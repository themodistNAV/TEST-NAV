OBJECT Codeunit 11102045 OM - Where Used Management
{
  OBJECT-PROPERTIES
  {
    Date=19/11/15;
    Time=12:00:00 PM;
    Version List=OMA10.00;
  }
  PROPERTIES
  {
    OnRun=BEGIN
            CASE RunType OF

              RunType::Default :
                StartCodeunit;

              RunType::"Update Where Used Object" :
                UpdateObjectLines(gObject);

              RunType::"Update Where Used In" :
                BEGIN
                  FillEntryNos;
                  UpdateWhereInOfObject(gObject);
                END;

              RunType::"Update Objects" :
                UpdateObjects;

            END;
          END;

  }
  CODE
  {
    VAR
      FirstObjectToUpdate@1000 : Record 2000000001;
      gObject@1001 : Record 2000000001;
      Window@1002 : Dialog;
      CrossTableEntryNo@1003 : Integer;
      PrevCALLineNo@1004 : Integer;
      PrevInEntryNo@1005 : Integer;
      PrevObjectEntryNo@1006 : Integer;
      PrevValidation@1007 : Integer;
      UsedInEntryNo@1008 : Integer;
      VariableBufferEntryNo@1009 : Integer;
      AskSqlTriggerInstalled@1010 : ' ,Yes,No';
      RunType@1011 : 'Default,Update Where Used Object,Update Where Used In,Update Objects';
      PrevIsTemporary2@1012 : Boolean;
      SaveVariableUsage@1013 : Boolean;

    PROCEDURE SetRunType@1(NewValue@1000 : Option;VAR NewObject@1001 : Record 2000000001;NewVariableUsage@1002 : Boolean);
    BEGIN
      RunType := NewValue;
      gObject := NewObject;
      SaveVariableUsage := NewVariableUsage;
    END;

    LOCAL PROCEDURE StartCodeunit@2();
    VAR
      Setup@1000 : Record 11102035;
      WhereUsedObject@1001 : Record 11102057;
      WhereUsedStatus@1002 : Codeunit 11102047;
      AllObjectsUpToDate@1003 : Boolean;
      CALUpToDate@1004 : Boolean;
      ObjectPresent@1005 : Boolean;
      ctNoObjectsFound@1006 : TextConst 'DEU=No Where Used Objects Found.\Update now?;ENU=No Where Used Objects Found.\Update now?;ESP=No Where Used Objects Found.\Update now?;FRA=No Where Used Objects Found.\Update now?;NLD=Geen waar-gebruikt objecten gevonden.\Nu bijwerken?;DEA=No Where Used Objects Found.\Update now?';
      ctNotAllUptoDate@1007 : TextConst 'DEU=Not all objects are up to date.\Update now?;ENU=Not all objects are up to date.\Update now?;ESP=Not all objects are up to date.\Update now?;FRA=Not all objects are up to date.\Update now?;NLD=Niet alle objecten zijn bijgewerkt. Nu bijwerken?;DEA=Not all objects are up to date.\Update now?';
    BEGIN
      ObjectPresent := WhereUsedObject.FINDFIRST;

      IF NOT WhereUsedStatus.RUN THEN
        EXIT;

      Setup.CustomGet;

      AllObjectsUpToDate := WhereUsedStatus.AllObjectsUpToDate;
      CALUpToDate := WhereUsedStatus.CALUpToDate;

      CASE TRUE OF

        NOT ObjectPresent :
          IF GUIALLOWED THEN
            IF NOT GuiConfirm(ctNoObjectsFound, TRUE) THEN
              EXIT;

        AllObjectsUpToDate :
          EXIT;

        ELSE
          IF GUIALLOWED THEN
            CASE Setup."Update Where Used" OF
              Setup."Update Where Used"::Confirm :
                IF NOT GuiConfirm(ctNotAllUptoDate, TRUE) THEN
                  EXIT;
              Setup."Update Where Used"::Never :
                EXIT;
            END;

      END;

      WhereUsedStatus.GetFirstObjectToUpdate(FirstObjectToUpdate);
      SetAskSqlTriggerInstalled(WhereUsedStatus.GetAskSqlTriggerInstalled);

      UpdateObjects;
    END;

    PROCEDURE UpdateObjects@3();
    VAR
      Setup@1000 : Record 11102035;
      CALHistoryObject@1001 : Record 11102052;
      WhereUsedObject@1002 : Record 11102057;
      Object@1003 : Record 2000000001;
      TmpUpdateCALObject@1004 : TEMPORARY Record 2000000001;
      TmpUpdateObjectLinesObject@1005 : TEMPORARY Record 2000000001;
      TmpUpdateWhereUsedInObject@1006 : TEMPORARY Record 2000000001;
      Mgt@1007 : Codeunit 11102035;
      WhereUsedMgt@1008 : Codeunit 11102045;
      WhereUsedStatus@1009 : Codeunit 11102047;
      SourceControl@1010 : Codeunit 11102050;
      NoOfObjects@1011 : Integer;
      ObjectCounter@1012 : Integer;
      UsedProgressbar@1013 : Integer;
      ctCheckingObjects@1014 : TextConst 'DEU=Checking objects...;ENU=Checking objects...;ESP=Checking objects...;FRA=Checking objects...;NLD=Objecten controleren...;DEA=Checking objects...';
      ctUpdateCALCode@1015 : TextConst 'DEU=Updating C/AL History...;ENU=Updating C/AL History...;ESP=Updating C/AL History...;FRA=Updating C/AL History...;NLD=C/AL Historie bijwerken...;DEA=Updating C/AL History...';
      ctUpdateObjectLines@1016 : TextConst 'DEU=Updating Where Used Objects...;ENU=Updating Where Used Objects...;ESP=Updating Where Used Objects...;FRA=Updating Where Used Objects...;NLD=Waar-gebruikt objecten bijwerken...;DEA=Updating Where Used Objects...';
      ctUpdateWhereUsedIn@1017 : TextConst 'DEU=Updating Where Used In...;ENU=Updating Where Used In...;ESP=Updating Where Used In...;FRA=Updating Where Used In...;NLD=Waar-gebruikt in bijwerken...;DEA=Updating Where Used In...';
      ctUpdateWhereUsedInFailed@1018 : TextConst 'DEU=Updating Where Used In failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;ENU=Updating Where Used In failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;ESP=Updating Where Used In failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;FRA=Updating Where Used In failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;NLD=Waar-gebruikt in bijwerken mislukt bij object:\\%1 %2 %3\\OMA Versienr.:%4 (%5)\Foutmelding: %6;DEA=Updating Where Used In failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6';
      ctUpdateWhereUsedInTables@1019 : TextConst 'DEU=Updating Where Used In Tables...;ENU=Updating Where Used In Tables...;ESP=Updating Where Used In Tables...;FRA=Updating Where Used In Tables...;NLD=Waar-gebruikt in tabellen bijwerken...;DEA=Updating Where Used In Tables...';
      ctUpdateWhereUsedObjectsFailed@1020 : TextConst 'DEU=Updating Where Used Object Lines failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;ENU=Updating Where Used Object Lines failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;ESP=Updating Where Used Object Lines failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;FRA=Updating Where Used Object Lines failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;NLD=Waar-gebruikt objectregels bijwerken mislukt bij object:\\%1 %2 %3\\OMA Versienr.:%4 (%5)\Foutmelding: %6;DEA=Updating Where Used Object Lines failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6';
    BEGIN
      IF GUIALLOWED THEN BEGIN
        Window.OPEN('#1#########################\#2#########################\@3@@@@@@@@@@@@@@@@@@@@@@@@@');
        Window.UPDATE(1, ctCheckingObjects);
      END;

      IF AskSqlTriggerInstalled = AskSqlTriggerInstalled::" " THEN
        SetAskSqlTriggerInstalled(WhereUsedStatus.SqlsAnswer <> '');

      IF AskSqlTriggerInstalled = AskSqlTriggerInstalled::Yes THEN
        NoOfObjects := GetObjectsWithAskSqlTrigger(TmpUpdateCALObject, TmpUpdateObjectLinesObject, TmpUpdateWhereUsedInObject)
      ELSE BEGIN
        RemoveDeletedObjects;
        NoOfObjects := GetObjectsWithObjectTable(TmpUpdateCALObject, TmpUpdateObjectLinesObject, TmpUpdateWhereUsedInObject);
      END;

      UsedProgressbar := 2500;

      COMMIT;

      ObjectCounter := 0;

      IF GUIALLOWED THEN
        Window.UPDATE(1, ctUpdateCALCode);

      WITH TmpUpdateCALObject DO
        IF FINDSET THEN
          REPEAT
            ObjectCounter += 1;

            IF GUIALLOWED THEN BEGIN
              Window.UPDATE(2, FORMAT(Type) + ' ' + FORMAT(ID) + ' ' + Name);
              Window.UPDATE(3, UsedProgressbar + ROUND(ObjectCounter / NoOfObjects * (10000 - UsedProgressbar), 1));
            END;

            SourceControl.AddObject(TmpUpdateCALObject, CALHistoryObject."Action Type"::"Update Where Used Objects", FALSE, TRUE, 2, FALSE);

            COMMIT;
          UNTIL NEXT = 0;

      IF GUIALLOWED THEN
        Window.UPDATE(1, ctUpdateObjectLines);

      WITH TmpUpdateObjectLinesObject DO
        IF FINDSET THEN
          REPEAT
            ObjectCounter += 1;

            IF GUIALLOWED THEN BEGIN
              Window.UPDATE(2, FORMAT(Type) + ' ' + FORMAT(ID) + ' ' + Name);
              Window.UPDATE(3, UsedProgressbar + ROUND(ObjectCounter / NoOfObjects * (10000 - UsedProgressbar), 1));
            END;

            WhereUsedMgt.SetRunType(1, TmpUpdateObjectLinesObject, SaveVariableUsage);

            COMMIT;

            IF NOT WhereUsedMgt.RUN THEN
              MESSAGE(
                STRSUBSTNO(ctUpdateWhereUsedObjectsFailed, Type, ID, Name, Setup.OMAVersionNo, Setup.DateOfObject, Mgt.GetLastError2));

            COMMIT;

          UNTIL NEXT = 0;

      AddVirtualTables;
      COMMIT;

      WhereUsedObject.SETCURRENTKEY("C/AL Changed");
      WhereUsedObject.SETRANGE("C/AL Changed", TRUE);
      IF WhereUsedObject.FINDSET THEN BEGIN
        NoOfObjects += WhereUsedObject.COUNT;

        IF GUIALLOWED THEN
          Window.UPDATE(1, ctUpdateCALCode);

        REPEAT
          ObjectCounter += 1;
          IF Object.GET(WhereUsedObject."Object Type", '', WhereUsedObject."Object No.") THEN BEGIN

            IF GUIALLOWED THEN BEGIN
              Window.UPDATE(2, FORMAT(Object.Type) + ' ' + FORMAT(Object.ID) + ' ' + Object.Name);
              Window.UPDATE(3, UsedProgressbar + ROUND(ObjectCounter / NoOfObjects * (10000 - UsedProgressbar), 1));
            END;

            SourceControl.AddObject(Object, CALHistoryObject."Action Type"::"Update Where Used Objects", FALSE, TRUE, 2, FALSE);

            WhereUsedObject."C/AL Changed" := FALSE;
            IF CALHistoryObject.TryGoToLastRecord(Object.Type, Object.ID) THEN
              WhereUsedObject."C/AL Code Entry No." := CALHistoryObject."Entry No.";
            WhereUsedObject.MODIFY;
          END;
          COMMIT;
        UNTIL WhereUsedObject.NEXT = 0;
      END;
      WhereUsedObject.SETRANGE("C/AL Changed");

      IF GUIALLOWED THEN
        Window.UPDATE(1, ctUpdateWhereUsedIn);

      WITH TmpUpdateWhereUsedInObject DO
        IF FINDSET THEN
          REPEAT
            ObjectCounter += 1;

            IF GUIALLOWED THEN BEGIN
              Window.UPDATE(2, FORMAT(Type) + ' ' + FORMAT(ID) + ' ' + Name);
              Window.UPDATE(3, UsedProgressbar + ROUND(ObjectCounter / NoOfObjects * (10000 - UsedProgressbar), 1));
            END;

            WhereUsedMgt.SetRunType(2, TmpUpdateWhereUsedInObject, SaveVariableUsage);

            COMMIT;
            IF NOT WhereUsedMgt.RUN THEN
              MESSAGE(STRSUBSTNO(ctUpdateWhereUsedInFailed, Type, ID, Name, Setup.OMAVersionNo, Setup.DateOfObject, Mgt.GetLastError2));
            COMMIT;

          UNTIL NEXT = 0;

      IF GUIALLOWED THEN
        Window.UPDATE(1, ctUpdateWhereUsedInTables);

      UpdateData;

      IF GUIALLOWED THEN
        Window.UPDATE(1, ctUpdateWhereUsedIn);

      WhereUsedObject.SETCURRENTKEY(Status);
      WhereUsedObject.SETRANGE(Status, WhereUsedObject.Status::"Lines Updated");
      IF WhereUsedObject.FINDSET THEN BEGIN
        NoOfObjects += WhereUsedObject.COUNT;
        REPEAT
          WITH Object DO
            IF GET(WhereUsedObject."Object Type", '', WhereUsedObject."Object No.") THEN BEGIN
              ObjectCounter += 1;

              IF GUIALLOWED THEN BEGIN
                Window.UPDATE(2, FORMAT(Type) + ' ' + FORMAT(ID) + ' ' + Name);
                Window.UPDATE(3, UsedProgressbar + ROUND(ObjectCounter / NoOfObjects * (10000 - UsedProgressbar), 1));
              END;

              WhereUsedMgt.SetRunType(2, Object, SaveVariableUsage);

              COMMIT;
              IF NOT WhereUsedMgt.RUN THEN
                MESSAGE(STRSUBSTNO(ctUpdateWhereUsedInFailed, Type, ID, Name, Setup.OMAVersionNo, Setup.DateOfObject, Mgt.GetLastError2));
              COMMIT;

            END;

        UNTIL WhereUsedObject.NEXT = 0;
      END;

      IF GUIALLOWED THEN
        Window.CLOSE;
    END;

    LOCAL PROCEDURE GetObjectsWithObjectTable@4(VAR TmpUpdateCALObject@1000 : TEMPORARY Record 2000000001;VAR TmpUpdateObjectLinesObject@1001 : TEMPORARY Record 2000000001;VAR TmpUpdateWhereUsedInObject@1002 : TEMPORARY Record 2000000001) NoOfObjects : Integer;
    VAR
      Object@1003 : Record 2000000001;
      WhereUsedStatus@1004 : Codeunit 11102047;
      ObjectCounter@1005 : Integer;
      StatusOfObject@1006 : Integer;
      TotalNoOfObjects@1007 : Integer;
    BEGIN
      Object.SETFILTER(Type, '<>%1', Object.Type::TableData);
      Object.SETRANGE("Company Name", '');
      Object.SETFILTER("BLOB Size", '>0');
      TotalNoOfObjects := Object.COUNT;
      IF Object.FINDSET THEN BEGIN

        IF FirstObjectToUpdate.ID <> 0 THEN
          Object := FirstObjectToUpdate;

        REPEAT

          ObjectCounter += 1;

          IF GUIALLOWED AND (ObjectCounter MOD 100 = 0) THEN
            Window.UPDATE(3, ROUND(ObjectCounter / TotalNoOfObjects * 2500, 1));

          StatusOfObject := WhereUsedStatus.StatusOfObject(Object);
          IF StatusOfObject <> 0 THEN BEGIN

            IF GUIALLOWED THEN
              Window.UPDATE(2, FORMAT(Object.Type) + ' ' + FORMAT(Object.ID) + ' ' + Object.Name);

            IF StatusOfObject = 1 THEN BEGIN
              TmpUpdateCALObject := Object;
              TmpUpdateCALObject.INSERT;
              NoOfObjects += 1;
            END;

            IF StatusOfObject IN [1, 2] THEN BEGIN
              TmpUpdateObjectLinesObject := Object;
              TmpUpdateObjectLinesObject.INSERT;
              NoOfObjects += 1;
            END;

            IF StatusOfObject IN [1, 2, 3] THEN BEGIN
              TmpUpdateWhereUsedInObject := Object;
              TmpUpdateWhereUsedInObject.INSERT;
              NoOfObjects += 1;
            END;

          END;

        UNTIL Object.NEXT = 0;

      END;
    END;

    LOCAL PROCEDURE GetObjectsWithAskSqlTrigger@5(VAR TmpUpdateCALObject@1000 : TEMPORARY Record 2000000001;VAR TmpUpdateObjectLinesObject@1001 : TEMPORARY Record 2000000001;VAR TmpUpdateWhereUsedInObject@1002 : TEMPORARY Record 2000000001) NoOfObjects : Integer;
    VAR
      WhereUsedObject@1003 : Record 11102057;
      ObjectsToUpdate@1004 : Record 11102059;
      Object@1005 : Record 2000000001;
      WhereUsedStatus@1006 : Codeunit 11102047;
      ObjectCounter@1007 : Integer;
      StatusOfObject@1008 : Integer;
      TotalNoOfObjects@1009 : Integer;
    BEGIN
      TotalNoOfObjects := ObjectsToUpdate.COUNT;
      IF ObjectsToUpdate.FINDSET THEN
        REPEAT

          ObjectCounter += 1;

          IF GUIALLOWED AND (ObjectCounter MOD 100 = 0) THEN
            Window.UPDATE(3, ROUND(ObjectCounter / TotalNoOfObjects * 2500, 1));

          IF Object.GET(ObjectsToUpdate."Object Type", '', ObjectsToUpdate."Object No.") THEN BEGIN

            StatusOfObject := WhereUsedStatus.StatusOfObject(Object);
            IF StatusOfObject <> 0 THEN BEGIN

              IF GUIALLOWED THEN
                Window.UPDATE(2, FORMAT(Object.Type) + ' ' + FORMAT(Object.ID) + ' ' + Object.Name);

              IF StatusOfObject = 1 THEN BEGIN
                TmpUpdateCALObject := Object;
                TmpUpdateCALObject.INSERT;
                NoOfObjects += 1;
              END;

              IF StatusOfObject IN [1, 2, 4] THEN BEGIN
                TmpUpdateObjectLinesObject := Object;
                TmpUpdateObjectLinesObject.INSERT;
                NoOfObjects += 1;
              END;

              IF StatusOfObject IN [1, 2, 3] THEN BEGIN
                TmpUpdateWhereUsedInObject := Object;
                TmpUpdateWhereUsedInObject.INSERT;
                NoOfObjects += 1;
              END;

            END;
          END ELSE
            IF WhereUsedObject.GET(ObjectsToUpdate."Object Type", ObjectsToUpdate."Object No.") THEN
              WhereUsedObject.DELETE(TRUE);

        UNTIL ObjectsToUpdate.NEXT = 0;
    END;

    PROCEDURE FillEntryNos@6();
    VAR
      WhereUsedIn@1000 : Record 11102060;
      CrossTable@1001 : Record 11102061;
    BEGIN
      IF CrossTable.FINDLAST THEN
        CrossTableEntryNo := CrossTable."Entry No.";

      IF WhereUsedIn.FINDLAST THEN
        UsedInEntryNo := WhereUsedIn."Entry No.";
    END;

    LOCAL PROCEDURE RemoveDeletedObjects@7();
    VAR
      WhereUsedObject@1000 : Record 11102057;
      WhereUsedObject2@1001 : Record 11102057;
      Object@1002 : Record 2000000001;
    BEGIN
      WhereUsedObject.SETFILTER("Object No.", '<2000000000');
      IF WhereUsedObject.FINDSET THEN BEGIN
        REPEAT
          IF NOT Object.GET(WhereUsedObject."Object Type", '', WhereUsedObject."Object No.") THEN BEGIN
            WhereUsedObject2 := WhereUsedObject;
            WhereUsedObject2.DELETE(TRUE);
          END;
        UNTIL WhereUsedObject.NEXT = 0;
        COMMIT;
      END;
    END;

    LOCAL PROCEDURE AddVirtualTables@8();
    VAR
      WhereUsedObject@1000 : Record 11102057;
      WhereUsedObjectLine@1001 : Record 11102058;
      Object@1002 : Record 2000000001;
      AllObj@1003 : Record 2000000038;
      Field@1004 : Record 2000000041;
      RecRef@1005 : RecordRef;
      FldRef@1006 : FieldRef;
      KeyRef@1007 : KeyRef;
      PrimaryKeyRef@1008 : KeyRef;
      Trigger@1009 : ARRAY [10] OF Text;
      i@1010 : Integer;
      j@1011 : Integer;
      k@1012 : Integer;
      PrimaryKeyFieldPresent@1013 : Boolean;
    BEGIN
      AllObj.SETRANGE("Object Type", AllObj."Object Type"::Table);
      AllObj.SETFILTER("Object ID", '>=2000000000');

      IF AllObj.FINDSET THEN
        REPEAT
          IF NOT Object.GET(AllObj."Object Type", '', AllObj."Object ID") THEN
            IF NOT WhereUsedObject.GET(AllObj."Object Type", AllObj."Object ID") THEN BEGIN
              WhereUsedObject."Object Type" := AllObj."Object Type";
              WhereUsedObject."Object No." := AllObj."Object ID";
              WhereUsedObject.Name := AllObj."Object Name";

              WhereUsedObjectLine."Entry No." := 0;
              WhereUsedObjectLine."Object Type" := AllObj."Object Type";
              WhereUsedObjectLine."Object No." := AllObj."Object ID";
              WhereUsedObjectLine.Id := AllObj."Object ID";
              WhereUsedObjectLine.Enabled := TRUE;
              WhereUsedObjectLine.Type := WhereUsedObjectLine.Type::Object;
              WhereUsedObjectLine.Name := AllObj."Object Name";
              WhereUsedObjectLine.INSERT;

              WhereUsedObject."Object Line Entry No." := WhereUsedObjectLine."Entry No.";
              WhereUsedObject.INSERT;

              GetTriggers(Object.Type::Table, Trigger);

              FOR i := 1 TO ARRAYLEN(Trigger) DO
                IF Trigger[i] <> '' THEN BEGIN
                  WhereUsedObjectLine."Entry No." := 0;
                  WhereUsedObjectLine."Object Type" := AllObj."Object Type";
                  WhereUsedObjectLine."Object No." := AllObj."Object ID";
                  WhereUsedObjectLine.Enabled := TRUE;
                  WhereUsedObjectLine.Type := WhereUsedObjectLine.Type::Trigger;
                  WhereUsedObjectLine.Id := i;
                  WhereUsedObjectLine.Name := Trigger[i];
                  WhereUsedObjectLine.INSERT;
                END;

              Field.SETRANGE(TableNo, AllObj."Object ID");
              IF Field.FINDSET THEN
                REPEAT
                  WhereUsedObjectLine."Entry No." := 0;
                  WhereUsedObjectLine."Object Type" := AllObj."Object Type";
                  WhereUsedObjectLine."Object No." := AllObj."Object ID";
                  WhereUsedObjectLine.Enabled := TRUE;
                  WhereUsedObjectLine.Type := WhereUsedObjectLine.Type::Field;
                  WhereUsedObjectLine.Id := Field."No.";
                  WhereUsedObjectLine.Name := Field.FieldName;
                  WhereUsedObjectLine.INSERT;
                UNTIL Field.NEXT = 0;

              RecRef.OPEN(AllObj."Object ID");
              FOR i := 1 TO RecRef.KEYCOUNT DO BEGIN
                WhereUsedObjectLine."Entry No." := 0;
                WhereUsedObjectLine."Object Type" := AllObj."Object Type";
                WhereUsedObjectLine."Object No." := AllObj."Object ID";
                WhereUsedObjectLine.Enabled := TRUE;
                WhereUsedObjectLine.Type := WhereUsedObjectLine.Type::Key;
                WhereUsedObjectLine.Id := i;
                WhereUsedObjectLine.Name := '';

                KeyRef := RecRef.KEYINDEX(i);
                FOR j := 1 TO KeyRef.FIELDCOUNT DO BEGIN
                  FldRef := KeyRef.FIELDINDEX(j);
                  IF WhereUsedObjectLine.Name = '' THEN
                    WhereUsedObjectLine.Name := FORMAT(FldRef.NUMBER)
                  ELSE
                    WhereUsedObjectLine.Name += ',' + FORMAT(FldRef.NUMBER);
                END;
                WhereUsedObjectLine."Name to Display" := WhereUsedObjectLine.Name;

                PrimaryKeyRef := RecRef.KEYINDEX(1);

                FOR k := 1 TO PrimaryKeyRef.FIELDCOUNT DO BEGIN
                  PrimaryKeyFieldPresent := FALSE;
                  FOR j := 1 TO KeyRef.FIELDCOUNT DO
                    IF PrimaryKeyRef.FIELDINDEX(k).NUMBER = KeyRef.FIELDINDEX(j).NUMBER THEN
                      PrimaryKeyFieldPresent := TRUE;

                  IF NOT PrimaryKeyFieldPresent THEN
                    WhereUsedObjectLine.Name += ',' + FORMAT(PrimaryKeyRef.FIELDINDEX(k).NUMBER);

                END;

                WhereUsedObjectLine.INSERT;
                WhereUsedObjectLine."Name to Display" := '';
              END;
              RecRef.CLOSE;

            END;
        UNTIL AllObj.NEXT = 0;
    END;

    PROCEDURE UpdateObjectLines@9(VAR Object@1000 : Record 2000000001);
    VAR
      CALHistoryObject@1001 : Record 11102052;
      WhereUsedObject@1002 : Record 11102057;
      ObjectLine@1003 : Record 11102058;
      TmpObjectLine@1004 : TEMPORARY Record 11102058;
      SourceControl@1005 : Codeunit 11102050;
      TableNo@1006 : Integer;
      DoInsert@1007 : Boolean;
    BEGIN
      IF SourceControl.ObjectHeaderIsOutdated(Object, FALSE) THEN
        EXIT;

      IF NOT CALHistoryObject.TryGoToLastRecord(Object.Type, Object.ID) THEN
        EXIT;

      GetObjectLines(CALHistoryObject, TmpObjectLine, TableNo);

      WriteObjectLines(CALHistoryObject, TmpObjectLine);

      ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
      ObjectLine.SETRANGE("Object Type", CALHistoryObject."Object Type");
      ObjectLine.SETRANGE("Object No.", CALHistoryObject."Object No.");
      ObjectLine.SETRANGE(Type, ObjectLine.Type::Object);
      ObjectLine.FINDFIRST;

      IF NOT WhereUsedObject.GET(Object.Type, Object.ID) THEN BEGIN
        DoInsert := TRUE;
        WhereUsedObject."Object Type" := Object.Type;
        WhereUsedObject."Object No." := Object.ID;
      END;
      WhereUsedObject.Status := WhereUsedObject.Status::"Lines Updated";
      WhereUsedObject.Name := Object.Name;
      WhereUsedObject."Object Date" := Object.Date;
      WhereUsedObject."Object Time" := Object.Time;
      WhereUsedObject."Object Modified" := Object.Modified;
      WhereUsedObject."Object Line Entry No." := ObjectLine."Entry No.";
      WhereUsedObject."Table No." := TableNo;
      WhereUsedObject."Version No." := 701;
      WhereUsedObject."C/AL Code Entry No." := CALHistoryObject."Entry No.";
      WhereUsedObject."Variable Usage Calculated" := FALSE;
      IF DoInsert THEN
        WhereUsedObject.INSERT
      ELSE
        WhereUsedObject.MODIFY;
    END;

    LOCAL PROCEDURE GetObjectLines@10(VAR CALHistoryObject@1000 : Record 11102052;VAR ObjectLine@1001 : Record 11102058;VAR TableNo@1002 : Integer);
    VAR
      CALHistoryLine@1003 : Record 11102053;
      CALHistoryLine2@1004 : Record 11102053;
      Fld@1005 : Record 2000000041;
      Mgt@1006 : Codeunit 11102035;
      CodeLine@1007 : Text;
      DataSource@1008 : Text;
      EnabledText@1009 : Text;
      FieldName2@1010 : Text;
      FieldNoText@1011 : Text;
      IndentString@1012 : Text;
      Key@1013 : Text;
      KeyField@1014 : ARRAY [100] OF Text;
      KeyString@1015 : Text;
      KeyToDisplay@1016 : Text;
      Method@1017 : Text;
      ObjectNoString@1018 : Text;
      PrimaryKeyField@1019 : ARRAY [100] OF Text;
      ProcedureIdString@1020 : Text;
      ProcedureName@1021 : Text;
      PropertyName@1022 : Text;
      PropertyValue@1023 : Text;
      Trigger@1024 : ARRAY [10] OF Text;
      TypeName@1025 : Text;
      CALLineNo@1026 : Integer;
      FieldNo2@1027 : Integer;
      i@1028 : Integer;
      j@1029 : Integer;
      KeyCounter@1030 : Integer;
      KeyFieldCounter@1031 : Integer;
      Position@1032 : Integer;
      PrimaryKeyFieldCounter@1033 : Integer;
      ProcedureId@1034 : Integer;
      SplitPos@1035 : Integer;
      SumIndexFieldCounter@1036 : Integer;
      Enabled@1037 : Boolean;
      IsLocal@1038 : Boolean;
      PrimaryKeyFieldPresent@1039 : Boolean;
      StopLoop@1040 : Boolean;
    BEGIN
      AddObjectLineRecord(
        ObjectLine, TRUE, ObjectLine.Type::Object, CALHistoryObject."Object No.", CALHistoryObject."Object Name", 0, 0, '', '');

      GetTriggers(CALHistoryObject."Object Type", Trigger);
      FOR i := 1 TO ARRAYLEN(Trigger) DO
        IF Trigger[i] <> '' THEN
          AddObjectLineRecord(ObjectLine, TRUE, ObjectLine.Type::Trigger, i, Trigger[i], 0, 0, '', '');

      CASE CALHistoryObject."Object Type" OF

        CALHistoryObject."Object Type"::Table :
          BEGIN

            IF SetRangeOnSection(CALHistoryObject, CALHistoryLine, 'FIELDS') THEN BEGIN
              CALHistoryLine.SETRANGE("Sub Line No.", 1);
              CALHistoryLine.SETFILTER(Code, '%1', '    {*');
              IF CALHistoryLine.FINDSET THEN
                REPEAT
                  Position := 7;
                  Mgt.NextValue(CALHistoryLine.Code, Position, ';', '[', ']', FieldNoText);
                  EVALUATE(FieldNo2, FieldNoText);
                  Mgt.NextValue(CALHistoryLine.Code, Position, ';', '[', ']', EnabledText);
                  Mgt.NextValue(CALHistoryLine.Code, Position, ';', '[', ']', FieldName2);
                  Mgt.NextValue(CALHistoryLine.Code, Position, ';', '[', ']', TypeName);
                  TypeName := DELCHR(TypeName, '>', ' }');
                  Enabled := NOT (EnabledText = 'No');
                  AddObjectLineRecord(
                    ObjectLine, Enabled, ObjectLine.Type::Field, FieldNo2, FieldName2, CALHistoryLine."Line No.", 0, TypeName, '');

                UNTIL CALHistoryLine.NEXT = 0;
            END;

            IF SetRangeOnSection(CALHistoryObject, CALHistoryLine, 'KEYS') THEN BEGIN
              CALHistoryLine.SETRANGE("Sub Line No.", 1);
              CALHistoryLine.SETFILTER(Code, '%1', '    {*');
              IF CALHistoryLine.FINDSET THEN
                REPEAT
                  KeyCounter += 1;
                  CodeLine := CALHistoryLine.Code;
                  IF CodeLine[STRLEN(CodeLine)] <> '}' THEN BEGIN
                    CALHistoryLine2.RESET;
                    CALHistoryLine2.SETRANGE("Entry No.", CALHistoryLine."Entry No.");
                    CALHistoryLine2.SETRANGE("Line No.", CALHistoryLine."Line No.");
                    CALHistoryLine2.SETFILTER("Sub Line No.", '>%1', CALHistoryLine."Sub Line No.");
                    IF CALHistoryLine2.FINDSET THEN
                      REPEAT
                        CodeLine += CALHistoryLine2.Code;
                      UNTIL CALHistoryLine2.NEXT = 0;
                  END;

                  Position := 7;
                  Mgt.NextValue(CodeLine, Position, ';', '[', ']', EnabledText);
                  Enabled := NOT (EnabledText = 'No');

                  Mgt.NextValue(CodeLine, Position, ';', '[', ']', Key);
                  IF Key <> '' THEN BEGIN
                    IF Key[STRLEN(Key)] = '}' THEN BEGIN
                      Key := DELSTR(Key, STRLEN(Key));
                      Key := DELCHR(Key, '<>');
                    END;
                    IF Key <> '' THEN BEGIN
                      Position := 1;
                      KeyFieldCounter := 0;
                      WHILE Mgt.NextValue(Key, Position, ',', '"', '"', FieldName2) DO BEGIN
                        KeyFieldCounter += 1;
                        KeyField[KeyFieldCounter] := FieldName2;
                        IF KeyCounter = 1 THEN BEGIN
                          PrimaryKeyFieldCounter += 1;
                          PrimaryKeyField[KeyFieldCounter] := FieldName2;
                        END;
                      END;
                      KeyString := '';
                      FOR i := 1 TO KeyFieldCounter DO BEGIN
                        Fld.SETRANGE(TableNo, CALHistoryObject."Object No.");
                        Fld.SETRANGE(FieldName, KeyField[i]);
                        IF Fld.FINDFIRST THEN
                          KeyString += ',' + FORMAT(Fld."No.");
                      END;

                      KeyToDisplay := COPYSTR(KeyString, 2);

                      FOR i := 1 TO PrimaryKeyFieldCounter DO BEGIN
                        PrimaryKeyFieldPresent := FALSE;
                        FOR j := 1 TO KeyFieldCounter DO
                          IF PrimaryKeyField[i] = KeyField[j] THEN
                            PrimaryKeyFieldPresent := TRUE;

                        IF NOT PrimaryKeyFieldPresent THEN BEGIN
                          Fld.SETRANGE(TableNo, CALHistoryObject."Object No.");
                          Fld.SETRANGE(FieldName, PrimaryKeyField[i]);
                          IF Fld.FINDFIRST THEN
                            KeyString += ',' + FORMAT(Fld."No.");
                        END;

                      END;

                      KeyString := COPYSTR(KeyString, 2);
                      AddObjectLineRecord(
                        ObjectLine, Enabled, ObjectLine.Type::Key, KeyCounter, KeyString, CALHistoryLine."Line No.", 0, '', '');

                      ObjectLine."Name to Display" := KeyToDisplay;
                      ObjectLine.MODIFY;
                      ObjectLine."Name to Display" := '';

                      StopLoop := FALSE;
                      CALHistoryLine2.RESET;
                      CALHistoryLine2.SETRANGE("Entry No.", CALHistoryLine."Entry No.");
                      CALHistoryLine2.SETRANGE("Line No.", CALHistoryLine."Line No.", CALHistoryLine.GETRANGEMAX("Line No."));
                      CALHistoryLine2.SETRANGE("Sub Line No.", 1);
                      IF CALHistoryLine2.FINDSET THEN
                        REPEAT
                          IF (CALHistoryLine2."Line No." > CALHistoryLine."Line No.") AND
                             (CALHistoryLine2."Sub Line No." = 1) AND
                             (CALHistoryLine2.Code[5] = '{')
                          THEN
                            StopLoop := TRUE
                          ELSE BEGIN
                            CALHistoryLine2.Code := COPYSTR(CALHistoryLine2.Code, 52);
                            GetPropertyName(CALHistoryLine2, PropertyName);
                            IF PropertyName = 'SumIndexFields' THEN BEGIN
                              GetPropertyValue(CALHistoryLine2, PropertyValue);
                              Position := 1;
                              SumIndexFieldCounter := 0;
                              WHILE Mgt.NextValue(PropertyValue, Position, ',', '"', '"', FieldName2) DO BEGIN
                                SumIndexFieldCounter += 1;
                                AddObjectLineRecord(
                                  ObjectLine, Enabled, ObjectLine.Type::"Sum Index Field", KeyCounter * 100 + SumIndexFieldCounter,
                                  FieldName2, CALHistoryLine."Line No.", KeyCounter, '', '');
                              END;
                            END;
                          END;
                        UNTIL (CALHistoryLine2.NEXT = 0) OR StopLoop;
                    END;

                  END;

                UNTIL CALHistoryLine.NEXT = 0;
            END;

          END;

        CALHistoryObject."Object Type"::Query :
          IF SetRangeOnSection(CALHistoryObject, CALHistoryLine, 'ELEMENTS') THEN BEGIN
            CALHistoryLine.SETRANGE("Sub Line No.", 1);
            IF CALHistoryLine.FINDSET THEN
              REPEAT
                IF CALHistoryLine.Code <> '' THEN BEGIN
                  IF CALHistoryLine.Code[5] = '{' THEN BEGIN
                    FieldName2 := '';
                    DataSource := '';
                    Method := '';
                    Position := 6;
                    CALLineNo := CALHistoryLine."Line No.";
                    Mgt.NextValue(CALHistoryLine.Code, Position, ';', '[', ']', FieldNoText);
                    EVALUATE(FieldNo2, FieldNoText);
                    Mgt.NextValue(CALHistoryLine.Code, Position, ';', '[', ']', IndentString);
                    Mgt.NextValue(CALHistoryLine.Code, Position, ';', '[', ']', TypeName);
                    Mgt.NextValue(CALHistoryLine.Code, Position, ';', '[', ']', FieldName2);
                  END;
                  IF COPYSTR(CALHistoryLine.Code, 16, 10) = 'DataSource' THEN
                    GetPropertyValue(CALHistoryLine, DataSource);
                  IF COPYSTR(CALHistoryLine.Code, 16, 7) = 'Method=' THEN
                    GetPropertyValue(CALHistoryLine, Method);
                  IF CALHistoryLine.Code[STRLEN(CALHistoryLine.Code)] = '}' THEN
                    IF DataSource <> '' THEN BEGIN
                      IF FieldName2 = '' THEN
                        FieldName2 := QueryFieldName(DataSource, Method);
                      AddObjectLineRecord(ObjectLine, TRUE, ObjectLine.Type::Field, FieldNo2, FieldName2, CALLineNo, 0, '', '');
                    END;
                END;
              UNTIL CALHistoryLine.NEXT = 0;
          END;

      END;

      IF SetRangeOnSection(CALHistoryObject, CALHistoryLine, 'CODE') THEN BEGIN
        CALHistoryLine.SETFILTER(Code, '%1|%2|%3', '    PROCEDURE *', '    LOCAL PROCEDURE *', '    EVENT *');
        IF CALHistoryLine.FINDSET THEN
          REPEAT

            ProcedureIdString := '';

            CASE CALHistoryLine.Code[5] OF
              'L' :
                BEGIN
                  IsLocal := TRUE;
                  Position := 21;
                  Mgt.NextValue(CALHistoryLine.Code, Position, '@', '"', '"', ProcedureName);
                  ProcedureIdString := COPYSTR(CALHistoryLine.Code, Position);

                  SplitPos := STRPOS(ProcedureIdString, '(');
                  IF SplitPos = 0 THEN BEGIN
                    SplitPos := STRPOS(ProcedureName, '(');
                    IF SplitPos > 0 THEN
                      ProcedureName := DELSTR(ProcedureName, SplitPos);
                    ProcedureIdString := '0';
                  END ELSE
                    ProcedureIdString := DELSTR(ProcedureIdString, SplitPos);

                END;
              'E' :
                BEGIN
                  IsLocal := TRUE;
                  Position := STRPOS(CALHistoryLine.Code, '::');
                  ProcedureName := COPYSTR(CALHistoryLine.Code, 11, Position - 11);
                  SplitPos := STRPOS(ProcedureName, '@');
                  IF SplitPos > 0 THEN
                    ProcedureName := DELSTR(ProcedureName, STRPOS(ProcedureName, '@'));
                  ProcedureIdString := COPYSTR(CALHistoryLine.Code, Position + 2);
                  IF STRPOS(ProcedureIdString, '@') = 0 THEN
                    ProcedureIdString := ''
                  ELSE
                    ProcedureIdString := DELSTR(ProcedureIdString, STRPOS(ProcedureIdString, '@'));
                  ProcedureName := ProcedureName + '::' + ProcedureIdString;
                  ProcedureIdString := '0';
                END;

              ELSE BEGIN
                IsLocal := FALSE;
                Position := 15;
                Mgt.NextValue(CALHistoryLine.Code, Position, '@', '"', '"', ProcedureName);
                ProcedureIdString := COPYSTR(CALHistoryLine.Code, Position);
                IF ProcedureIdString = '' THEN BEGIN
                  ProcedureName := DELSTR(ProcedureName, STRPOS(ProcedureName, '('));
                  ProcedureIdString := '0';
                END ELSE
                  ProcedureIdString := DELSTR(ProcedureIdString, STRPOS(ProcedureIdString, '('));

              END;
            END;

            IF EVALUATE(ProcedureId, ProcedureIdString) THEN
              IF IsLocal THEN
                AddObjectLineRecord(
                  ObjectLine, TRUE, ObjectLine.Type::"Local Function",
                  ProcedureId, ProcedureName, CALHistoryLine."Line No.", 0, '', '')
              ELSE
                AddObjectLineRecord(
                  ObjectLine, TRUE, ObjectLine.Type::"Global Function",
                  ProcedureId, ProcedureName, CALHistoryLine."Line No.", 0, '', '');

          UNTIL CALHistoryLine.NEXT = 0;
      END;

      TableNo := 0;
      IF CALHistoryObject."Object Type" = CALHistoryObject."Object Type"::Page THEN BEGIN
        CALHistoryLine.RESET;
        CALHistoryLine.SETRANGE("Entry No.", CALHistoryObject."Entry No.");
        CALHistoryLine.SETFILTER(Code, '%1', '    SourceTable=*');
        IF CALHistoryLine.FINDFIRST THEN BEGIN
          ObjectNoString := COPYSTR(CALHistoryLine.Code, 22);
          ObjectNoString := DELSTR(ObjectNoString, STRLEN(ObjectNoString));
          EVALUATE(TableNo, ObjectNoString);
        END;
      END;
    END;

    LOCAL PROCEDURE WriteObjectLines@11(VAR CALHistoryObject@1000 : Record 11102052;VAR TmpNewObjectLine@1001 : TEMPORARY Record 11102058);
    VAR
      ExistingObjectLine@1002 : Record 11102058;
      ObjectLine@1003 : Record 11102058;
      CompareType@1004 : 'Existing Further,Same,New Further';
      ExistingAtEnd@1005 : Boolean;
      IsQuery@1006 : Boolean;
      NewAtEnd@1007 : Boolean;
      UpdateRelatedObjects@1008 : Boolean;
    BEGIN
      TmpNewObjectLine.RESET;
      TmpNewObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
      NewAtEnd := NOT TmpNewObjectLine.FINDFIRST;

      ExistingObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
      ExistingObjectLine.SETRANGE("Object Type", CALHistoryObject."Object Type");
      ExistingObjectLine.SETRANGE("Object No.", CALHistoryObject."Object No.");
      ExistingAtEnd := NOT ExistingObjectLine.FINDFIRST;

      IsQuery := CALHistoryObject."Object Type" = CALHistoryObject."Object Type"::Query;

      WHILE NOT NewAtEnd OR NOT ExistingAtEnd DO

        CASE TRUE OF

          ExistingAtEnd :
            BEGIN
              ObjectLine := TmpNewObjectLine;
              CLEAR(ObjectLine."Entry No.");
              ObjectLine."Object Type" := CALHistoryObject."Object Type";
              ObjectLine."Object No." := CALHistoryObject."Object No.";
              ObjectLine.INSERT(TRUE);
              NewAtEnd := TmpNewObjectLine.NEXT(1) = 0;
            END;

          NewAtEnd :
            BEGIN
              ExistingObjectLine.DELETE(TRUE);
              ExistingAtEnd := ExistingObjectLine.NEXT(1) = 0;
            END;

          ELSE

            CASE CompareExistingNew(ExistingObjectLine, TmpNewObjectLine) OF
              CompareType::"Existing Further" :
                BEGIN
                  ObjectLine := TmpNewObjectLine;
                  CLEAR(ObjectLine."Entry No.");
                  ObjectLine."Object Type" := CALHistoryObject."Object Type";
                  ObjectLine."Object No." := CALHistoryObject."Object No.";
                  ObjectLine.INSERT(TRUE);
                  IF (ObjectLine.Type = ObjectLine.Type::Key) OR IsQuery THEN
                    UpdateRelatedObjects := TRUE;
                  NewAtEnd := TmpNewObjectLine.NEXT(1) = 0;
                END;

              CompareType::Same :
                BEGIN
                  IF (ExistingObjectLine.Name <> TmpNewObjectLine.Name) OR
                     (ExistingObjectLine."Name to Display" <> TmpNewObjectLine."Name to Display") OR
                     (ExistingObjectLine.Enabled <> TmpNewObjectLine.Enabled) OR
                     (ExistingObjectLine."C/AL Line No." <> TmpNewObjectLine."C/AL Line No.") OR
                     (ExistingObjectLine."Type Name" <> TmpNewObjectLine."Type Name") OR
                     (ExistingObjectLine."No. of Variables" <> TmpNewObjectLine."No. of Variables") OR
                     (ExistingObjectLine."No. of Parameters" <> TmpNewObjectLine."No. of Parameters") OR
                     (ExistingObjectLine."No. of Return Values" <> TmpNewObjectLine."No. of Return Values")
                  THEN BEGIN

                    IF (ExistingObjectLine.Type = ExistingObjectLine.Type::Key) AND
                       ((ExistingObjectLine.Name <> TmpNewObjectLine.Name) OR
                         (ExistingObjectLine.Enabled <> TmpNewObjectLine.Enabled))
                    THEN
                      UpdateRelatedObjects := TRUE;

                    IF (ExistingObjectLine.Name <> TmpNewObjectLine.Name) OR IsQuery THEN
                      UpdateCALChanged(ExistingObjectLine);

                    ExistingObjectLine.Name := TmpNewObjectLine.Name;
                    ExistingObjectLine.Enabled := TmpNewObjectLine.Enabled;
                    ExistingObjectLine."C/AL Line No." := TmpNewObjectLine."C/AL Line No.";
                    ExistingObjectLine."Name to Display" := TmpNewObjectLine."Name to Display";
                    ExistingObjectLine."Type Name" := TmpNewObjectLine."Type Name";
                    ExistingObjectLine."No. of Variables" := TmpNewObjectLine."No. of Variables";
                    ExistingObjectLine."No. of Parameters" := TmpNewObjectLine."No. of Parameters";
                    ExistingObjectLine."No. of Return Values" := TmpNewObjectLine."No. of Return Values";
                    ExistingObjectLine.MODIFY;
                  END;

                  ExistingAtEnd := ExistingObjectLine.NEXT(1) = 0;
                  NewAtEnd := TmpNewObjectLine.NEXT(1) = 0;
                END;

              CompareType::"New Further" :
                BEGIN

                  IF (ExistingObjectLine.Type = ExistingObjectLine.Type::Key) OR IsQuery THEN
                    UpdateRelatedObjects := TRUE;

                  ExistingObjectLine.DELETE(TRUE);
                  ExistingAtEnd := ExistingObjectLine.NEXT(1) = 0;
                END;

            END;
        END;

      IF UpdateRelatedObjects THEN
        SetUpdateRelatedObject(CALHistoryObject."Object Type", CALHistoryObject."Object No.");
    END;

    LOCAL PROCEDURE SetUpdateRelatedObject@12(VAR ObjectType2@1000 : Option;VAR ObjectNo@1001 : Integer);
    VAR
      WhereUsedObject@1002 : Record 11102057;
      WhereUsedObject2@1003 : Record 11102057;
      WhereUsedCrossTable@1004 : Record 11102061;
    BEGIN
      IF WhereUsedObject.GET(ObjectType2, ObjectNo) THEN BEGIN
        WhereUsedCrossTable.SETCURRENTKEY("Object Entry No.");
        WhereUsedCrossTable.SETRANGE("Object Entry No.", WhereUsedObject."Object Line Entry No.");
        IF WhereUsedCrossTable.FINDSET THEN
          REPEAT
            WhereUsedCrossTable.CALCFIELDS("Object Type", "Object No.");
            IF WhereUsedObject2.GET(WhereUsedCrossTable."Object Type", WhereUsedCrossTable."Object No.") THEN
              IF WhereUsedObject2.Status = WhereUsedObject2.Status::"Used in Updated" THEN BEGIN
                WhereUsedObject2.Status := WhereUsedObject2.Status::"Lines Updated";
                WhereUsedObject2."Variable Usage Calculated" := FALSE;
                WhereUsedObject2.MODIFY;
              END;
          UNTIL WhereUsedCrossTable.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE UpdateCALChanged@13(VAR WhereUsedObjectLine@1000 : Record 11102058);
    VAR
      WhereUsedObject@1001 : Record 11102057;
      WhereUsedCrossTable@1002 : Record 11102061;
    BEGIN
      WhereUsedCrossTable.SETCURRENTKEY("Object Entry No.");
      WhereUsedCrossTable.SETRANGE("Object Entry No.", WhereUsedObjectLine."Entry No.");
      IF WhereUsedCrossTable.FINDSET THEN
        REPEAT
          WhereUsedCrossTable.CALCFIELDS("Object Type", "Object No.");
          IF WhereUsedObject.GET(WhereUsedCrossTable."Object Type", WhereUsedCrossTable."Object No.") THEN
            IF NOT WhereUsedObject."C/AL Changed" THEN BEGIN
              WhereUsedObject."C/AL Changed" := TRUE;
              WhereUsedObject.MODIFY;
            END;
        UNTIL WhereUsedCrossTable.NEXT = 0;
    END;

    LOCAL PROCEDURE CompareExistingNew@14(VAR ExistinghereUsedObject@1000 : Record 11102058;VAR NewObjectLine@1001 : Record 11102058) : Integer;
    VAR
      CompareType@1002 : 'Existing Further,Same,New Further';
    BEGIN
      IF ExistinghereUsedObject.Type < NewObjectLine.Type THEN
        EXIT(CompareType::"New Further");

      IF ExistinghereUsedObject.Type > NewObjectLine.Type THEN
        EXIT(CompareType::"Existing Further");

      IF ExistinghereUsedObject.Id < NewObjectLine.Id THEN
        EXIT(CompareType::"New Further");

      IF ExistinghereUsedObject.Id > NewObjectLine.Id THEN
        EXIT(CompareType::"Existing Further");

      EXIT(CompareType::Same);
    END;

    PROCEDURE UpdateWhereInOfObject@15(VAR Object@1000 : Record 2000000001);
    VAR
      CALHistoryObject@1001 : Record 11102052;
      TmpHistoryLine@1002 : ARRAY [5] OF TEMPORARY Record 11102053;
      WhereUsedObject@1003 : Record 11102057;
      ObjectLine@1004 : Record 11102058;
      ObjectLine2@1005 : Record 11102058;
      ObjectVariableLine@1006 : Record 11102058;
      WhereUsedIn@1007 : Record 11102060;
      TmpLinkedTable@1008 : TEMPORARY Record 11102062;
      TmpVariable@1009 : TEMPORARY Record 11102062;
      Relation@1010 : Record 11102078;
      Object2@1011 : Record 2000000001;
      TableObject@1012 : Record 2000000038;
      TableObject2@1013 : Record 2000000038;
      Mgt@1014 : Codeunit 11102035;
      SourceControl@1015 : Codeunit 11102050;
      ControlIdText@1016 : Text;
      ControlName@1017 : Text;
      ControlType@1018 : Text;
      CurrentSection@1019 : Text;
      DataItemName@1020 : ARRAY [250] OF Text;
      Expression@1021 : Text;
      FieldName2@1022 : Text;
      KeyNumber@1023 : Text;
      LinkReference@1024 : Text;
      LinkTableVarName@1025 : Text;
      NameOfIndent@1026 : ARRAY [100] OF Text;
      NextDataItemVarName@1027 : Text;
      ObjectNoString@1028 : Text;
      PagePartSubPageLink@1029 : Text;
      PagePartSubPageView@1030 : Text;
      PropertyCode@1031 : Text;
      PropertyName@1032 : Text;
      PropertyValue@1033 : Text;
      PropertyValue2@1034 : Text;
      RunObjectType@1035 : Text;
      Section@1036 : ARRAY [5] OF Text;
      TriggerName@1037 : Text;
      VarName@1038 : Text;
      CALLineNo@1039 : Integer;
      ControlId@1040 : Integer;
      CurrentKeyNo@1041 : Integer;
      DataItemIndent@1042 : ARRAY [250] OF Integer;
      DataItemTableNo@1043 : ARRAY [250] OF Integer;
      Dummy@1044 : Integer;
      FieldNo2@1045 : Integer;
      i@1046 : Integer;
      Indent@1047 : Integer;
      ItemCounter@1048 : Integer;
      LineStart@1049 : Integer;
      MainTableNo@1050 : Integer;
      NextDataItemTable@1051 : Integer;
      NoOfParts@1052 : Integer;
      ObjectLineEntryNo@1053 : Integer;
      ObjectNo@1054 : Integer;
      PagePartSubPageLinkLine@1055 : Integer;
      PagePartSubPageViewLine@1056 : Integer;
      ParentEntryNo@1057 : Integer;
      PartId@1058 : ARRAY [100] OF Integer;
      PartPageNo@1059 : ARRAY [100] OF Integer;
      PartProviderId@1060 : ARRAY [100] OF Integer;
      Position@1061 : Integer;
      PropertyValueId@1062 : Integer;
      PropStart@1063 : Integer;
      ProviderId@1064 : Integer;
      SectionStartPos@1065 : Integer;
      SplitPos@1066 : Integer;
      SubPageId@1067 : Integer;
      ObjectType2@1068 : ' ,Table,,Report,,Codeunit,XMLport,MenuSuite,Page';
      OptionYesNo@1069 : ' ,Yes,No';
      EndOfSectionFound@1070 : Boolean;
      IsLocal@1071 : Boolean;
      IsTemporary2@1072 : Boolean;
    BEGIN
      IF NOT WhereUsedObject.GET(Object.Type, Object.ID) THEN
        EXIT;

      IF NOT CALHistoryObject.GET(WhereUsedObject."C/AL Code Entry No.") THEN BEGIN
        IF NOT CALHistoryObject.TryGoToLastRecord(Object.Type, Object.ID) THEN
          EXIT;

        WhereUsedObject."C/AL Code Entry No." := CALHistoryObject."Entry No.";
        WhereUsedObject.MODIFY;
      END;

      SourceControl.FillCALLineBufferWithEntryNo(TmpHistoryLine[1], CALHistoryObject."Entry No.");
      //UseTestFile(Object, TmpHistoryLine[1]);

      RemoveFromTill(TmpHistoryLine[1], '    BEGIN', '    END.');
      RemoveFromTill(TmpHistoryLine[1], '  RDLDATA', '    END_OF_RDLDatA');

      IF Object.Type = Object.Type::Table THEN
        IF TableObject.GET(Object.Type::Table, Object.ID) THEN
          ;

      ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
      ObjectLine.SETRANGE("Object Type", Object.Type);
      ObjectLine.SETRANGE("Object No.", Object.ID);
      ObjectLine.SETRANGE(Type, ObjectLine.Type::Object);
      ObjectLine.FINDFIRST;
      ObjectLineEntryNo := ObjectLine."Entry No.";

      WhereUsedIn.SETCURRENTKEY("Object Type", "Object No.");
      WhereUsedIn.SETRANGE("Object Type", Object.Type);
      WhereUsedIn.SETRANGE("Object No.", Object.ID);
      WhereUsedIn.DELETEALL(TRUE);

      ObjectVariableLine.SETCURRENTKEY("Object Type", "Object No.");
      ObjectVariableLine.SETRANGE("Object Type", Object.Type);
      ObjectVariableLine.SETRANGE("Object No.", Object.ID);
      ObjectVariableLine.SETFILTER(Type,
        '%1|%2|%3|%4', ObjectLine2.Type::"Global Variable", ObjectLine2.Type::"Local Variable",
        ObjectLine2.Type::Parameter, ObjectLine2.Type::"Return Value");
      ObjectVariableLine.DELETEALL(TRUE);

      IF Object.Type = Object.Type::Table THEN BEGIN
        Relation.SETCURRENTKEY("Object Type", "Table No.");
        Relation.SETRANGE("Object Type", Relation."Object Type"::Table);
        Relation.SETRANGE("Table No.", Object.ID);
        Relation.DELETEALL(TRUE);
      END;

      IF Object.Type = Object.Type::Table THEN BEGIN
        ObjectLine.SETCURRENTKEY("Object Type", "Object No.");
        ObjectLine.SETRANGE("Object Type", Object.Type);
        ObjectLine.SETRANGE("Object No.", Object.ID);
        ObjectLine.SETRANGE(Type, ObjectLine.Type::"Sum Index Field");
        IF ObjectLine.FINDSET THEN BEGIN
          AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, 'SumIndexField');
          REPEAT
            ObjectLine2.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
            ObjectLine2.SETRANGE("Object Type", ObjectLine2."Object Type"::Table);
            ObjectLine2.SETRANGE("Object No.", Object.ID);
            ObjectLine2.SETRANGE(Type, ObjectLine2.Type::Field);
            ObjectLine2.SETRANGE(Name, ObjectLine.Name);
            IF ObjectLine2.FINDFIRST THEN
              AddCrossTableRecord(ObjectLine2."Entry No.", WhereUsedIn."Entry No.", ObjectLine."C/AL Line No.", 0, FALSE);
          UNTIL ObjectLine.NEXT = 0;
        END;

        AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, 'KeyField');
        ObjectLine.SETRANGE(Type, ObjectLine.Type::Key);
        IF ObjectLine.FINDSET THEN
          REPEAT
            FOR i := 1 TO STRLEN(ObjectLine.Name) DO BEGIN
              IF ObjectLine.Name[i] <> ',' THEN
                KeyNumber += FORMAT(ObjectLine.Name[i]);

              IF (i = STRLEN(ObjectLine.Name)) OR (ObjectLine.Name[i] = ',') THEN BEGIN
                ObjectLine2.RESET;
                ObjectLine2.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
                ObjectLine2.SETRANGE("Object Type", ObjectLine2."Object Type"::Table);
                ObjectLine2.SETRANGE("Object No.", Object.ID);
                ObjectLine2.SETRANGE(Type, ObjectLine2.Type::Field);
                ObjectLine2.SETFILTER(Id, KeyNumber);
                IF ObjectLine2.FINDFIRST THEN
                  AddCrossTableRecord(ObjectLine2."Entry No.", WhereUsedIn."Entry No.", ObjectLine."C/AL Line No.", 0, FALSE);

                KeyNumber := '';
              END;

            END;
          UNTIL ObjectLine.NEXT = 0;

        IF SetRangeOnSection(CALHistoryObject, TmpHistoryLine[1], 'FIELDGROUPS') THEN BEGIN
          AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, 'FieldGroupField');
          TmpHistoryLine[1].SETRANGE("Sub Line No.", 1);
          TmpHistoryLine[1].SETFILTER(Code, '%1', '    {*');
          IF TmpHistoryLine[1].FINDSET THEN
            REPEAT
              IF TmpHistoryLine[1].Code[73] = ';' THEN
                TmpHistoryLine[1].Code := DELSTR(TmpHistoryLine[1].Code, 73);

              Position := 7;
              Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', PropertyValue);
              Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', PropertyValue);
              TmpHistoryLine[1].Code := DELCHR(TmpHistoryLine[1].Code, '>', ' }');
              WHILE Mgt.NextValue(TmpHistoryLine[1].Code, Position, ',', '"', '"', FieldName2) DO BEGIN

                ObjectLine2.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
                ObjectLine2.SETRANGE("Object Type", ObjectLine2."Object Type"::Table);
                ObjectLine2.SETRANGE("Object No.", Object.ID);
                ObjectLine2.SETRANGE(Type, ObjectLine2.Type::Field);
                ObjectLine2.SETRANGE(Name, FieldName2);
                IF ObjectLine2.FINDFIRST THEN
                  AddCrossTableRecord(ObjectLine2."Entry No.", WhereUsedIn."Entry No.", TmpHistoryLine[1]."Line No.", 0, FALSE);
              END;

            UNTIL TmpHistoryLine[1].NEXT = 0;
        END;

      END;

      IF SetRangeOnSection(CALHistoryObject, TmpHistoryLine[1], 'CODE') THEN BEGIN
        TmpHistoryLine[1].SETRANGE("Sub Line No.", 1);
        IF TmpHistoryLine[1].FINDSET THEN
          IF TmpHistoryLine[1].Code = '    VAR' THEN BEGIN

            AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::"Global Variable", 'Global');

            TmpHistoryLine[3].RESET;
            TmpHistoryLine[3].SETRANGE("Entry No.", CALHistoryObject."Entry No.");
            TmpHistoryLine[3].SETFILTER("Line No.", '>%1', TmpHistoryLine[1]."Line No.");
            TmpHistoryLine[3].SETRANGE("Sub Line No.", 1);
            TmpHistoryLine[3].FINDFIRST;

            TmpHistoryLine[3].NEXT(1);
            WHILE NOT EndOfSectionFound DO
              IF NOT InVariableSection(TmpHistoryLine[3]) THEN
                EndOfSectionFound := TRUE
              ELSE
                IF TmpHistoryLine[3].NEXT = 0 THEN
                  EndOfSectionFound := TRUE;

            TmpHistoryLine[3].SETRANGE("Line No.", TmpHistoryLine[1]."Line No." + 1, TmpHistoryLine[3]."Line No." - 1);

            WhereUsedObject."No. of Global Variables" := AddVariablesFromSection(TmpHistoryLine[3], TmpVariable, WhereUsedIn, 3, 0);
            WhereUsedObject.MODIFY;

            IF ObjectLine.GET(WhereUsedObject."Object Line Entry No.") THEN BEGIN
              ObjectLine."No. of Variables" := WhereUsedObject."No. of Global Variables";
              ObjectLine.MODIFY;
            END;

          END ELSE BEGIN
            WhereUsedObject."No. of Global Variables" := 0;
            WhereUsedObject.MODIFY;
          END;
      END;

      CASE Object.Type OF

        Object.Type::Report :
          IF SetRangeOnSection(CALHistoryObject, TmpHistoryLine[1], 'DATASET') THEN BEGIN
            TmpHistoryLine[1].SETRANGE("Sub Line No.", 1);
            IF TmpHistoryLine[1].FINDSET THEN
              REPEAT

                IF COPYSTR(TmpHistoryLine[1].Code, 5, 1) = '{' THEN BEGIN
                  NextDataItemTable := 0;
                  NextDataItemVarName := '';
                  Position := 7;
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', NextDataItemVarName);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', NextDataItemVarName);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', NextDataItemVarName);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', NextDataItemVarName);
                END;

                IF COPYSTR(TmpHistoryLine[1].Code, 16, 14) = 'DataItemTable=' THEN BEGIN
                  PropertyValue := COPYSTR(TmpHistoryLine[1].Code, 35);
                  PropertyValue := DELSTR(PropertyValue, STRLEN(PropertyValue));
                  EVALUATE(NextDataItemTable, PropertyValue);
                  IF NextDataItemVarName = '' THEN
                    IF TableObject.GET(TableObject."Object Type"::Table, NextDataItemTable) THEN
                      NextDataItemVarName := TableObject."Object Name";
                  IF NextDataItemVarName <> '' THEN
                    AppendVariablesToBuffer(
                      TmpVariable, 4, FALSE, NextDataItemVarName,
                      0, ObjectType2::Table, NextDataItemTable, 0, TmpHistoryLine[1]."Line No.", ObjectLineEntryNo, 0, '', '', FALSE);

                END;

              UNTIL TmpHistoryLine[1].NEXT = 0;
            TableObject."Object ID" := 0;
          END;

        Object.Type::XMLport :
          IF SetRangeOnSection(CALHistoryObject, TmpHistoryLine[1], 'ELEMENTS') THEN BEGIN
            TmpHistoryLine[1].SETRANGE("Sub Line No.", 1);
            IF TmpHistoryLine[1].FINDSET THEN
              REPEAT
                IF TmpHistoryLine[1].Code[5] = '{' THEN BEGIN
                  Position := 5;
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', ControlName);
                  ControlName := COPYSTR(ControlName, 4);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', ControlType);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', ControlType);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', ControlType);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', ControlType);
                  NextDataItemTable := 0;
                  NextDataItemVarName := '';
                  LinkTableVarName := '';
                END;

                IF COPYSTR(TmpHistoryLine[1].Code, 51, 13) = 'VariableName=' THEN
                  GetPropertyValue(TmpHistoryLine[1], NextDataItemVarName);

                IF COPYSTR(TmpHistoryLine[1].Code, 51, 12) = 'SourceTable=' THEN BEGIN
                  PropertyValue := COPYSTR(TmpHistoryLine[1].Code, 68);
                  PropertyValue := DELSTR(PropertyValue, STRLEN(PropertyValue));
                  EVALUATE(NextDataItemTable, PropertyValue);

                  IF NextDataItemVarName = '' THEN
                    IF TableObject2.GET(Object.Type::Table, NextDataItemTable) THEN
                      NextDataItemVarName := TableObject2."Object Name";
                END;

                IF COPYSTR(TmpHistoryLine[1].Code, 51, 10) = 'LinkTable=' THEN BEGIN
                  PropertyValue := COPYSTR(TmpHistoryLine[1].Code, 61);
                  PropertyValue := DELSTR(PropertyValue, STRLEN(PropertyValue));
                  LinkTableVarName := PropertyValue;
                END;

                IF TmpHistoryLine[1].Code = '' THEN
                  IF NextDataItemTable <> 0 THEN BEGIN

                    AppendVariablesToBuffer(
                      TmpVariable, 4, FALSE, NextDataItemVarName,
                      0, ObjectType2::Table, NextDataItemTable, 0, TmpHistoryLine[1]."Line No.", ObjectLineEntryNo, 0, '', '', FALSE);

                    IF LinkTableVarName <> '' THEN BEGIN
                      TmpLinkedTable."Entry No." += 1;
                      TmpLinkedTable.Name := ControlName;
                      TmpLinkedTable."Case Name" := LinkTableVarName;
                      TmpLinkedTable.Id := NextDataItemTable;
                      TmpLinkedTable.INSERT;
                    END;
                  END;

              UNTIL TmpHistoryLine[1].NEXT = 0;
          END;

        Object.Type::Page :
          IF SetRangeOnSection(CALHistoryObject, TmpHistoryLine[1], 'CONTROLS') THEN BEGIN
            TmpHistoryLine[1].SETRANGE("Sub Line No.", 1);
            IF TmpHistoryLine[1].FINDSET THEN
              REPEAT
                IF TmpHistoryLine[1].Code[5] = '{' THEN BEGIN
                  Position := 6;
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '"', '"', ControlIdText);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '"', '"', ControlType);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '"', '"', ControlType);
                  ControlName := '';
                END;

                IF ControlType = 'Part' THEN BEGIN
                  GetPropertyName(TmpHistoryLine[1], PropertyName);
                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                  CASE PropertyName OF
                    'Name' :
                      ControlName := PropertyValue;

                    'PagePartID' :
                      IF EVALUATE(SubPageId, COPYSTR(PropertyValue, 5)) THEN BEGIN
                        NoOfParts += 1;
                        IF EVALUATE(PartId[NoOfParts], ControlIdText) THEN
                          ;
                        PartPageNo[NoOfParts] := SubPageId;
                        AppendVariablesToBuffer(
                          TmpVariable, 4, FALSE, ControlName, 0, ObjectType2::Page, SubPageId,
                          0, TmpHistoryLine[1]."Line No.", CALHistoryObject."Entry No.", 0, '', '', FALSE);
                      END;

                    'ProviderID' :
                      IF NoOfParts > 0 THEN
                        IF EVALUATE(PartProviderId[NoOfParts], PropertyValue) THEN
                          ;
                  END;
                END;
              UNTIL TmpHistoryLine[1].NEXT = 0;
          END;

        Object.Type::Query :
          IF SetRangeOnSection(CALHistoryObject, TmpHistoryLine[1], 'ELEMENTS') THEN BEGIN
            TmpHistoryLine[1].SETRANGE("Sub Line No.", 1);
            IF TmpHistoryLine[1].FINDSET THEN
              REPEAT

                IF COPYSTR(TmpHistoryLine[1].Code, 5, 1) = '{' THEN BEGIN
                  NextDataItemTable := 0;
                  NextDataItemVarName := '';
                  Position := 7;
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', NextDataItemVarName);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', NextDataItemVarName);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', NextDataItemVarName);
                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', NextDataItemVarName);
                END;

                IF COPYSTR(TmpHistoryLine[1].Code, 16, 14) = 'DataItemTable=' THEN BEGIN
                  PropertyValue := COPYSTR(TmpHistoryLine[1].Code, 35);
                  PropertyValue := DELSTR(PropertyValue, STRLEN(PropertyValue));
                  EVALUATE(NextDataItemTable, PropertyValue);
                  IF NextDataItemVarName = '' THEN
                    IF TableObject.GET(TableObject."Object Type"::Table, NextDataItemTable) THEN
                      NextDataItemVarName := QueryTableName(TableObject."Object Name");
                  IF NextDataItemVarName <> '' THEN
                    AppendVariablesToBuffer(
                      TmpVariable, 4, FALSE, NextDataItemVarName,
                      0, ObjectType2::Table, NextDataItemTable, 0, TmpHistoryLine[1]."Line No.", ObjectLineEntryNo, 0, '', '', FALSE);

                END;

              UNTIL TmpHistoryLine[1].NEXT = 0;
            TableObject."Object ID" := 0;
          END;

      END;

      CASE Object.Type OF
        Object.Type::Page :
          AppendVariablesToBuffer(TmpVariable, 4, TRUE, 'currpage', 0, Object.Type, Object.ID, 0, 0, 0, 0, '', '', FALSE);
        ELSE
          AppendVariablesToBuffer(TmpVariable, 4, TRUE, 'rec', 0, Object.Type, Object.ID, 0, 0, 0, 0, '', '', FALSE);
      END;

      TmpHistoryLine[1].RESET;
      TmpHistoryLine[1].SETRANGE("Entry No.", CALHistoryObject."Entry No.");
      TmpHistoryLine[1].SETFILTER("Line No.", '>1');
      TmpHistoryLine[1].SETRANGE("Sub Line No.", 1);
      IF TmpHistoryLine[1].FINDSET THEN
        REPEAT
          IF STRLEN(TmpHistoryLine[1].Code) > 5 THEN

            CASE TRUE OF

              TmpHistoryLine[1].Code[3] <> ' ' :
                BEGIN
                  CLEAR(Section);
                  Section[1] := DELCHR(TmpHistoryLine[1].Code, '<>');
                  CurrentSection := Section[1];
                  IF CurrentSection = 'RDLDATA' THEN BEGIN
                    TmpHistoryLine[1].SETFILTER(Code, '%1', '    END_OF_RDLDATA');
                    IF TmpHistoryLine[1].FINDFIRST THEN
                      ;
                    TmpHistoryLine[1].SETRANGE(Code);
                  END;
                  SectionStartPos := 5;
                END;

              TmpHistoryLine[1].Code = '    CONTROLS' :
                BEGIN
                  Section[2] := 'CONTROLS';
                  CurrentSection := Section[1] + '-' + Section[2];
                END;

              TmpHistoryLine[1].Code = '      FIELDS' :
                BEGIN
                  Section[2] := 'FIELDS';
                  CurrentSection := Section[1] + '-' + Section[2];
                END;

              TmpHistoryLine[1].Code = '        { PROPERTIES' :
                BEGIN
                  Section[3] := 'PROPERTIES';
                  CurrentSection := Section[1] + '-' + Section[2] + '-' + Section[3];
                END;

              TmpHistoryLine[1].Code = '    PROPERTIES' :
                BEGIN
                  Section[2] := 'PROPERTIES';
                  CurrentSection := Section[1] + '-' + Section[2];
                  SectionStartPos := 7;
                END;

              TmpHistoryLine[1].Code = '          CONTROLS' :
                BEGIN
                  Section[3] := 'CONTROLS';
                  CurrentSection := Section[1] + '-' + Section[2] + '-' + Section[3];
                END;

              TmpHistoryLine[1].Code = '    ActionList=ACTIONS' :
                BEGIN
                  CurrentSection := DELCHR(TmpHistoryLine[1].Code, '<>');
                  SectionStartPos := 23;
                END;

              TmpHistoryLine[1].Code = '                ActionList=ACTIONS' :
                BEGIN
                  Section[2] := 'ActionList=ACTIONS';
                  CurrentSection := Section[1] + '-' + Section[2];
                  SectionStartPos := 35;
                END;

              ELSE

                CASE TRUE OF

                  COPYSTR(TmpHistoryLine[1].Code, STRLEN(TmpHistoryLine[1].Code) - 3) = '=VAR' :
                    BEGIN
                      IF (CurrentSection = 'FIELDS') AND (TmpHistoryLine[1].Code[5] <> ' ') THEN BEGIN
                        Position := 5;
                        Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', FieldName2);
                        Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', FieldName2);
                        Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', FieldName2);
                      END;

                      TriggerName := SetCodeSectionRange(TmpHistoryLine[1], TmpHistoryLine[3], TmpHistoryLine[4], '=VAR');
                      IF CurrentSection = 'FIELDS' THEN
                        TriggerName := FieldName2 + '-' + TriggerName;

                      TmpHistoryLine[1].SETFILTER("Line No.", '>%1', TmpHistoryLine[1]."Line No.");
                      AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Code, TriggerName);
                      TmpHistoryLine[2].SETRANGE("Entry No.", -1);
                      AnalyseCode(
                        WhereUsedIn, TmpHistoryLine[2], TmpHistoryLine[3],
                        TmpHistoryLine[4], TmpVariable, Object, TableObject."Object ID", CurrentKeyNo);
                      TmpHistoryLine[1] := TmpHistoryLine[4];
                      TmpHistoryLine[1].NEXT(1);
                    END;

                  COPYSTR(TmpHistoryLine[1].Code, STRLEN(TmpHistoryLine[1].Code) - 5) = '=BEGIN' :
                    BEGIN

                      IF (CurrentSection = 'FIELDS') AND (TmpHistoryLine[1].Code[5] <> ' ') THEN BEGIN
                        Position := 5;
                        Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', FieldName2);
                        Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', FieldName2);
                        Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', FieldName2);
                      END;

                      TriggerName := SetCodeSectionRange(TmpHistoryLine[1], TmpHistoryLine[3], TmpHistoryLine[4], '=BEGIN');
                      IF CurrentSection = 'FIELDS' THEN
                        TriggerName := FieldName2 + '-' + TriggerName;

                      AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Code, TriggerName);
                      TmpHistoryLine[2].SETRANGE("Entry No.", -1);
                      AnalyseCode(
                        WhereUsedIn, TmpHistoryLine[2], TmpHistoryLine[3],
                        TmpHistoryLine[4], TmpVariable, Object, TableObject."Object ID", CurrentKeyNo);
                      TmpHistoryLine[1] := TmpHistoryLine[4];
                      TmpHistoryLine[1].NEXT(1);
                    END;

                  ELSE

                    CASE CurrentSection OF
                      'PROPERTIES', 'REQUESTPAGE-PROPERTIES' :
                        IF TmpHistoryLine[1].Code[SectionStartPos] <> ' ' THEN BEGIN
                          PropertyCode := DELCHR(TmpHistoryLine[1].Code, '<>');
                          CALLineNo := TmpHistoryLine[1]."Line No.";
                          GetPropertyName(TmpHistoryLine[1], PropertyName);
                          CASE PropertyName OF

                            'CalcFields', 'DataCaptionFields' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AnalyseEnumFields(PropertyValue, WhereUsedIn, TableObject, CALLineNo, FALSE);
                              END;

                            'DataCaptionExpr' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AnalyseExpression(PropertyValue, WhereUsedIn, TmpVariable, Object, CALLineNo, Indent, NameOfIndent);
                              END;

                            'DrillDownPageID', 'LookupPageID' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                ObjectNoString := COPYSTR(PropertyValue, 5);
                                IF EVALUATE(ObjectNo, ObjectNoString) THEN BEGIN
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  AddObjectUsedInRecord(
                                    WhereUsedIn, ObjectType2::Page, ObjectNo, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);
                                END;
                              END;

                            'CardPageID' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                Object2.RESET;
                                Object2.SETRANGE(Type, Object2.Type::Page);
                                Object2.SETRANGE("Company Name", '');
                                Object2.SETRANGE(Name, PropertyValue);
                                IF Object2.FINDFIRST THEN BEGIN
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  AddObjectUsedInRecord(
                                    WhereUsedIn, Object2.Type, Object2.ID, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);
                                END;
                              END;

                            'Permissions' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                IF PropertyValue <> '' THEN BEGIN
                                  i := 1;
                                  ObjectNoString := SelectStr2(i, PropertyValue);
                                  WHILE ObjectNoString <> '' DO BEGIN
                                    ObjectNoString := COPYSTR(ObjectNoString, 5);

                                    SplitPos := STRPOS(ObjectNoString, ' ');
                                    IF SplitPos > 0 THEN BEGIN

                                      ObjectNoString := COPYSTR(ObjectNoString, SplitPos + 1);
                                      SplitPos := STRPOS(ObjectNoString, '=');
                                      IF SplitPos > 0 THEN BEGIN
                                        ObjectNoString := DELSTR(ObjectNoString, SplitPos);
                                        EVALUATE(ObjectNo, ObjectNoString);

                                        AddObjectUsedInRecord(
                                          WhereUsedIn, ObjectType2::Table, ObjectNo,
                                          ObjectLine.Type::Object, 0, '', CALLineNo + i - 1, FALSE);
                                      END;
                                    END;

                                    i += 1;
                                    ObjectNoString := SelectStr2(i, PropertyValue);
                                  END;
                                END;
                              END;

                            'SourceTable' :
                              BEGIN
                                IsTemporary2 := FALSE;

                                TmpHistoryLine[2].RESET;
                                TmpHistoryLine[2].SETRANGE("Sub Line No.", 1);

                                TmpHistoryLine[2].SETFILTER(Code, '%1', PADSTR('', SectionStartPos - 1) + 'SourceTableTemporary*');
                                IF TmpHistoryLine[2].FINDFIRST THEN BEGIN
                                  GetPropertyValue(TmpHistoryLine[2], PropertyValue);
                                  IF EVALUATE(OptionYesNo, PropertyValue) THEN
                                    IsTemporary2 := OptionYesNo = OptionYesNo::Yes;
                                END;
                                TmpHistoryLine[2].RESET;

                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                PropertyValue := COPYSTR(PropertyValue, 6);
                                EVALUATE(PropertyValueId, PropertyValue);
                                IF TableObject.GET(ObjectType2::Table, PropertyValueId) THEN BEGIN
                                  AppendVariablesToBuffer(
                                    TmpVariable, 4, FALSE, 'rec', 0,
                                    ObjectType2::Table, TableObject."Object ID", 0, 0, 0, 0, '', '', IsTemporary2);
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  AddObjectUsedInRecord(
                                    WhereUsedIn, ObjectType2::Table, TableObject."Object ID",
                                    ObjectLine.Type::Object, 0, '', CALLineNo, IsTemporary2);
                                END;
                              END;

                            'SourceTableView' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AnalyseTableView(PropertyValue, WhereUsedIn, TableObject."Object ID", CurrentKeyNo, CALLineNo, FALSE);
                              END;

                            'TableNo' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                EVALUATE(PropertyValueId, PropertyValue);

                                IF Object.Type = Object.Type::Codeunit THEN
                                  TableObject."Object ID" := PropertyValueId
                                ELSE
                                  AppendVariablesToBuffer(
                                    TmpVariable, 4, FALSE, 'rec', 0,
                                    ObjectType2::Table, PropertyValueId, 0, TmpHistoryLine[1]."Line No.", 0, 0, '', '', FALSE);

                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AddObjectUsedInRecord(
                                  WhereUsedIn, ObjectType2::Table, PropertyValueId, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);
                                CurrentKeyNo := 0;
                              END;
                          END;
                        END;

                      'FIELDS' :
                        BEGIN
                          IF TmpHistoryLine[1].Code[5] <> ' ' THEN BEGIN
                            Position := 5;
                            Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', FieldName2);
                            EVALUATE(FieldNo2, DELCHR(FieldName2, '=', '{ '));
                            Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', FieldName2);
                            Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', FieldName2);
                          END;
                          IF TmpHistoryLine[1].Code[52] <> ' ' THEN BEGIN
                            TmpHistoryLine[1].Code := COPYSTR(TmpHistoryLine[1].Code, 52);
                            CALLineNo := TmpHistoryLine[1]."Line No.";
                            GetPropertyName(TmpHistoryLine[1], PropertyName);
                            CASE PropertyName OF

                              'AltSearchField' :
                                BEGIN
                                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                  IF FindVariable(Object.Type, TmpVariable, NameOfIndent, Indent, 'rec', Mgt.AddQuotes(PropertyValue))
                                  THEN BEGIN
                                    AddWhereUsedInRecord(
                                      WhereUsedIn, Object, WhereUsedIn.Type::Property, FieldName2 + '-' + PropertyName);
                                    FlagVariables(TmpVariable, WhereUsedIn, TmpHistoryLine[1]."Line No.", 0);
                                    PropertyValue := 'sorting(' + PropertyValue + ')';
                                    AnalyseTableView(PropertyValue, WhereUsedIn, Object.ID, Dummy, CALLineNo, FALSE);
                                  END;
                                END;

                              'AutoFormatExpr', 'CaptionClass' :
                                BEGIN
                                  AddWhereUsedInRecord(
                                    WhereUsedIn, Object, WhereUsedIn.Type::Property, FieldName2 + '-' + PropertyName);
                                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                  AnalyseExpression(PropertyValue, WhereUsedIn, TmpVariable, Object, CALLineNo, Indent, NameOfIndent);
                                END;

                              'CalcFormula' :
                                BEGIN
                                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  AnalyseCalcFormula(PropertyValue, WhereUsedIn, Object, CALLineNo);
                                END;

                              'TableRelation' :
                                BEGIN
                                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Relation, PropertyName);
                                  AnalyseTableRelation(PropertyValue, WhereUsedIn, Object.ID, FieldNo2, CALLineNo);
                                END;

                              'AccessByPermission' :
                                BEGIN
                                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  AnalyseAccessByPermission(PropertyValue, WhereUsedIn, CALLineNo);
                                END;

                            END;
                          END;
                        END;

                      'DATAITEMS-FIELDS' :
                        IF TmpHistoryLine[1].Code[9] = '{' THEN BEGIN
                          Position := 10;
                          Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', PropertyValue);
                          Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', PropertyValue);
                          PropertyValue := COPYSTR(TmpHistoryLine[1].Code, Position);
                          PropertyValue := DELSTR(PropertyValue, STRLEN(PropertyValue));
                          PropertyValue := DELCHR(PropertyValue, '<>');
                          PropertyValue := LOWERCASE(PropertyValue);
                          AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::SourceExpr, 'Dataitem-Field');
                          AnalyseExpression(
                            PropertyValue, WhereUsedIn, TmpVariable, Object, TmpHistoryLine[1]."Line No.", Indent, NameOfIndent);
                        END;

                      'CONTROLS', 'REQUESTPAGE-CONTROLS' :
                        BEGIN
                          IF Object.Type = Object.Type::Page THEN BEGIN
                            LineStart := 5;
                            PropStart := 17;
                          END ELSE BEGIN
                            LineStart := 7;
                            PropStart := 19;
                          END;

                          IF TmpHistoryLine[1].Code[LineStart] <> ' ' THEN BEGIN
                            Position := LineStart + 1;
                            Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', ControlIdText);
                            Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', FieldName2);
                            PagePartSubPageView := '';
                            PagePartSubPageLink := '';
                            ControlId := 0;
                            IF EVALUATE(ControlId, ControlIdText) THEN
                              ;
                          END;

                          PropertyName := '';
                          CASE TRUE OF
                            TmpHistoryLine[1].Code[PropStart] <> ' ' :
                              BEGIN
                                TmpHistoryLine[1].Code := COPYSTR(TmpHistoryLine[1].Code, PropStart);
                                CALLineNo := TmpHistoryLine[1]."Line No.";
                                GetPropertyName(TmpHistoryLine[1], PropertyName);
                              END;
                            TmpHistoryLine[1].Code[PropStart + 4] <> ' ' :
                              BEGIN
                                TmpHistoryLine[1].Code := COPYSTR(TmpHistoryLine[1].Code, PropStart + 4);
                                CALLineNo := TmpHistoryLine[1]."Line No.";
                                GetPropertyName(TmpHistoryLine[1], PropertyName);
                              END;
                          END;

                          CASE PropertyName OF

                            'SourceExpr' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::SourceExpr, PropertyName);
                                AnalyseExpression(PropertyValue, WhereUsedIn, TmpVariable, Object, CALLineNo, Indent, NameOfIndent);
                              END;

                            'LookupPageID', 'DrillDownPageID' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                Object2.RESET;
                                Object2.SETRANGE(Type, Object2.Type::Page);
                                Object2.SETRANGE("Company Name", '');
                                Object2.SETRANGE(Name, PropertyValue);
                                IF Object2.FINDFIRST THEN BEGIN
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  AddObjectUsedInRecord(
                                    WhereUsedIn, Object2.Type, Object2.ID, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);
                                END;
                              END;

                            'TableRelation' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Relation, PropertyName);
                                AnalyseTableRelation(PropertyValue, WhereUsedIn, TableObject."Object ID", 0, CALLineNo);
                              END;

                            'PagePartID' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                PropertyValue := COPYSTR(PropertyValue, 5);
                                IF EVALUATE(SubPageId, PropertyValue) THEN
                                  ;

                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AddObjectUsedInRecord(
                                  WhereUsedIn, ObjectType2::Page, SubPageId, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);

                                IF PagePartSubPageView <> '' THEN
                                  IF WhereUsedObject.GET(ObjectType2::Page, SubPageId) THEN
                                    IF TableObject2.GET(ObjectType2::Table, WhereUsedObject."Table No.") THEN
                                      AnalyseTableView(
                                        PagePartSubPageView, WhereUsedIn, TableObject2."Object ID",
                                        Dummy, PagePartSubPageViewLine, FALSE);

                                IF PagePartSubPageLink <> '' THEN BEGIN

                                  MainTableNo := TableObject."Object ID";
                                  ProviderId := 0;
                                  FOR i := 1 TO NoOfParts DO
                                    IF PartId[i] = ControlId THEN
                                      ProviderId := PartProviderId[i];
                                  IF ProviderId <> 0 THEN
                                    FOR i := 1 TO NoOfParts DO
                                      IF PartId[i] = ProviderId THEN
                                        IF WhereUsedObject.GET(ObjectType2::Page, PartPageNo[i]) THEN
                                          MainTableNo := WhereUsedObject."Table No.";

                                  IF WhereUsedObject.GET(ObjectType2::Page, SubPageId) THEN
                                    IF TableObject2.GET(ObjectType2::Table, WhereUsedObject."Table No.") THEN
                                      AnalyseLink(
                                        PagePartSubPageLink, WhereUsedIn, MainTableNo, TableObject2."Object ID",
                                        PagePartSubPageLinkLine, FALSE);
                                END;

                              END;

                            'SubPageView' :
                              IF Object.Type = Object.Type::Page THEN BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                PagePartSubPageView := PropertyValue;
                                PagePartSubPageViewLine := CALLineNo;
                              END ELSE BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                IF WhereUsedObject.GET(ObjectType2::Page, SubPageId) THEN
                                  IF TableObject2.GET(ObjectType2::Table, WhereUsedObject."Table No.") THEN
                                    AnalyseTableView(PropertyValue, WhereUsedIn, TableObject2."Object ID", Dummy, CALLineNo, FALSE);
                              END;

                            'RunPageView' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                IF WhereUsedObject.GET(ObjectType2::Page, SubPageId) THEN
                                  IF TableObject2.GET(ObjectType2::Table, WhereUsedObject."Table No.") THEN
                                    AnalyseTableView(PropertyValue, WhereUsedIn, TableObject2."Object ID", Dummy, CALLineNo, FALSE);
                              END;

                            'SubPageLink' :
                              IF Object.Type = Object.Type::Page THEN BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                PagePartSubPageLink := PropertyValue;
                                PagePartSubPageLinkLine := CALLineNo;
                              END ELSE BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                IF WhereUsedObject.GET(ObjectType2::Page, SubPageId) THEN
                                  IF TableObject2.GET(ObjectType2::Table, WhereUsedObject."Table No.") THEN
                                    AnalyseLink(
                                      PropertyValue, WhereUsedIn, TableObject."Object ID", TableObject2."Object ID", CALLineNo, FALSE);
                              END;

                            'RunPageLink' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                IF WhereUsedObject.GET(ObjectType2::Page, SubPageId) THEN
                                  IF TableObject2.GET(ObjectType2::Table, WhereUsedObject."Table No.") THEN
                                    AnalyseLink(PropertyValue, WhereUsedIn, Object.ID, TableObject2."Object ID", CALLineNo, FALSE);
                              END;

                            'RunObject' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                SplitPos := STRPOS(PropertyValue, ' ');
                                Object2.RESET;
                                Object2.SETFILTER(Type, DELSTR(PropertyValue, SplitPos));
                                Object2.SETRANGE("Company Name", '');
                                Object2.SETFILTER(ID, COPYSTR(PropertyValue, SplitPos + 1));
                                IF Object2.FINDFIRST THEN BEGIN
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  AddObjectUsedInRecord(
                                    WhereUsedIn, Object2.Type, Object2.ID, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);
                                  AddObjectUsedInRecord(
                                    WhereUsedIn, Object2.Type, Object2.ID, ObjectLine.Type::Trigger, 1, '', CALLineNo, FALSE);
                                  SubPageId := Object2.ID;
                                END;
                              END;

                            'Visible', 'Enabled', 'Editable', 'HideValue', 'AutoFormatExpr', 'QuickEntry', 'StyleExpr', 'CaptionClass', 'ShowMandatory' :
                              IF Object.Type IN [Object.Type::Page, Object.Type::Report] THEN BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AnalyseExpression(PropertyValue, WhereUsedIn, TmpVariable, Object, CALLineNo, Indent, NameOfIndent);
                              END;

                            'AccessByPermission' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AnalyseAccessByPermission(PropertyValue, WhereUsedIn, CALLineNo);
                              END;

                          END;

                        END;

                      'DATASET' :
                        BEGIN
                          IF TmpHistoryLine[1].Code[5] = '{' THEN BEGIN
                            Position := 7;
                            Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', PropertyValue);
                            Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', PropertyValue2);
                            Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', PropertyValue);
                            IF PropertyValue = 'DataItem' THEN BEGIN
                              ItemCounter += 1;
                              LinkReference := '';
                              Indent := 1;
                              CurrentKeyNo := 0;
                              Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', DataItemName[ItemCounter]);
                              NameOfIndent[1] := LOWERCASE(DataItemName[ItemCounter]);
                              IF PropertyValue2 = '' THEN
                                DataItemIndent[ItemCounter] := 0
                              ELSE
                                EVALUATE(DataItemIndent[ItemCounter], PropertyValue2);
                            END;
                          END;

                          PropertyCode := DELCHR(TmpHistoryLine[1].Code, '<>');
                          CALLineNo := TmpHistoryLine[1]."Line No.";
                          GetPropertyName(TmpHistoryLine[1], PropertyName);
                          CASE PropertyName OF

                            'DataItemTable' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                PropertyValue := COPYSTR(PropertyValue, 6);
                                EVALUATE(PropertyValueId, PropertyValue);

                                IF TableObject.GET(TableObject."Object Type"::Table, PropertyValueId) THEN
                                  ;

                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AddObjectUsedInRecord(
                                  WhereUsedIn, ObjectType2::Table, PropertyValueId, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);
                                IF ItemCounter > ARRAYLEN(DataItemTableNo) THEN
                                  EXIT;
                                DataItemTableNo[ItemCounter] := PropertyValueId;
                                IF DataItemName[ItemCounter] = '' THEN
                                  DataItemName[ItemCounter] := TableObject."Object Name";
                                IF NameOfIndent[1] = '' THEN
                                  NameOfIndent[1] := AddQuotesForFilter(DataItemName[ItemCounter]);
                              END;

                            'DataItemTableView' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AnalyseTableView(PropertyValue, WhereUsedIn, TableObject."Object ID", CurrentKeyNo, CALLineNo, FALSE);
                              END;

                            'DataItemLinkReference' :
                              GetPropertyValue(TmpHistoryLine[1], LinkReference);

                            'ReqFilterFields', 'TotalFields', 'GroupTotalFields', 'CalcFields' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AnalyseEnumFields(PropertyValue, WhereUsedIn, TableObject, CALLineNo, FALSE);
                              END;

                            'DataItemLink' :
                              BEGIN
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                TableObject2."Object ID" := 0;

                                i := ItemCounter - 1;
                                WHILE (i >= 1) AND (TableObject2."Object ID" = 0) DO BEGIN
                                  IF (LinkReference <> '') AND (DataItemName[i] = LinkReference) THEN
                                    IF TableObject2.GET(TableObject2."Object Type"::Table, DataItemTableNo[i]) THEN
                                      ;
                                  IF (LinkReference = '') AND (DataItemIndent[i] = DataItemIndent[ItemCounter] - 1) THEN
                                    IF TableObject2.GET(TableObject2."Object Type"::Table, DataItemTableNo[i]) THEN
                                      ;
                                  i -= 1;
                                END;

                                IF TableObject2."Object ID" <> 0 THEN
                                  AnalyseLink(
                                    PropertyValue, WhereUsedIn, TableObject2."Object ID", TableObject."Object ID", CALLineNo, FALSE);

                              END;

                            'SourceExpr' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::SourceExpr, PropertyName);
                                AnalyseExpression(PropertyValue, WhereUsedIn, TmpVariable, Object, CALLineNo, Indent, NameOfIndent);
                              END;

                          END;
                        END;

                      'CODE' :
                        IF (DELSTR(TmpHistoryLine[1].Code, 14) = '    PROCEDURE') OR
                           (DELSTR(TmpHistoryLine[1].Code, 20) = '    LOCAL PROCEDURE') OR
                           (DELSTR(TmpHistoryLine[1].Code, 10) = '    EVENT')
                        THEN BEGIN

                          CASE TmpHistoryLine[1].Code[5] OF
                            'L' :
                              BEGIN
                                IsLocal := TRUE;
                                Position := 21;
                              END;
                            'E' :
                              BEGIN
                                IsLocal := TRUE;
                                Position := 11;
                              END;

                            ELSE BEGIN
                              IsLocal := FALSE;
                              Position := 15;
                            END;
                          END;

                          IF Object.Type IN [Object.Type::Report, Object.Type::XMLport] THEN
                            TableObject."Object ID" := 0;

                          Mgt.NextValue(TmpHistoryLine[1].Code, Position, '@', '"', '"', TriggerName);

                          IF TmpHistoryLine[1].Code[5] = 'E' THEN BEGIN
                            TmpVariable.RESET;
                            TmpVariable.SETCURRENTKEY(Name, Scope);
                            TmpVariable.SETRANGE(Name, Mgt.AddQuotes(TriggerName));
                            TmpVariable.SETRANGE(Scope, TmpVariable.Scope::Global);
                            IF TmpVariable.FINDFIRST THEN
                              FlagVariableUsedIn(TmpVariable);
                            TmpVariable.SETRANGE(Scope);
                          END;

                          TmpHistoryLine[2].RESET;
                          TmpHistoryLine[2].SETRANGE("Entry No.", TmpHistoryLine[1]."Entry No.");
                          TmpHistoryLine[2].SETRANGE("Line No.", TmpHistoryLine[1]."Line No.");

                          TmpHistoryLine[3].RESET;
                          TmpHistoryLine[3].SETRANGE("Entry No.", TmpHistoryLine[1]."Entry No.");
                          TmpHistoryLine[3].SETFILTER("Line No.", '>%1', TmpHistoryLine[1]."Line No.");
                          TmpHistoryLine[3].SETRANGE(Code, '    BEGIN');
                          TmpHistoryLine[3].FINDFIRST;
                          TmpHistoryLine[3].SETRANGE(Code);
                          TmpHistoryLine[3].SETRANGE("Line No.", TmpHistoryLine[1]."Line No." + 2, TmpHistoryLine[3]."Line No." - 1);

                          TmpHistoryLine[4].RESET;
                          TmpHistoryLine[4].SETRANGE("Entry No.", TmpHistoryLine[1]."Entry No.");
                          TmpHistoryLine[4].SETFILTER("Line No.", '>%1', TmpHistoryLine[1]."Line No.");
                          TmpHistoryLine[4].SETRANGE(Code, '    END;');
                          TmpHistoryLine[4].FINDFIRST;
                          TmpHistoryLine[4].SETFILTER("Line No.", '>%1', TmpHistoryLine[1]."Line No.");
                          TmpHistoryLine[4].SETRANGE(Code);
                          TmpHistoryLine[4].SETRANGE("Line No.", TmpHistoryLine[3]."Line No." + 1, TmpHistoryLine[4]."Line No." - 1);
                          TmpHistoryLine[1].SETFILTER("Line No.", '>%1', TmpHistoryLine[1]."Line No.");
                          AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Code, TriggerName);
                          AnalyseCode(
                            WhereUsedIn, TmpHistoryLine[2],
                            TmpHistoryLine[3], TmpHistoryLine[4], TmpVariable, Object, TableObject."Object ID", CurrentKeyNo);
                          TmpHistoryLine[1] := TmpHistoryLine[4];
                          TmpHistoryLine[1].NEXT(1);

                        END;

                      'MENUNODES' :
                        IF TmpHistoryLine[1].Code[65] <> ' ' THEN BEGIN
                          TmpHistoryLine[1].Code := COPYSTR(TmpHistoryLine[1].Code, 65);
                          GetPropertyName(TmpHistoryLine[1], PropertyName);
                          CASE PropertyName OF

                            'RunObjectType' :
                              GetPropertyValue(TmpHistoryLine[1], RunObjectType);

                            'RunObjectID' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                TableObject2.SETFILTER("Object Type", RunObjectType);
                                TableObject2.SETFILTER("Object ID", PropertyValue);
                                IF TableObject2.FINDFIRST THEN BEGIN
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  AddObjectUsedInRecord(
                                    WhereUsedIn, TableObject2."Object Type", TableObject2."Object ID", ObjectLine.Type::Object, 0, '',
                                    TmpHistoryLine[1]."Line No.", FALSE);
                                  AddObjectUsedInRecord(
                                    WhereUsedIn, TableObject2."Object Type", TableObject2."Object ID", ObjectLine.Type::Trigger, 1, '',
                                    TmpHistoryLine[1]."Line No.", FALSE);
                                END;
                                TableObject2.RESET;

                              END;

                            'AccessByPermission' :
                              BEGIN
                                GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                AnalyseAccessByPermission(PropertyValue, WhereUsedIn, CALLineNo);
                              END;

                          END;
                        END;

                      'ELEMENTS' :
                        CASE Object.Type OF
                          Object.Type::XMLport :
                            IF TmpHistoryLine[1].Code[51] <> ' ' THEN BEGIN

                              IF TmpHistoryLine[1].Code[5] = '{' THEN BEGIN
                                Position := 5;
                                Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', ControlName);
                                ControlName := COPYSTR(ControlName, 4);
                              END;

                              TmpHistoryLine[1].Code := COPYSTR(TmpHistoryLine[1].Code, 51);
                              GetPropertyName(TmpHistoryLine[1], PropertyName);
                              CASE PropertyName OF

                                'SourceTable' :
                                  BEGIN
                                    GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                    PropertyValue := COPYSTR(PropertyValue, 6);
                                    EVALUATE(PropertyValueId, PropertyValue);
                                    IF TableObject2.GET(ObjectType2::Table, PropertyValueId) THEN BEGIN
                                      AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                      AddObjectUsedInRecord(
                                        WhereUsedIn, ObjectType2::Table, TableObject2."Object ID", ObjectLine.Type::Object, 0, '',
                                        TmpHistoryLine[1]."Line No.", FALSE);
                                    END;
                                    CurrentKeyNo := 0;
                                  END;

                                'SourceField' :
                                  BEGIN
                                    GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                    SplitPos := STRPOS(PropertyValue, '::');
                                    IF SplitPos > 0 THEN BEGIN
                                      VarName := DELSTR(PropertyValue, SplitPos);
                                      FieldName2 := COPYSTR(PropertyValue, SplitPos + 2);
                                      AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::SourceExpr, PropertyName);
                                      Expression := Mgt.AddQuotes(VarName) + '.' + Mgt.AddQuotes(FieldName2);
                                      AnalyseExpression(
                                        Expression, WhereUsedIn, TmpVariable, Object, TmpHistoryLine[1]."Line No.", Indent, NameOfIndent);
                                    END;
                                  END;

                                'SourceTableView' :
                                  BEGIN
                                    GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                    AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                    AnalyseTableView(
                                      PropertyValue, WhereUsedIn, Object.ID, CurrentKeyNo, TmpHistoryLine[1]."Line No.", TRUE);
                                  END;

                                'CalcFields' :
                                  BEGIN
                                    GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                    AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                    AnalyseEnumFields(PropertyValue, WhereUsedIn, TableObject, TmpHistoryLine[1]."Line No.", TRUE);
                                  END;

                                'LinkFields' :
                                  BEGIN
                                    GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                    AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                    TmpLinkedTable.SETRANGE(Name, ControlName);
                                    IF TmpLinkedTable.FINDFIRST THEN BEGIN
                                      TmpVariable.SETRANGE(Scope, TmpVariable.Scope::Global);
                                      TmpVariable.SETRANGE("Parent Name");
                                      TmpVariable.SETRANGE(Name, Mgt.AddQuotes(TmpLinkedTable."Case Name"));
                                      IF TmpVariable.FINDFIRST THEN
                                        IF TableObject.GET(TableObject."Object Type"::Table, TmpVariable."Object No.") THEN
                                          AnalyseLink(
                                            PropertyValue, WhereUsedIn,
                                            TableObject."Object ID", TableObject2."Object ID", TmpHistoryLine[1]."Line No.", TRUE);
                                      TmpVariable.SETRANGE(Scope);
                                    END;

                                  END;

                              END;
                            END;

                          Object.Type::Query :
                            BEGIN
                              IF TmpHistoryLine[1].Code[5] = '{' THEN BEGIN
                                Position := 7;
                                Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', PropertyValue);
                                Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', PropertyValue2);
                                Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', PropertyValue);
                                IF PropertyValue = 'DataItem' THEN BEGIN
                                  ItemCounter += 1;
                                  LinkReference := '';
                                  Indent := 1;
                                  CurrentKeyNo := 0;
                                  Mgt.NextValue(TmpHistoryLine[1].Code, Position, ';', '[', ']', DataItemName[ItemCounter]);
                                  NameOfIndent[1] := LOWERCASE(DataItemName[ItemCounter]);
                                  IF PropertyValue2 = '' THEN
                                    DataItemIndent[ItemCounter] := 0
                                  ELSE
                                    EVALUATE(DataItemIndent[ItemCounter], PropertyValue2);
                                END;
                              END;

                              PropertyCode := DELCHR(TmpHistoryLine[1].Code, '<>');
                              CALLineNo := TmpHistoryLine[1]."Line No.";
                              GetPropertyName(TmpHistoryLine[1], PropertyName);
                              CASE PropertyName OF

                                'DataItemTable' :
                                  BEGIN
                                    GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                    PropertyValue := COPYSTR(PropertyValue, 6);
                                    EVALUATE(PropertyValueId, PropertyValue);

                                    IF TableObject.GET(TableObject."Object Type"::Table, PropertyValueId) THEN
                                      ;

                                    AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                    AddObjectUsedInRecord(
                                      WhereUsedIn, ObjectType2::Table, PropertyValueId, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);
                                    IF ItemCounter > ARRAYLEN(DataItemTableNo) THEN
                                      EXIT;
                                    DataItemTableNo[ItemCounter] := PropertyValueId;
                                    IF DataItemName[ItemCounter] = '' THEN
                                      DataItemName[ItemCounter] := QueryTableName(TableObject."Object Name");
                                    IF NameOfIndent[1] = '' THEN
                                      NameOfIndent[1] := LOWERCASE(DataItemName[ItemCounter]);
                                  END;

                                'DataItemLink' :
                                  BEGIN
                                    AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                    GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                    AnalyseQueryLink(
                                      PropertyValue, WhereUsedIn, DataItemName, DataItemTableNo, ItemCounter, CALLineNo);
                                  END;

                                'DataItemTableFilter' :
                                  BEGIN
                                    GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                    AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                    AnalyseTableFilter(PropertyValue, WhereUsedIn, TableObject."Object ID", CALLineNo);
                                  END;

                                'DataSource' :
                                  BEGIN
                                    GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                    AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::SourceExpr, PropertyName);
                                    AnalyseExpression(PropertyValue, WhereUsedIn, TmpVariable, Object, CALLineNo, Indent, NameOfIndent);
                                  END;

                              END;

                            END;

                        END;

                      'ActionList=ACTIONS', 'CONTROLS-ActionList=ACTIONS' :
                        BEGIN
                          IF (CurrentSection = 'CONTROLS-ActionList=ACTIONS') AND
                             (TmpHistoryLine[1].Code[17] = '}')
                          THEN
                            CurrentSection := 'CONTROLS';
                          IF TmpHistoryLine[1].Code[SectionStartPos] <> ' ' THEN BEGIN
                            TmpHistoryLine[1].Code := COPYSTR(TmpHistoryLine[1].Code, SectionStartPos);
                            CALLineNo := TmpHistoryLine[1]."Line No.";
                            GetPropertyName(TmpHistoryLine[1], PropertyName);

                            CASE PropertyName OF

                              'Visible', 'Enabled' :
                                BEGIN
                                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  AnalyseExpression(PropertyValue, WhereUsedIn, TmpVariable, Object, CALLineNo, Indent, NameOfIndent);
                                END;

                              'RunObject' :
                                BEGIN
                                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                  SplitPos := STRPOS(PropertyValue, ' ');
                                  Object2.RESET;
                                  Object2.SETFILTER(Type, DELSTR(PropertyValue, SplitPos));
                                  Object2.SETRANGE("Company Name", '');
                                  Object2.SETFILTER(ID, COPYSTR(PropertyValue, SplitPos + 1));
                                  IF Object2.FINDFIRST THEN BEGIN
                                    AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                    AddObjectUsedInRecord(
                                      WhereUsedIn, Object2.Type, Object2.ID, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);
                                    AddObjectUsedInRecord(
                                      WhereUsedIn, Object2.Type, Object2.ID, ObjectLine.Type::Trigger, 1, '', CALLineNo, FALSE);
                                    SubPageId := Object2.ID;
                                  END;
                                END;

                              'RunPageView' :
                                BEGIN
                                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  IF WhereUsedObject.GET(ObjectType2::Page, SubPageId) THEN
                                    IF TableObject2.GET(ObjectType2::Table, WhereUsedObject."Table No.") THEN
                                      AnalyseTableView(PropertyValue, WhereUsedIn, TableObject2."Object ID", Dummy, CALLineNo, FALSE);
                                END;

                              'RunPageLink' :
                                BEGIN
                                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  IF WhereUsedObject.GET(ObjectType2::Page, SubPageId) THEN
                                    IF TableObject2.GET(ObjectType2::Table, WhereUsedObject."Table No.") THEN
                                      AnalyseLink(PropertyValue, WhereUsedIn, Object.ID, TableObject2."Object ID", CALLineNo, FALSE);
                                END;

                              'AccessByPermission' :
                                BEGIN
                                  GetPropertyValue(TmpHistoryLine[1], PropertyValue);
                                  AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Property, PropertyName);
                                  AnalyseAccessByPermission(PropertyValue, WhereUsedIn, CALLineNo);
                                END;

                            END;
                          END;

                        END;
                    END;
                END;
            END;

        UNTIL TmpHistoryLine[1].NEXT = 0;

      IF SaveVariableUsage THEN BEGIN

        ObjectLine.RESET;
        ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type);
        ObjectLine.SETRANGE("Object Type", Object.Type);
        ObjectLine.SETRANGE("Object No.", Object.ID);
        IF ObjectLine.FINDSET THEN
          REPEAT
            ObjectLine.CALCFIELDS("No. of Times Used");
            ObjectLine.Used := ObjectLine."No. of Times Used" > 0;
            ObjectLine.MODIFY;
          UNTIL ObjectLine.NEXT = 0;

      END ELSE BEGIN

        TmpVariable.RESET;
        TmpVariable.SETCURRENTKEY(Scope, Used);
        TmpVariable.SETRANGE(Scope, TmpVariable.Scope::Global);
        TmpVariable.SETRANGE(Used, TRUE);
        TmpVariable.SETFILTER("Parent Entry No.", '>0');

        WHILE TmpVariable.FINDLAST DO BEGIN
          ParentEntryNo := TmpVariable."Parent Entry No.";
          TmpVariable.DELETE;

          TmpVariable.SETRANGE("Parent Entry No.");
          TmpVariable.SETRANGE(Used);
          IF TmpVariable.GET(TmpVariable."Parent Entry No.") THEN
            TmpVariable.DELETE;
          TmpVariable.SETCURRENTKEY("Parent Entry No.");
          TmpVariable.SETRANGE("Parent Entry No.", ParentEntryNo);
          TmpVariable.DELETEALL;
          TmpVariable.SETCURRENTKEY(Scope, Used);
          TmpVariable.SETRANGE(Used, TRUE);
          TmpVariable.SETFILTER("Parent Entry No.", '>0');
        END;

        TmpVariable.RESET;
        TmpVariable.SETCURRENTKEY(Scope, Used);
        TmpVariable.SETRANGE(Scope, TmpVariable.Scope::Global);
        TmpVariable.SETRANGE(Type, TmpVariable.Type::Variable);
        TmpVariable.SETRANGE("Parent Entry No.", 0);
        TmpVariable.SETFILTER("C/AL Line No.", '>0');
        IF TmpVariable.FINDSET THEN BEGIN
          ObjectVariableLine.RESET;
          REPEAT
            IF NOT TmpVariable.Used THEN BEGIN
              ObjectVariableLine."Entry No." := 0;
              ObjectVariableLine."Object Type" := Object.Type;
              ObjectVariableLine."Object No." := Object.ID;
              ObjectVariableLine.Enabled := TRUE;
              ObjectVariableLine.Type := ObjectVariableLine.Type::"Global Variable";
              ObjectVariableLine.Id := TmpVariable.Id;
              ObjectVariableLine.Name := TmpVariable."Case Name";
              ObjectVariableLine."Parent No." := TmpVariable."Object Line Entry No.";
              ObjectVariableLine."C/AL Line No." := TmpVariable."C/AL Line No.";
              ObjectVariableLine.Used := TmpVariable.Used;
              ObjectVariableLine."Type Name" := TmpVariable."Type Name";
              ObjectVariableLine."Sub Type" := TmpVariable."Sub Type";
              ObjectVariableLine.INSERT;
            END;
          UNTIL TmpVariable.NEXT = 0;
        END;
      END;

      WhereUsedObject.GET(Object.Type, Object.ID);
      WhereUsedObject.Status := WhereUsedObject.Status::"Used in Updated";
      WhereUsedObject."Variable Usage Calculated" := SaveVariableUsage;
      WhereUsedObject.MODIFY;
    END;

    LOCAL PROCEDURE SetRangeOnSection@16(VAR CALHistoryObject@1000 : Record 11102052;VAR CALHistoryLine@1001 : Record 11102053;SectionName@1002 : Text) : Boolean;
    VAR
      SectionEnd@1003 : Integer;
      SectionStart@1004 : Integer;
    BEGIN
      CALHistoryLine.RESET;
      CALHistoryLine.SETRANGE("Sub Line No.", 1);
      CALHistoryLine.SETRANGE("Entry No.", CALHistoryObject."Entry No.");
      CALHistoryLine.SETRANGE(Code, '  ' + SectionName);
      IF CALHistoryLine.FINDFIRST THEN BEGIN
        SectionStart := CALHistoryLine."Line No." + 2;
        CALHistoryLine.SETFILTER("Line No.", '>%1', CALHistoryLine."Line No.");
        CALHistoryLine.SETRANGE("Sub Line No.", 1);
        CALHistoryLine.SETRANGE(Code, '  }');
        IF CALHistoryLine.FINDFIRST THEN
          SectionEnd := CALHistoryLine."Line No." - 1;
        IF (SectionStart <> 0) AND (SectionEnd <> 0) THEN BEGIN
          CALHistoryLine.RESET;
          CALHistoryLine.SETRANGE("Entry No.", CALHistoryObject."Entry No.");
          CALHistoryLine.SETRANGE("Line No.", SectionStart, SectionEnd);
          EXIT(TRUE);
        END;
      END;
    END;

    LOCAL PROCEDURE SetCodeSectionRange@17(VAR CALHistoryLine@1000 : Record 11102053;VAR CALHistoryLine2@1001 : Record 11102053;VAR CALHistoryLine3@1002 : Record 11102053;Opening@1003 : Text) ExitValue : Text;
    VAR
      GetTriggerPos@1004 : Integer;
    BEGIN
      GetTriggerPos := STRLEN(CALHistoryLine.Code) - STRLEN(Opening);
      WHILE NOT (CALHistoryLine.Code[GetTriggerPos] IN [' ', ';']) DO BEGIN
        ExitValue := FORMAT(CALHistoryLine.Code[GetTriggerPos]) + ExitValue;
        GetTriggerPos -= 1;
      END;

      IF Opening = '=VAR' THEN BEGIN
        CALHistoryLine2.RESET;
        CALHistoryLine2.SETRANGE("Entry No.", CALHistoryLine."Entry No.");
        CALHistoryLine2.SETFILTER("Line No.", '>%1', CALHistoryLine."Line No.");
        CALHistoryLine2.SETFILTER(Code, '%1', PADSTR('', STRPOS(CALHistoryLine.Code, Opening)) + 'BEGIN');
        CALHistoryLine2.FINDFIRST;
        CALHistoryLine2.SETRANGE(Code);
        CALHistoryLine2.SETRANGE("Line No.", CALHistoryLine."Line No." + 1, CALHistoryLine2."Line No." - 1);
      END ELSE BEGIN
        CALHistoryLine2.RESET;
        CALHistoryLine2.SETRANGE("Entry No.", CALHistoryLine."Entry No.");
        CALHistoryLine2.SETFILTER("Line No.", '<0');
        CALHistoryLine2."Line No." := CALHistoryLine."Line No.";
      END;

      CALHistoryLine3.RESET;
      CALHistoryLine3.SETRANGE("Entry No.", CALHistoryLine."Entry No.");
      CALHistoryLine3.SETFILTER("Line No.", '>%1', CALHistoryLine."Line No.");
      CALHistoryLine3.SETFILTER(Code, '%1', PADSTR('', STRPOS(CALHistoryLine.Code, Opening)) + 'END;');
      CALHistoryLine3.FINDFIRST;
      CALHistoryLine3.SETRANGE(Code);
      CALHistoryLine3.SETRANGE("Line No.", CALHistoryLine2."Line No." + 1, CALHistoryLine3."Line No." - 1);
    END;

    LOCAL PROCEDURE AnalyseTableView@18(VAR Expression@1000 : Text;VAR WhereUsedIn@1001 : Record 11102060;VAR TableId@1002 : Integer;VAR CurrentKeyNo@1003 : Integer;CALLineNo@1004 : Integer;WithFieldNo@1005 : Boolean);
    VAR
      ObjectLine@1006 : Record 11102058;
      Object@1007 : Record 2000000001;
      Object2@1008 : Record 2000000001;
      Fld@1009 : Record 2000000041;
      Mgt@1010 : Codeunit 11102035;
      Filter1@1011 : Text;
      Filter2@1012 : Text;
      Filter3@1013 : Text;
      KeyField@1014 : Text;
      KeyString@1015 : Text;
      SortingString@1016 : Text;
      WhereString@1017 : Text;
      OrderPos@1018 : Integer;
      Position@1019 : Integer;
      WherePos@1020 : Integer;
      GetNext@1021 : Boolean;
    BEGIN
      Expression := LOWERCASE(Expression);

      IF STRPOS(Expression, 'order') > 0 THEN BEGIN

        OrderPos := STRPOS(Expression, 'order(descending)');
        IF OrderPos > 0 THEN BEGIN
          Expression := DELSTR(Expression, OrderPos, STRLEN('order(descending)'));
          IF Expression[OrderPos] = ' ' THEN
            Expression := DELSTR(Expression, OrderPos, 1);
          IF OrderPos > 1 THEN
            IF Expression[OrderPos - 1] = ' ' THEN
              Expression := DELSTR(Expression, OrderPos - 1, 1);

        END;
        OrderPos := STRPOS(Expression, 'order(ascending)');
        IF OrderPos > 0 THEN BEGIN
          Expression := DELSTR(Expression, OrderPos, STRLEN('order(ascending)'));
          IF Expression[OrderPos] = ' ' THEN
            Expression := DELSTR(Expression, OrderPos, 1);
          IF OrderPos > 1 THEN
            IF Expression[OrderPos - 1] = ' ' THEN
              Expression := DELSTR(Expression, OrderPos - 1, 1);
        END;

      END;

      IF STRPOS(Expression, 'where') > 0 THEN BEGIN

        IF DELSTR(Expression, 7) = 'where(' THEN
          Expression := ' ' + Expression;

        WherePos := STRPOS(Expression, ')where(');
        IF WherePos > 0 THEN
          Expression := INSSTR(Expression, ' ', WherePos + 1);

        WherePos := STRPOS(Expression, ' where (');
        IF WherePos > 0 THEN
          Expression := DELSTR(Expression, WherePos + 6, 1);

        WherePos := STRPOS(Expression, ' where(');
        IF WherePos > 1 THEN
          IF Expression[WherePos - 1] = ' ' THEN BEGIN
            Expression := DELSTR(Expression, WherePos - 1, 1);
            WherePos -= 1;
          END;

      END;

      IF COPYSTR(Expression, 1, 8) = 'sorting(' THEN BEGIN
        CASE TRUE OF
          OrderPos > 0 :
            SortingString := COPYSTR(Expression, 9, OrderPos - 10);
          WherePos > 0 :
            SortingString := COPYSTR(Expression, 9, WherePos - 10);
          ELSE
            SortingString := COPYSTR(Expression, 9, STRLEN(Expression) - 9);
        END;
        Position := 1;
        WHILE Mgt.NextValue(SortingString, Position, ',', '"', '"', KeyField) DO BEGIN
          Fld.SETRANGE(TableNo, TableId);
          IF WithFieldNo THEN
            ReplaceFieldNo(KeyField, TableId);
          Fld.SETFILTER(FieldName, Mgt.CreateFieldFilter(KeyField, TRUE));
          IF Fld.FINDFIRST THEN BEGIN
            KeyString += ',' + FORMAT(Fld."No.");
            AddObjectUsedInRecord(WhereUsedIn, Object.Type::Table, TableId, ObjectLine.Type::Field, Fld."No.", '', CALLineNo, FALSE);
          END;
        END;
        IF KeyString <> '' THEN BEGIN
          KeyString := COPYSTR(KeyString, 2);

          IF GetUsedKey(ObjectLine, TableId, KeyString) THEN BEGIN
            AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);
            CurrentKeyNo := ObjectLine.Id;
          END;
        END;
      END;

      IF WherePos > 0 THEN BEGIN
        WhereString := COPYSTR(Expression, WherePos + 7, STRLEN(Expression) - 7);
        GetNext := TRUE;
        Position := 1;
        WHILE GetNext DO BEGIN

          GetNextFilter(WhereString, Position, Filter1, Filter2, Filter3);

          IF WithFieldNo THEN
            ReplaceFieldNo(Filter1, TableId);

          AddObjectUsedInRecord(
            WhereUsedIn, Object2.Type::Table, TableId, ObjectLine.Type::Field, 0, DELCHR(Filter1, '<>', '"'), CALLineNo, FALSE);

          GetNext := WhereString[Position] = ',';
          Position += 1;
        END;

      END;
    END;

    LOCAL PROCEDURE AnalyseTableFilter@77(VAR Expression@1000 : Text;VAR WhereUsedIn@1001 : Record 11102060;VAR TableId@1002 : Integer;CALLineNo@1003 : Integer);
    VAR
      ObjectLine@1004 : Record 11102058;
      Object2@1005 : Record 2000000001;
      Filter1@1006 : Text;
      Filter2@1007 : Text;
      Filter3@1008 : Text;
      WhereString@1009 : Text;
      Position@1010 : Integer;
      GetNext@1011 : Boolean;
    BEGIN
      Expression := LOWERCASE(Expression);

      GetNext := TRUE;
      Position := 1;
      WHILE GetNext DO BEGIN

        GetNextFilter(WhereString, Position, Filter1, Filter2, Filter3);
        AddObjectUsedInRecord(
          WhereUsedIn, Object2.Type::Table, TableId, ObjectLine.Type::Field, 0, DELCHR(Filter1, '<>', '"'), CALLineNo, FALSE);

        GetNext := WhereString[Position] = ',';
        Position += 1;
      END;
    END;

    LOCAL PROCEDURE GetUsedKey@19(VAR ObjectLine@1000 : Record 11102058;TableId@1001 : Integer;KeyString@1002 : Text) : Boolean;
    BEGIN
      ObjectLine.RESET;
      ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
      ObjectLine.SETRANGE("Object Type", ObjectLine."Object Type"::Table);
      ObjectLine.SETRANGE("Object No.", TableId);
      ObjectLine.SETRANGE(Type, ObjectLine.Type::Key);
      ObjectLine.SETFILTER(Name, KeyString + '*');
      ObjectLine.SETRANGE(Enabled, TRUE);
      IF ObjectLine.FINDSET THEN
        REPEAT
          IF (ObjectLine.Name = KeyString) OR
             (DELSTR(ObjectLine.Name, STRLEN(KeyString) + 2) = KeyString + ',')
          THEN
            EXIT(TRUE);
        UNTIL ObjectLine.NEXT = 0;

      ObjectLine.SETRANGE(Enabled, FALSE);
      IF ObjectLine.FINDSET THEN
        REPEAT
          IF (ObjectLine.Name = KeyString) OR
             (DELSTR(ObjectLine.Name, STRLEN(KeyString) + 2) = KeyString + ',')
          THEN
            EXIT(TRUE);
        UNTIL ObjectLine.NEXT = 0;
    END;

    LOCAL PROCEDURE AnalyseCalcFormula@20(VAR Expression@1000 : Text;VAR WhereUsedIn@1001 : Record 11102060;VAR Object@1002 : Record 2000000001;CALLineNo@1003 : Integer);
    VAR
      ObjectLine@1004 : Record 11102058;
      ObjectLine2@1005 : Record 11102058;
      TmpDisabledKey@1006 : TEMPORARY Record 11102058;
      TmpEnabledKey@1007 : TEMPORARY Record 11102058;
      AllObj@1008 : Record 2000000038;
      Field@1009 : Record 2000000041;
      Mgt@1010 : Codeunit 11102035;
      FieldName2@1011 : Text;
      Filter1@1012 : Text;
      Filter2@1013 : Text;
      Filter3@1014 : Text;
      KeyFilter@1015 : Text;
      KeyFilter1@1016 : Text;
      KeyFilter2@1017 : Text;
      SIFFilterFieldName@1018 : Text;
      String@1019 : Text;
      TableName2@1020 : Text;
      FilterFieldNo@1021 : ARRAY [100] OF Integer;
      FirstOtherField2@1022 : ARRAY [100] OF Integer;
      FlowFilterFieldNo@1023 : ARRAY [100] OF Integer;
      FlowFilterFieldNo2@1024 : ARRAY [100] OF Integer;
      HighestFirstOtherField@1025 : Integer;
      i@1026 : Integer;
      i2@1027 : Integer;
      j@1028 : Integer;
      KeyCounter@1029 : Integer;
      NoOfFilters@1030 : Integer;
      NoOfFlowFilters@1031 : Integer;
      NoOfFlowFilters2@1032 : Integer;
      NoOfOptions@1033 : Integer;
      Position@1034 : Integer;
      Power2@1035 : ARRAY [100] OF Integer;
      SIFFilterTableNo@1036 : Integer;
      AnalyseSIF@1037 : Boolean;
      GetNext@1038 : Boolean;
      IsFlowFilter@1039 : Boolean;
      KeyFound@1040 : Boolean;
    BEGIN
      Expression := LOWERCASE(Expression);
      Position := 1;

      IF Expression[1] = '-' THEN
        Position := 2;

      NextValueTill(Expression, Position, 0, '(', String);
      AnalyseSIF := String IN ['sum', 'average'];

      IF String IN ['count', 'exist'] THEN
        NextValueTill(Expression, Position, '"', ' )', TableName2)
      ELSE BEGIN
        NextValueTill(Expression, Position, '"', '.', TableName2);
        NextValueTill(Expression, Position, '"', ' )', FieldName2);
      END;

      IF GetTableByName(AllObj, TableName2, FALSE) THEN BEGIN
        AddObjectUsedInRecord(
          WhereUsedIn, AllObj."Object Type"::Table, AllObj."Object ID", ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);
        SIFFilterTableNo := AllObj."Object ID";
        SIFFilterFieldName := FieldName2;
      END;

      IF FieldName2 <> '' THEN
        AddObjectUsedInRecord(
          WhereUsedIn, Object.Type::Table, AllObj."Object ID", ObjectLine.Type::Field, 0, FieldName2, CALLineNo, FALSE);

      GetNext := COPYSTR(Expression, Position, 5) = 'where';
      Position += 7;
      WHILE GetNext DO BEGIN

        GetNextFilter(Expression, Position, Filter1, Filter2, Filter3);

        AddObjectUsedInRecord(
          WhereUsedIn, Object.Type::Table, AllObj."Object ID", ObjectLine.Type::Field, 0, DELCHR(Filter1, '<>', '"'), CALLineNo, FALSE);

        IF Filter2 = 'field' THEN
          AddObjectUsedInRecord(
            WhereUsedIn, Object.Type::Table, Object.ID, ObjectLine.Type::Field, 0, DELCHR(Filter3, '<>', '"'), CALLineNo, FALSE);

        IF AnalyseSIF THEN BEGIN

          IsFlowFilter := FALSE;
          IF Filter2 = 'field' THEN BEGIN
            Field.SETRANGE(TableNo, Object.ID);
            Field.SETFILTER(FieldName, Mgt.CreateFieldFilter(Filter3, TRUE));
            IF Field.FINDFIRST THEN
              IsFlowFilter := Field.Class = Field.Class::FlowFilter;
          END;

          Field.SETRANGE(TableNo, SIFFilterTableNo);
          Field.SETFILTER(FieldName, Mgt.CreateFieldFilter(Filter1, TRUE));
          IF Field.FINDFIRST THEN
            IF IsFlowFilter THEN BEGIN
              NoOfFlowFilters += 1;
              FlowFilterFieldNo[NoOfFlowFilters] := Field."No.";
            END ELSE BEGIN
              KeyFilter1 += '&*,' + FORMAT(Field."No.") + ',*';
              NoOfFilters += 1;
              FilterFieldNo[NoOfFilters] := Field."No.";
            END;
        END;

        GetNext := Expression[Position] = ',';
        Position += 1;
      END;

      IF AnalyseSIF THEN BEGIN

        ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
        ObjectLine.SETRANGE("Object Type", ObjectLine."Object Type"::Table);
        ObjectLine.SETRANGE("Object No.", SIFFilterTableNo);
        ObjectLine.SETRANGE(Type, ObjectLine.Type::"Sum Index Field");
        ObjectLine.SETFILTER(Name, Mgt.CreateFilter(SIFFilterFieldName, TRUE));

        IF ObjectLine.FINDSET THEN
          REPEAT
            ObjectLine2.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
            ObjectLine2.SETRANGE("Object Type", ObjectLine2."Object Type"::Table);
            ObjectLine2.SETRANGE("Object No.", SIFFilterTableNo);
            ObjectLine2.SETRANGE(Type, ObjectLine2.Type::Key);
            ObjectLine2.SETRANGE(Id, ROUND(ObjectLine.Id / 100, 1, '<'));
            IF ObjectLine2.FINDFIRST THEN
              IF ObjectLine2.Enabled THEN BEGIN
                TmpEnabledKey := ObjectLine2;
                TmpEnabledKey.Name := ',' + TmpEnabledKey.Name + ',';
                TmpEnabledKey.Id := ObjectLine.Id;
                TmpEnabledKey.Enabled := FALSE;
                TmpEnabledKey.INSERT;
              END ELSE BEGIN
                TmpDisabledKey := ObjectLine2;
                TmpDisabledKey.Name := ',' + TmpDisabledKey.Name + ',';
                TmpDisabledKey.Id := ObjectLine.Id;
                TmpDisabledKey.INSERT;
              END;

          UNTIL ObjectLine.NEXT = 0;

        IF NoOfFlowFilters > 10 THEN
          NoOfFlowFilters := 10;

        FOR j := 1 TO NoOfFlowFilters DO
          Power2[j] := POWER(2, NoOfFlowFilters - j);
        NoOfOptions := POWER(2, NoOfFlowFilters);
        FOR i := 0 TO NoOfOptions - 1 DO BEGIN

          i2 := i;
          KeyFilter2 := '';
          NoOfFlowFilters2 := 0;

          FOR j := 1 TO NoOfFlowFilters DO
            IF i2 >= Power2[j] THEN BEGIN
              KeyFilter2 += '&*,' + FORMAT(FlowFilterFieldNo[j]) + ',*';
              i2 -= Power2[j];
              NoOfFlowFilters2 += 1;
              FlowFilterFieldNo2[NoOfFlowFilters2] := FlowFilterFieldNo[j];
            END;

          HighestFirstOtherField := 0;
          KeyFilter := COPYSTR(KeyFilter1 + KeyFilter2, 2);
          TmpEnabledKey.SETFILTER(Name, KeyFilter);
          IF TmpEnabledKey.FINDFIRST THEN BEGIN
            KeyCounter := 0;
            REPEAT
              KeyCounter += 1;
              FirstOtherField2[KeyCounter] :=
                FirstOtherField(TmpEnabledKey.Name, NoOfFilters, FilterFieldNo, NoOfFlowFilters2, FlowFilterFieldNo2);

              IF FirstOtherField2[KeyCounter] > HighestFirstOtherField THEN
                HighestFirstOtherField := FirstOtherField2[KeyCounter];
            UNTIL TmpEnabledKey.NEXT = 0;
            KeyFound := FALSE;
            KeyCounter := 0;
            TmpEnabledKey.FINDFIRST;
            REPEAT
              KeyCounter += 1;
              IF FirstOtherField2[KeyCounter] = HighestFirstOtherField THEN BEGIN
                IF NOT TmpEnabledKey.Enabled THEN BEGIN
                  TmpEnabledKey.Enabled := TRUE;
                  TmpEnabledKey.MODIFY;
                END;
                KeyFound := TRUE;
              END;
            UNTIL (TmpEnabledKey.NEXT = 0) OR KeyFound;
          END ELSE BEGIN
            TmpDisabledKey.SETFILTER(Name, KeyFilter);
            IF TmpDisabledKey.FINDFIRST THEN
              IF NOT TmpDisabledKey.Enabled THEN BEGIN
                TmpDisabledKey.Enabled := TRUE;
                TmpDisabledKey.MODIFY;
              END;
          END;
        END;

        TmpEnabledKey.SETRANGE(Name);
        TmpEnabledKey.SETRANGE(Enabled, TRUE);
        IF TmpEnabledKey.FINDSET THEN
          REPEAT
            AddCrossTableRecord(TmpEnabledKey."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);
            ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
            ObjectLine.SETRANGE(Id, TmpEnabledKey.Id);
            ObjectLine.FINDFIRST;
            AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);
          UNTIL TmpEnabledKey.NEXT = 0;

        TmpDisabledKey.SETRANGE(Name);
        TmpDisabledKey.SETRANGE(Enabled, TRUE);
        IF TmpDisabledKey.FINDSET THEN
          REPEAT
            AddCrossTableRecord(TmpDisabledKey."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);
            ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
            ObjectLine.SETRANGE(Id, TmpDisabledKey.Id);
            ObjectLine.FINDFIRST;
            AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);
          UNTIL TmpDisabledKey.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE FirstOtherField@21(VAR KeyString@1000 : Text;VAR NoOfFilters@1001 : Integer;VAR FilterFieldNo@1002 : ARRAY [100] OF Integer;VAR NoOfFlowFilters@1003 : Integer;VAR FlowFilterFieldNo@1004 : ARRAY [100] OF Integer) : Integer;
    VAR
      Mgt@1005 : Codeunit 11102035;
      FieldNoString@1006 : Text;
      FieldCounter@1007 : Integer;
      FieldNo2@1008 : Integer;
      i@1009 : Integer;
      Position@1010 : Integer;
      FieldIsFilter@1011 : Boolean;
    BEGIN
      Position := 2;
      WHILE Mgt.NextValue(KeyString, Position, ',', ' ', ' ', FieldNoString) DO BEGIN
        FieldCounter += 1;
        EVALUATE(FieldNo2, FieldNoString);
        FieldIsFilter := FALSE;
        i := 1;
        WHILE ((i <= NoOfFilters) OR (i <= NoOfFlowFilters)) AND NOT FieldIsFilter DO BEGIN
          IF (i <= NoOfFilters) AND (FilterFieldNo[i] = FieldNo2) THEN
            FieldIsFilter := TRUE;

          IF (i <= NoOfFlowFilters) AND (FlowFilterFieldNo[i] = FieldNo2) THEN
            FieldIsFilter := TRUE;

          i += 1;
        END;
        IF NOT FieldIsFilter THEN
          EXIT(FieldCounter);
      END;
      EXIT(99);
    END;

    LOCAL PROCEDURE AnalyseLink@22(VAR Expression@1000 : Text;VAR WhereUsedIn@1001 : Record 11102060;VAR TableId1@1002 : Integer;VAR TableId2@1003 : Integer;CALLineNo@1004 : Integer;WithFieldNo@1005 : Boolean);
    VAR
      ObjectLine@1006 : Record 11102058;
      Object@1007 : Record 2000000001;
      Filter1@1008 : Text;
      Filter2@1009 : Text;
      Filter3@1010 : Text;
      Position@1011 : Integer;
      GetNext@1012 : Boolean;
    BEGIN
      Expression := LOWERCASE(Expression);
      Position := 1;

      GetNext := TRUE;
      WHILE GetNext DO BEGIN

        GetNextFilter(Expression, Position, Filter1, Filter2, Filter3);

        IF WithFieldNo THEN
          ReplaceFieldNo(Filter1, TableId2);

        AddObjectUsedInRecord(
          WhereUsedIn, Object.Type::Table, TableId2, ObjectLine.Type::Field, 0, DELCHR(Filter1, '<>', '"'), CALLineNo, FALSE);

        IF Filter2 = 'field' THEN BEGIN

          IF WithFieldNo THEN
            ReplaceFieldNo(Filter3, TableId1);

          AddObjectUsedInRecord(
            WhereUsedIn, Object.Type::Table, TableId1, ObjectLine.Type::Field, 0, DELCHR(Filter3, '<>', '"'), CALLineNo, FALSE);
        END;

        GetNext := Expression[Position] = ',';
        Position += 1;
      END;
    END;

    LOCAL PROCEDURE AnalyseQueryLink@23(VAR Expression@1000 : Text;VAR WhereUsedIn@1001 : Record 11102060;VAR RefItemName@1002 : ARRAY [250] OF Text;VAR RefItemNo@1003 : ARRAY [250] OF Integer;CurrentItemNo@1004 : Integer;CALLineNo@1005 : Integer);
    VAR
      ObjectLine@1006 : Record 11102058;
      Object@1007 : Record 2000000001;
      Mgt@1008 : Codeunit 11102035;
      FieldName2@1009 : Text;
      RefFieldName@1010 : Text;
      RefTableName@1011 : Text;
      i@1012 : Integer;
      Position@1013 : Integer;
      RefTableNo@1014 : Integer;
      StopLoop@1015 : Boolean;
    BEGIN
      Position := 1;
      WHILE NOT StopLoop DO BEGIN

        Mgt.NextValue(Expression, Position, '=', '"', '"', FieldName2);
        Mgt.NextValue(Expression, Position, '.', '"', '"', RefTableName);
        Mgt.NextValue(Expression, Position, ',', '"', '"', RefFieldName);

        IF (FieldName2 <> '') AND (RefFieldName <> '') THEN BEGIN

          AddObjectUsedInRecord(
            WhereUsedIn, Object.Type::Table, RefItemNo[CurrentItemNo], ObjectLine.Type::Field, 0, FieldName2, CALLineNo, FALSE);

          RefTableNo := 0;
          FOR i := 1 TO CurrentItemNo - 1 DO
            IF LOWERCASE(RefTableName) = LOWERCASE(RefItemName[i]) THEN
              RefTableNo := RefItemNo[i];

          IF RefTableNo <> 0 THEN
            AddObjectUsedInRecord(
              WhereUsedIn, Object.Type::Table, RefTableNo, ObjectLine.Type::Field, 0, RefFieldName, CALLineNo, FALSE);

        END ELSE
          StopLoop := TRUE;

      END;
    END;

    LOCAL PROCEDURE AnalyseAccessByPermission@43(VAR Expression@1000 : Text;VAR WhereUsedIn@1001 : Record 11102060;CALLineNo@1002 : Integer);
    VAR
      ObjectLine@1003 : Record 11102058;
      Object@1004 : Record 2000000001;
      ObjectNoText@1005 : Text;
      ObjectTypeText@1006 : Text;
      Position@1007 : Integer;
    BEGIN
      Expression := LOWERCASE(Expression);

      Position := 1;

      NextValueTill(Expression, Position, '"', ' ', ObjectTypeText);
      NextValueTill(Expression, Position, '"', ' =;,', ObjectNoText);

      IF ObjectTypeText = 'tabledata' THEN
        ObjectTypeText := 'table';

      IF EVALUATE(Object.Type, ObjectTypeText) AND EVALUATE(Object.ID, ObjectNoText) THEN
        AddObjectUsedInRecord(WhereUsedIn, Object.Type, Object.ID, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);
    END;

    LOCAL PROCEDURE GetNextFilter@24(VAR Expression@1000 : Text;VAR Position@1001 : Integer;VAR First@1002 : Text;VAR Compare@1003 : Text;VAR NextString@1004 : Text);
    VAR
      Mgt@1005 : Codeunit 11102035;
    BEGIN
      Mgt.NextValue(Expression, Position, '=', '"', '"', First);
      Mgt.NextValue(Expression, Position, '(', ')', ')', Compare);
      NextFilter(Expression, Position, ')', NextString);

      IF DELSTR(NextString, 12) = 'upperlimit(' THEN BEGIN
        NextString := COPYSTR(NextString, 12);
        Position += 1;
      END;

      IF DELSTR(NextString, 8) = 'filter(' THEN BEGIN
        NextString := COPYSTR(NextString, 8);
        Position += 1;
      END;
    END;

    LOCAL PROCEDURE NextFilter@78(VAR TextLine@1000 : Text;VAR Position@1001 : Integer;CloseChar@1002 : Char;VAR ExitValue@1003 : Text) : Boolean;
    VAR
      Mgt@1004 : Codeunit 11102035;
      SplitCharacters@1005 : Text;
      StartCharacters@1006 : Text;
      Char@1007 : Char;
      StartCharacter@1008 : Char;
      Advanced@1009 : Boolean;
      FirstCharacter@1010 : Boolean;
      SetFirstCharacter@1011 : Boolean;
      Stop@1012 : Boolean;
    BEGIN
      ExitValue := '';
      FirstCharacter := TRUE;

      IF Position > STRLEN(TextLine) THEN
        EXIT(FALSE);

      SplitCharacters := '|&';
      StartCharacters := '''"';

      WHILE NOT Stop DO

        IF Mgt.NextChar(TextLine, Position, Char) THEN BEGIN

          CASE TRUE OF

            Advanced :
              IF Char = StartCharacter THEN BEGIN
                IF Mgt.NextChar(TextLine, Position, Char) THEN
                  IF Char = StartCharacter THEN
                    ExitValue += FORMAT(Char)
                  ELSE BEGIN
                    Advanced := FALSE;
                    Position -= 1;
                  END;
              END ELSE
                ExitValue += FORMAT(Char);

            STRPOS(StartCharacters, FORMAT(Char)) > 0 :
              IF FirstCharacter THEN BEGIN
                StartCharacter := Char;
                Advanced := TRUE;
              END ELSE
                ExitValue += FORMAT(Char);

            STRPOS(SplitCharacters, FORMAT(Char)) > 0 :
              BEGIN
                ExitValue += FORMAT(Char);
                SetFirstCharacter := TRUE;
              END;

            Char = CloseChar :
              Stop := TRUE;

            ELSE
              ExitValue += FORMAT(Char);
          END;

          IF SetFirstCharacter THEN BEGIN
            FirstCharacter := TRUE;
            SetFirstCharacter := FALSE;
          END ELSE
            FirstCharacter := FALSE;

        END ELSE
          Stop := TRUE;

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE AnalyseEnumFields@25(VAR Expression@1000 : Text;VAR WhereUsedIn@1001 : Record 11102060;VAR TableObject@1002 : Record 2000000038;CALLineNo@1003 : Integer;WithFieldNo@1004 : Boolean);
    VAR
      ObjectLine@1005 : Record 11102058;
      Mgt@1006 : Codeunit 11102035;
      FieldName2@1007 : Text;
      Position@1008 : Integer;
    BEGIN
      Position := 1;
      WHILE Mgt.NextValue(Expression, Position, ',', '"', '"', FieldName2) DO BEGIN

        IF WithFieldNo THEN
          ReplaceFieldNo(FieldName2, TableObject."Object ID");

        AddObjectUsedInRecord(
          WhereUsedIn, TableObject."Object Type", TableObject."Object ID", ObjectLine.Type::Field,
          0, FieldName2, CALLineNo, FALSE);
      END;
    END;

    LOCAL PROCEDURE AnalyseTableRelation@26(VAR Expression@1000 : Text;VAR WhereUsedIn@1001 : Record 11102060;VAR TableId@1002 : Integer;FieldNo2@1003 : Integer;CALLineNo@1004 : Integer);
    VAR
      ObjectLine@1005 : Record 11102058;
      AllObj@1006 : Record 2000000038;
      Fld2@1007 : Record 2000000041;
      Mgt@1008 : Codeunit 11102035;
      RecRef@1009 : RecordRef;
      FldRef@1010 : FieldRef;
      KeyRef@1011 : KeyRef;
      FieldString@1012 : Text;
      Filter1@1013 : Text;
      Filter2@1014 : Text;
      Filter3@1015 : Text;
      NextString@1016 : Text;
      TableString@1017 : Text;
      Position@1018 : Integer;
      GetNext@1019 : Boolean;
      GetNext2@1020 : Boolean;
      GetNextFilter2@1021 : Boolean;
    BEGIN
      Expression := LOWERCASE(Expression);
      Position := 1;

      GetNext := Expression <> '';
      WHILE GetNext DO BEGIN

        NextString := '';
        NextValueTill(Expression, Position, '"', ' .;}', TableString);

        IF TableString = 'else' THEN
          NextValueTill(Expression, Position, '"', ' .;}', TableString);

        IF TableString = 'if' THEN BEGIN

          GetNextFilter2 := TRUE;
          WHILE GetNextFilter2 DO BEGIN

            Position += 1;
            GetNextFilter(Expression, Position, Filter1, Filter2, Filter3);

            AddObjectUsedInRecord(
              WhereUsedIn, ObjectLine."Object Type"::Table, TableId, ObjectLine.Type::Field,
              0, DELCHR(Filter1, '<>', '"'), CALLineNo, FALSE);

            NextString := '';

            IF Position > 1000 THEN
              EXIT;

            GetNextFilter2 := Expression[Position] = ',';
            Position += 1;
          END;
          Position += 1;
          NextValueTill(Expression, Position, '"', ' .;}', TableString);
        END;

        IF Position > 1000 THEN
          EXIT;

        FieldString := '';
        IF Expression[Position - 1] = '.' THEN
          NextValueTill(Expression, Position, '"', ' ;}', FieldString);

        IF GetTableByName(AllObj, TableString, TRUE) THEN BEGIN
          AddObjectUsedInRecord(
            WhereUsedIn, ObjectLine."Object Type"::Table, AllObj."Object ID", ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);

          IF FieldString = '' THEN BEGIN
            RecRef.OPEN(AllObj."Object ID");
            KeyRef := RecRef.KEYINDEX(1);
            FldRef := KeyRef.FIELDINDEX(1);

            AddObjectUsedInRecord(
              WhereUsedIn, ObjectLine."Object Type"::Table, AllObj."Object ID", ObjectLine.Type::Field,
              0, FldRef.NAME, CALLineNo, FALSE);
            RecRef.CLOSE;

            IF FieldNo2 <> 0 THEN
              AddRelationRecord(TableId, FieldNo2, AllObj."Object ID", FldRef.NUMBER);

          END ELSE BEGIN
            AddObjectUsedInRecord(
              WhereUsedIn, ObjectLine."Object Type"::Table, AllObj."Object ID", ObjectLine.Type::Field,
              0, DELCHR(FieldString, '<>', '"'), CALLineNo, FALSE);

            IF FieldNo2 <> 0 THEN BEGIN
              Fld2.SETRANGE(TableNo, AllObj."Object ID");
              Fld2.SETFILTER(FieldName, Mgt.CreateFieldFilter(FieldString, TRUE));
              IF Fld2.FINDFIRST THEN
                AddRelationRecord(TableId, FieldNo2, AllObj."Object ID", Fld2."No.");
            END;

          END;

        END;

        GetNext2 := COPYSTR(Expression, Position, 5) = 'where';
        IF GetNext2 THEN BEGIN
          Position += 1;
          NextValueTill(Expression, Position, '"', ' ', FieldString);

          WHILE GetNext2 DO BEGIN

            Position += 1;
            GetNextFilter(Expression, Position, Filter1, Filter2, Filter3);

            AddObjectUsedInRecord(
              WhereUsedIn, ObjectLine."Object Type"::Table, AllObj."Object ID", ObjectLine.Type::Field,
              0, DELCHR(Filter1, '<>', '"'), CALLineNo, FALSE);

            IF Filter2 = 'field' THEN
              AddObjectUsedInRecord(
                WhereUsedIn, ObjectLine."Object Type"::Table, TableId, ObjectLine.Type::Field,
                0, DELCHR(Filter3, '<>', '"'), CALLineNo, FALSE);

            GetNext2 := Expression[Position] = ',';
            Position += 1;
          END;
        END;

        GetNext := Position < STRLEN(Expression);

      END;
    END;

    LOCAL PROCEDURE AnalyseExpression@27(VAR Expression@1000 : Text;VAR WhereUsedIn@1001 : Record 11102060;VAR Variable@1002 : Record 11102062;VAR Object@1003 : Record 2000000001;VAR CALLineNo@1004 : Integer;VAR Indent@1005 : Integer;VAR NameOfIndent@1006 : ARRAY [100] OF Text);
    VAR
      ObjectLine@1007 : Record 11102058;
      Object2@1008 : Record 2000000001;
      Mgt@1009 : Codeunit 11102035;
      AccoladeExpr@1010 : Text;
      CoupleString@1011 : Text;
      First@1012 : Text;
      Last@1013 : Text;
      NextString@1014 : Text;
      Parent@1015 : Text;
      PreviousFirst@1016 : Text;
      PreviousLast@1017 : Text;
      String@1018 : Text;
      Position@1019 : Integer;
    BEGIN
      Expression := LOWERCASE(Expression);

      IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, '', Expression) THEN BEGIN
        FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);
        EXIT;
      END;

      Position := 1;
      WHILE GetNextStatementInExpr(Expression, Position, String, NextString, First, CoupleString, Last, AccoladeExpr) DO BEGIN

        IF AccoladeExpr <> '' THEN
          AnalyseExpression(AccoladeExpr, WhereUsedIn, Variable, Object, CALLineNo, Indent, NameOfIndent);

        IF CoupleString = '::' THEN
          IF First IN ['codeunit', 'database', 'report', 'xmlport', 'page', 'query'] THEN BEGIN
            IF First = 'database' THEN
              Object2.SETRANGE(Type, Object2.Type::Table)
            ELSE
              Object2.SETFILTER(Type, First);
            Object2.SETFILTER(Name, Mgt.CreateFilter(Last, TRUE));
            IF Object2.FINDFIRST THEN
              AddObjectUsedInRecord(WhereUsedIn, Object2.Type, Object2.ID, ObjectLine.Type::Object, 0, '', CALLineNo, FALSE);

          END ELSE BEGIN
            IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, '', First) THEN
              FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

          END

        ELSE

          CASE Last OF

            '.' :
              IF NextString = 'page' THEN
                IF PreviousFirst = 'currpage' THEN BEGIN
                  GetNextStatementInExpr(Expression, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);

                  IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, PreviousLast, Last) THEN
                    FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

                END;

            'getfilter', 'fieldcaption', 'fieldname', 'fieldno', 'getrangemin', 'getrangemax' :
              BEGIN
                IF CoupleString = '.' THEN
                  Parent := First
                ELSE
                  Parent := '';

                IF NextString = '(' THEN BEGIN
                  GetNextStatementInExpr(Expression, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                  GetNextStatementInExpr(Expression, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);

                  IF AccoladeExpr <> '' THEN
                    AnalyseExpression(AccoladeExpr, WhereUsedIn, Variable, Object, CALLineNo, Indent, NameOfIndent);

                  IF CoupleString = '.' THEN BEGIN
                    IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, First, Last) THEN
                      FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);
                  END ELSE
                    IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Parent, First) THEN
                      FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

                END;

              END;

            ';', '(', ')' :
              ;

            ELSE BEGIN

              IF CoupleString = '.' THEN
                Parent := First
              ELSE
                Parent := '';

              IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Parent, Last) THEN
                FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

            END;

          END;

        IF First = 'currpage' THEN BEGIN
          PreviousFirst := First;
          PreviousLast := Last;
        END;

      END;
    END;

    LOCAL PROCEDURE GetNextStatementInExpr@28(VAR Expression@1000 : Text;VAR Position@1001 : Integer;VAR Statement@1002 : Text;VAR NextStatement@1003 : Text;VAR First@1004 : Text;VAR CoupleString@1005 : Text;VAR Last@1006 : Text;VAR AccoladeExpr@1007 : Text) ExitValue : Boolean;
    VAR
      NextExp@1008 : Text;
      Stat1@1009 : Text;
      Stat2@1010 : Text;
      Stat3@1011 : Text;
    BEGIN
      AccoladeExpr := '';

      GetNextStatementInExprSub(Expression, Position, NextExp, AccoladeExpr);

      IF NextStatement = '' THEN BEGIN
        IF NextExp = '' THEN
          EXIT(FALSE);
        Statement := NextExp;
        GetNextStatementInExprSub(Expression, Position, NextStatement, AccoladeExpr);
      END ELSE BEGIN
        Statement := NextStatement;
        NextStatement := NextExp;
      END;

      IF NextStatement IN ['.', '::'] THEN BEGIN
        Stat1 := Statement;
        Stat2 := NextStatement;
        GetNextStatementInExprSub(Expression, Position, Statement, AccoladeExpr);
        Stat3 := Statement;

        Statement := Stat1 + Stat2 + Stat3;

        First := Stat1;
        CoupleString := Stat2;
        Last := Stat3;

        GetNextStatementInExprSub(Expression, Position, NextStatement, AccoladeExpr);

      END ELSE BEGIN
        First := Statement;
        CoupleString := '';
        Last := Statement;
      END;

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE GetNextStatementInExprSub@29(VAR Expression@1000 : Text;VAR Position@1001 : Integer;VAR Statement@1002 : Text;VAR AccoladeExpr@1003 : Text);
    VAR
      Mgt@1004 : Codeunit 11102035;
      Char@1005 : Char;
      AccoladeOpen@1006 : Integer;
      AddChar@1007 : Boolean;
      AddingStarted@1008 : Boolean;
      StopLoop@1009 : Boolean;
      SubTextOpen@1010 : Boolean;
      SubVariableOpen@1011 : Boolean;
      TextOpen@1012 : Boolean;
      VariableOpen@1013 : Boolean;
    BEGIN
      Statement := '';

      WHILE NOT StopLoop DO

        IF NextCharInExpr(Expression, Position, Char) THEN BEGIN
          AddChar := FALSE;

          CASE TRUE OF

            VariableOpen :
              BEGIN
                IF Char = '"' THEN
                  VariableOpen := FALSE;
                AddChar := TRUE;
              END;

            TextOpen :
              IF Char = '''' THEN
                TextOpen := FALSE;

            AccoladeOpen > 0 :
              BEGIN

                CASE TRUE OF

                  SubVariableOpen :
                    IF Char = '"' THEN
                      SubVariableOpen := FALSE;

                  SubTextOpen :
                    IF Char = '''' THEN
                      SubTextOpen := FALSE;

                  Char = '''' :
                    SubTextOpen := TRUE;

                  Char = '"' :
                    SubVariableOpen := TRUE;
                END;

                IF NOT SubVariableOpen AND NOT SubTextOpen THEN BEGIN
                  IF Char = '[' THEN
                    AccoladeOpen += 1;
                  IF Char = ']' THEN
                    AccoladeOpen -= 1;
                END;
                IF AccoladeOpen > 0 THEN
                  AccoladeExpr += FORMAT(Char);
              END;

            Char = '''' :
              TextOpen := TRUE;

            Char = '"' :
              BEGIN
                VariableOpen := TRUE;
                AddChar := TRUE;
              END;

            Char = '[' :
              AccoladeOpen += 1;

            Char = ':' :
              IF Expression[Position] = ':' THEN
                IF AddingStarted THEN BEGIN
                  Position -= 1;
                  StopLoop := TRUE;
                END ELSE BEGIN
                  Position += 1;
                  Statement := '::';
                  StopLoop := TRUE;
                END;

            Char IN [';', '.', '(', ')'] :
              IF AddingStarted THEN BEGIN
                Position -= 1;
                StopLoop := TRUE;
              END ELSE BEGIN
                Statement := FORMAT(Char);
                StopLoop := TRUE;
              END;

            NOT Mgt.SpecialCharacter(Char) :
              AddChar := TRUE;

            ELSE
              IF AddingStarted THEN
                StopLoop := TRUE;

          END;

          IF AddChar THEN BEGIN
            Statement += FORMAT(Char);
            AddingStarted := TRUE;
          END;

        END ELSE
          StopLoop := TRUE;
    END;

    LOCAL PROCEDURE NextCharInExpr@30(VAR Expression@1000 : Text;VAR Position@1001 : Integer;VAR Char@1002 : Char) : Boolean;
    BEGIN
      IF Position <= STRLEN(Expression) THEN BEGIN
        Char := Expression[Position];
        Position += 1;
        EXIT(TRUE);
      END ELSE
        EXIT(FALSE);
    END;

    LOCAL PROCEDURE NextValueTill@31(VAR TextLine@1000 : Text;VAR Position@1001 : Integer;OpenChar@1002 : Char;StopChars@1003 : Text;VAR ExitValue@1004 : Text) : Boolean;
    VAR
      Mgt@1005 : Codeunit 11102035;
      Char@1006 : Char;
      Advanced@1007 : Boolean;
      FirstCharacter@1008 : Boolean;
      Stop@1009 : Boolean;
    BEGIN
      ExitValue := '';
      FirstCharacter := TRUE;

      IF Position > STRLEN(TextLine) THEN
        EXIT(FALSE);

      WHILE NOT Stop DO

        IF Mgt.NextChar(TextLine, Position, Char) THEN BEGIN

          CASE TRUE OF

            Char = OpenChar :
              IF FirstCharacter THEN
                Advanced := TRUE
              ELSE
                IF Advanced THEN BEGIN
                  IF Mgt.NextChar(TextLine, Position, Char) THEN
                    IF Char = OpenChar THEN
                      ExitValue += FORMAT(Char)
                    ELSE BEGIN
                      Advanced := FALSE;
                      Position -= 1;
                    END;
                END ELSE
                  ExitValue += FORMAT(Char);

            STRPOS(StopChars, FORMAT(Char)) > 0 :

              IF Advanced THEN
                ExitValue += FORMAT(Char)
              ELSE
                Stop := TRUE;

            ELSE
              ExitValue += FORMAT(Char);

          END;

          FirstCharacter := FALSE;

        END ELSE
          Stop := TRUE;

      ExitValue := DELCHR(ExitValue, '<>');
      EXIT(TRUE);
    END;

    LOCAL PROCEDURE AnalyseCode@32(VAR WhereUsedIn@1000 : Record 11102060;VAR ParameterSection@1001 : Record 11102053;VAR VariableSection@1002 : Record 11102053;VAR CodeSection@1003 : Record 11102053;VAR Variable@1004 : Record 11102062;VAR Object@1005 : Record 2000000001;TableObjectNo@1006 : Integer;CurrentKeyNo@1007 : Integer);
    VAR
      PrevCodeSection@1008 : Record 11102053;
      ObjectLine@1009 : Record 11102058;
      ObjectLine2@1010 : Record 11102058;
      ObjectVariableLine@1011 : Record 11102058;
      WhereUsedIn2@1012 : Record 11102060;
      Object2@1013 : Record 2000000001;
      Fld@1014 : Record 2000000041;
      Mgt@1015 : Codeunit 11102035;
      AccoladeExpr@1016 : Text;
      CoupleString@1017 : Text;
      First@1018 : Text;
      KeyString@1019 : Text;
      Last@1020 : Text;
      NameOfIndent@1021 : ARRAY [100] OF Text;
      NextString@1022 : Text;
      Parent@1023 : Text;
      PreviousFirst@1024 : Text;
      PreviousLast@1025 : Text;
      String@1026 : Text;
      TmpLast@1027 : Text;
      CALLineNo@1028 : Integer;
      CurrentKeyNo2@1029 : Integer;
      Indent@1030 : Integer;
      ObjectNo@1031 : Integer;
      ParentEntryNo@1032 : Integer;
      Position@1033 : Integer;
      PrevPosition@1034 : Integer;
      SetCurrentKeyTableNo@1035 : Integer;
      Validated@1036 : Integer;
      Validation@1037 : Integer;
      Found@1038 : Boolean;
      MiniIndent@1039 : Boolean;
      StopLoop@1040 : Boolean;
    BEGIN
      ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
      ObjectLine.SETRANGE("Object Type", Object.Type);
      ObjectLine.SETRANGE("Object No.", Object.ID);
      CASE WhereUsedIn.Name OF
        'OnInsert' :
          ObjectLine.SETRANGE(Name, 'Insert');
        'OnModify' :
          ObjectLine.SETRANGE(Name, 'Modify');
        'OnDelete' :
          ObjectLine.SETRANGE(Name, 'Delete');
        'OnRename' :
          ObjectLine.SETRANGE(Name, 'Rename');
        ELSE
          ObjectLine.SETFILTER(Name, Mgt.CreateFilter(WhereUsedIn.Name, FALSE));
      END;
      IF ObjectLine.FINDFIRST THEN
        ;

      IF TableObjectNo <> 0 THEN
        IF ((WhereUsedIn."Object Type" = WhereUsedIn."Object Type"::Codeunit) AND (WhereUsedIn.Name = 'OnRun')) OR
           (WhereUsedIn."Object Type" = WhereUsedIn."Object Type"::Report)
        THEN
          AppendVariablesToBuffer(Variable, 0, FALSE, 'rec', 0, Object.Type::Table, TableObjectNo, 0, 0, 0, 0, '', '', FALSE);

      IF NOT ParameterSection.ISEMPTY THEN BEGIN
        ObjectLine."No. of Parameters" := AddVariablesFromParameters(ParameterSection, Variable, WhereUsedIn, ObjectLine."Entry No.");
        IF ObjectLine."No. of Parameters" >= 100 THEN BEGIN
          ObjectLine."No. of Parameters" -= 100;
          ObjectLine."No. of Return Values" := 1;
        END;
      END;

      IF VariableSection.COUNT > 0 THEN BEGIN
        WhereUsedIn2 := WhereUsedIn;
        UsedInEntryNo += 1;
        WhereUsedIn2."Entry No." := UsedInEntryNo;
        WhereUsedIn2.Type := WhereUsedIn2.Type::"Local Variable";
        WhereUsedIn2.INSERT;
        ObjectLine."No. of Variables" := AddVariablesFromSection(VariableSection, Variable, WhereUsedIn2, 0, ObjectLine."Entry No.");
      END;

      IF ObjectLine."Entry No." <> 0 THEN
        ObjectLine.MODIFY;

      Position := 1;
      Indent := 1;

      IF CodeSection.FINDSET THEN BEGIN
        CodeSection.Code := ' ' + LOWERCASE(DELCHR(CodeSection.Code, '<>')) + ' ';

        WHILE GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr) DO BEGIN

          IF CALLineNo = 0 THEN
            CALLineNo := CodeSection."Line No.";

          IF AccoladeExpr <> '' THEN
            AnalyseExpression(AccoladeExpr, WhereUsedIn, Variable, Object, CALLineNo, Indent, NameOfIndent);

          IF CoupleString = '::' THEN
            IF First IN ['codeunit', 'database', 'report', 'xmlport', 'page', 'query'] THEN BEGIN
              IF First = 'database' THEN
                Object2.SETRANGE(Type, Object2.Type::Table)
              ELSE
                Object2.SETFILTER(Type, First);
              Object2.SETFILTER(Name, Mgt.CreateFilter(Last, TRUE));
              IF Object2.FINDFIRST THEN BEGIN
                ObjectLine.RESET;
                ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type);
                ObjectLine.SETRANGE("Object Type", Object2.Type);
                ObjectLine.SETRANGE("Object No.", Object2.ID);
                ObjectLine.SETRANGE(Type, ObjectLine.Type::Object);
                IF ObjectLine.FINDFIRST THEN
                  AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);

                IF PreviousLast IN ['run', 'runmodal', 'saveashtml', 'saveasxml', 'saveaspdf', 'saveasexcel', 'saveasword', 'execute', 'print', 'saveas'] THEN
                  IF Object2.Type <> Object2.Type::Table THEN BEGIN
                    ObjectLine.SETRANGE(Type, ObjectLine.Type::Trigger);
                    ObjectLine.SETRANGE(Id, 1);
                    IF ObjectLine.FINDFIRST THEN
                      AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);
                  END;

              END;
            END ELSE BEGIN

              IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, '', First) THEN
                FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

            END

          ELSE BEGIN

            Validated := 0;
            CASE Last OF

              '.' :
                IF NextString = 'page' THEN
                  IF PreviousFirst = 'currpage' THEN BEGIN
                    GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);

                    IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, PreviousLast, Last) THEN
                      FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

                  END;

              ';' :
                BEGIN
                  MiniIndent := FALSE;
                  NameOfIndent[Indent + 1] := '';
                END;

              '(', ')', ':=', 'if', 'then', 'else', '0', '1', 'true', 'false', 'not', '::' :
                ;

              'with' :
                BEGIN
                  GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                  NameOfIndent[Indent + 1] := Last;

                  IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, '', Last) THEN
                    FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

                  GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                  IF (String = 'do') AND (NextString <> 'begin') THEN
                    MiniIndent := TRUE;

                END;

              'begin', 'case', 'repeat' :
                Indent += 1;

              'run', 'runmodal', 'saveashtml', 'saveasxml', 'saveaspdf', 'saveasexcel', 'saveasword', 'execute', 'print', 'saveas' :
                IF First IN ['codeunit', 'report', 'xmlport', 'page', 'query'] THEN BEGIN
                  IF NextString = '(' THEN BEGIN

                    PreviousLast := Last;

                    ObjectLine.RESET;
                    ObjectLine.SETFILTER("Object Type", First);
                    GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                    IF EVALUATE(ObjectNo, NextString) THEN BEGIN

                      ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type);
                      ObjectLine.SETRANGE("Object No.", ObjectNo);
                      ObjectLine.SETRANGE(Type, ObjectLine.Type::Object);
                      IF ObjectLine.FINDFIRST THEN
                        AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);
                      ObjectLine.SETRANGE(Type, ObjectLine.Type::Trigger);
                      ObjectLine.SETRANGE(Id, 1);
                      IF ObjectLine.FINDFIRST THEN
                        AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);

                    END;
                  END;
                END ELSE

                  IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, First, 'run') THEN
                    FlagVariables(Variable, WhereUsedIn, CALLineNo, 0)
                  ELSE
                    IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, '', First) THEN
                      FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

              'end', 'until' :
                BEGIN
                  NameOfIndent[Indent] := '';
                  Indent -= 1;
                  IF Indent < 1 THEN
                    Indent := 1;
                END;

              'validate', 'setfilter', 'getfilter', 'copyfilter', 'setrange', 'testfield', 'fielderror',
              'fieldcaption', 'fieldname', 'fieldno', 'clear', 'calcfields', 'evaluate', 'getrangemin', 'getrangemax' :
                BEGIN
                  IF Last = 'validate' THEN
                    Validated := 2;

                  IF Last = 'evaluate' THEN
                    Validated := 1;

                  IF (Last = 'calcfields') AND (CoupleString = '.') THEN BEGIN
                    MiniIndent := TRUE;
                    NameOfIndent[Indent + 1] := First;
                  END;

                  IF CoupleString = '.' THEN
                    Parent := First
                  ELSE
                    Parent := '';

                  IF GetActiveTable(Variable, Parent, NameOfIndent, Indent, MiniIndent) THEN
                    FlagVariables(Variable, WhereUsedIn, CALLineNo, Validated);

                  IF NextString = '(' THEN BEGIN
                    GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                    GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);

                    IF AccoladeExpr <> '' THEN
                      AnalyseExpression(AccoladeExpr, WhereUsedIn, Variable, Object, CALLineNo, Indent, NameOfIndent);

                    IF CoupleString = '.' THEN BEGIN
                      IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, First, Last) THEN
                        FlagVariables(Variable, WhereUsedIn, CALLineNo, Validated);
                    END ELSE
                      IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Parent, First) THEN BEGIN
                        FlagVariables(Variable, WhereUsedIn, CALLineNo, Validated);
                        IF Variable."Type Name" = 'FieldRef' THEN
                          IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, '', Last) THEN
                            FlagVariables(Variable, WhereUsedIn, CALLineNo, Validated);
                      END;

                  END;

                END;

              'calcsums' :
                BEGIN
                  SetCurrentKeyTableNo := 0;
                  CurrentKeyNo2 := 0;

                  IF CoupleString = '.' THEN
                    Parent := First
                  ELSE
                    Parent := '';

                  IF GetActiveTable(Variable, Parent, NameOfIndent, Indent, MiniIndent) THEN BEGIN
                    SetCurrentKeyTableNo := Variable."Object No.";
                    IF Variable.Name = 'rec' THEN
                      CurrentKeyNo2 := CurrentKeyNo
                    ELSE
                      CurrentKeyNo2 := Variable."Current Key";
                  END;

                  IF SetCurrentKeyTableNo <> 0 THEN BEGIN

                    ObjectLine.RESET;
                    ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
                    ObjectLine.SETRANGE("Object Type", ObjectLine."Object Type"::Table);
                    ObjectLine.SETRANGE("Object No.", SetCurrentKeyTableNo);
                    ObjectLine.SETRANGE(Type, ObjectLine.Type::"Sum Index Field");

                    IF CurrentKeyNo2 <> 0 THEN
                      ObjectLine.SETRANGE(Id, CurrentKeyNo2 * 100, CurrentKeyNo2 * 100 + 99);

                    ObjectLine2.RESET;
                    ObjectLine2.SETCURRENTKEY("Object Type", "Object No.", Type, Id);
                    ObjectLine2.SETRANGE("Object Type", ObjectLine."Object Type"::Table);
                    ObjectLine2.SETRANGE("Object No.", SetCurrentKeyTableNo);
                    ObjectLine2.SETRANGE(Type, ObjectLine.Type::Key);

                    GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                    GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                    StopLoop := FALSE;
                    WHILE NOT StopLoop DO
                      IF Last = ')' THEN
                        StopLoop := TRUE
                      ELSE BEGIN
                        ObjectLine.SETFILTER(Name, Mgt.CreateFilter(Last, TRUE));
                        IF ObjectLine.FINDSET THEN
                          REPEAT
                            AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);
                            ObjectLine2.SETRANGE(Id, ROUND(ObjectLine.Id / 100, 1, '<'));
                            ObjectLine2.FINDFIRST;
                            AddCrossTableRecord(ObjectLine2."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);
                          UNTIL ObjectLine.NEXT = 0;

                        StopLoop :=
                          NOT GetNextStatementInCode(
                            CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                      END;

                  END;
                END;

              'setcurrentkey' :
                BEGIN

                  SetCurrentKeyTableNo := 0;
                  Found := FALSE;

                  IF CoupleString = '.' THEN
                    Parent := First
                  ELSE
                    Parent := '';

                  IF GetActiveTable(Variable, Parent, NameOfIndent, Indent, MiniIndent) THEN BEGIN
                    FlagVariableUsedIn(Variable);
                    SetCurrentKeyTableNo := Variable."Object No.";
                    Found := TRUE;
                  END;

                  IF SetCurrentKeyTableNo <> 0 THEN BEGIN
                    Fld.SETRANGE(TableNo, SetCurrentKeyTableNo);
                    KeyString := '';
                    GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                    GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                    StopLoop := FALSE;
                    WHILE NOT StopLoop DO
                      IF Last = ')' THEN
                        StopLoop := TRUE
                      ELSE BEGIN
                        Fld.SETFILTER(FieldName, Mgt.CreateFieldFilter(Last, TRUE));
                        IF Fld.FINDFIRST THEN BEGIN
                          KeyString += ',' + FORMAT(Fld."No.");
                          AddObjectUsedInRecord(
                            WhereUsedIn, Object.Type::Table, SetCurrentKeyTableNo,
                            ObjectLine.Type::Field, Fld."No.", '', CALLineNo, Variable."Temporary Record");
                        END;
                        StopLoop :=
                          NOT GetNextStatementInCode(
                            CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                      END;

                    IF KeyString <> '' THEN BEGIN
                      KeyString := COPYSTR(KeyString, 2);
                      IF GetUsedKey(ObjectLine, SetCurrentKeyTableNo, KeyString) THEN BEGIN
                        AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, Variable."Temporary Record");
                        IF Found THEN BEGIN
                          Variable."Current Key" := ObjectLine.Id;
                          Variable.MODIFY;
                        END ELSE
                          CurrentKeyNo := ObjectLine.Id;
                      END;
                    END;
                  END;
                END;

              'find', 'findfirst', 'findlast', 'findset', 'isempty', 'next' :
                BEGIN
                  IF CoupleString = '.' THEN
                    Parent := First
                  ELSE
                    Parent := '';

                  IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Parent, 'find') THEN
                    FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

                END;

              'init', 'insert', 'delete', 'deleteall', 'modify' :
                BEGIN

                  IF Last = 'deleteall' THEN
                    Last := 'delete';

                  IF CoupleString = '.' THEN
                    Parent := First
                  ELSE
                    Parent := '';

                  IF NextString = '(' THEN BEGIN
                    PrevPosition := Position;
                    PrevCodeSection := CodeSection;
                    GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, TmpLast, AccoladeExpr);
                    GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, TmpLast, AccoladeExpr);
                    IF String = 'true' THEN
                      Validated := 2
                    ELSE BEGIN
                      Position := PrevPosition;
                      CodeSection := PrevCodeSection;
                    END;
                  END;

                  IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Parent, Last) THEN
                    FlagVariables(Variable, WhereUsedIn, CALLineNo, Validated);

                END;

              'modifyall' :
                BEGIN
                  IF CoupleString = '.' THEN
                    Parent := First
                  ELSE
                    Parent := '';

                  GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                  PrevPosition := Position;
                  PrevCodeSection := CodeSection;
                  GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);

                  IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Parent, Last) THEN
                    FlagVariables(Variable, WhereUsedIn, CALLineNo, 1);

                  GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);

                  IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Parent, 'modify') THEN
                    IF Last = 'true' THEN
                      FlagVariables(Variable, WhereUsedIn, CALLineNo, 2)
                    ELSE BEGIN
                      Position := PrevPosition;
                      CodeSection := PrevCodeSection;
                      FlagVariables(Variable, WhereUsedIn, CALLineNo, 1);
                    END;

                END;

              'rename' :
                BEGIN

                  IF CoupleString = '.' THEN
                    Parent := First
                  ELSE
                    Parent := '';

                  IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Parent, Last) THEN
                    FlagVariables(Variable, WhereUsedIn, CALLineNo, 2);

                END;

              'transferfields' :
                BEGIN

                  IF CoupleString = '.' THEN
                    Parent := First
                  ELSE
                    Parent := '';

                  IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Parent, Last) THEN
                    FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

                  GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                  GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);

                  IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Last, 'transferfields') THEN
                    FlagVariables(Variable, WhereUsedIn, CALLineNo, 0);

                END;

              'exit' :
                BEGIN
                  Position := Position;
                  Position := Position;
                  Position := Position;
                  GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
                  IF AccoladeExpr <> '' THEN
                    AnalyseExpression(AccoladeExpr, WhereUsedIn, Variable, Object, CALLineNo, Indent, NameOfIndent);
                  IF NOT (NextString IN ['0', '', 'false']) THEN
                    FlagReturnValue(Variable, WhereUsedIn, CALLineNo);
                END;

              ELSE BEGIN

                Validation := 0;

                IF NextString IN [':=', '+=', '-=', '/=', '*='] THEN
                  Validation := 1
                ELSE
                  Validation := 0;

                IF CoupleString = '.' THEN
                  Parent := First
                ELSE
                  Parent := '';

                IF FindVariable(WhereUsedIn."Object Type", Variable, NameOfIndent, Indent, Parent, Last) THEN
                  FlagVariables(Variable, WhereUsedIn, CALLineNo, Validation);

              END;

            END;
          END;

          IF NextString = '::' THEN BEGIN
            GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
            GetNextStatementInCode(CodeSection, Position, String, NextString, First, CoupleString, Last, AccoladeExpr);
          END;

          IF First = 'currpage' THEN BEGIN
            PreviousFirst := First;
            PreviousLast := Last;
          END;

          CALLineNo := CodeSection."Line No.";

        END;
      END;

      IF NOT SaveVariableUsage THEN BEGIN

        Variable.RESET;
        Variable.SETCURRENTKEY(Scope, Used);
        Variable.SETFILTER(Scope, '%1|%2', Variable.Scope::"Local", Variable.Scope::Parameter);
        Variable.SETRANGE(Used, TRUE);
        Variable.SETFILTER("Parent Entry No.", '>0');

        WHILE Variable.FINDLAST DO BEGIN
          ParentEntryNo := Variable."Parent Entry No.";
          Variable.DELETE;

          Variable.SETRANGE("Parent Entry No.");
          Variable.SETRANGE(Used);
          IF Variable.GET(Variable."Parent Entry No.") THEN
            Variable.DELETE;
          Variable.SETCURRENTKEY("Parent Entry No.");
          Variable.SETRANGE("Parent Entry No.", ParentEntryNo);
          Variable.DELETEALL;
          Variable.SETCURRENTKEY(Scope, Used);
          Variable.SETRANGE(Used, TRUE);
          Variable.SETFILTER("Parent Entry No.", '>0');
        END;

        Variable.RESET;
        Variable.SETCURRENTKEY(Scope, Used);
        Variable.SETFILTER(Scope, '%1|%2|%3', Variable.Scope::"Local", Variable.Scope::Parameter, Variable.Scope::"Return Value");
        Variable.SETRANGE("Parent Entry No.", 0);
        Variable.SETFILTER("C/AL Line No.", '>0');
        IF Variable.FINDSET THEN BEGIN
          ObjectVariableLine.RESET;
          REPEAT
            IF NOT Variable.Used THEN BEGIN
              ObjectVariableLine."Entry No." := 0;
              ObjectVariableLine."Object Type" := Object.Type;
              ObjectVariableLine."Object No." := Object.ID;
              ObjectVariableLine.Enabled := TRUE;

              CASE Variable.Scope OF
                Variable.Scope::"Local" :
                  ObjectVariableLine.Type := ObjectVariableLine.Type::"Local Variable";
                Variable.Scope::Global :
                  ObjectVariableLine.Type := ObjectVariableLine.Type::"Global Variable";
                Variable.Scope::Parameter :
                  ObjectVariableLine.Type := ObjectVariableLine.Type::Parameter;
                Variable.Scope::"Return Value" :
                  ObjectVariableLine.Type := ObjectVariableLine.Type::"Return Value";
              END;

              ObjectVariableLine.Id := Variable.Id;
              ObjectVariableLine.Name := Variable."Case Name";
              ObjectVariableLine."Parent No." := Variable."Object Line Entry No.";
              ObjectVariableLine."C/AL Line No." := Variable."C/AL Line No.";
              ObjectVariableLine."Type Name" := Variable."Type Name";
              ObjectVariableLine."Sub Type" := Variable."Sub Type";
              ObjectVariableLine.Used := Variable.Used;
              ObjectVariableLine.INSERT;
            END;
          UNTIL Variable.NEXT = 0;
        END;
      END;

      Variable.RESET;
      Variable.SETCURRENTKEY(Scope, Used);
      Variable.SETFILTER(Scope, '%1|%2|%3', Variable.Scope::"Local", Variable.Scope::Parameter, Variable.Scope::"Return Value");
      Variable.DELETEALL;

      Variable.SETRANGE(Scope);
    END;

    LOCAL PROCEDURE FindVariable@33(VAR ObjectType2@1000 : ' ,Table,,Report,,Codeunit,XMLport,MenuSuite,Page';VAR Variable@1001 : Record 11102062;VAR NameOfIndent@1002 : ARRAY [100] OF Text;VAR CurrentIndent@1003 : Integer;ParentName@1004 : Text;Name@1005 : Text) : Boolean;
    VAR
      ParentFilter@1006 : Text;
      i@1007 : Integer;
    BEGIN
      IF STRLEN(Name) > 100 THEN BEGIN
        IF STRLEN(Name) > 250 THEN
          EXIT(FALSE);
        Variable.RESET;
        Variable.SETCURRENTKEY(Name);
        Variable.SETRANGE(Name, Name);
        EXIT(Variable.FINDSET);
      END;

      IF ParentName = '' THEN BEGIN

        CASE ObjectType2 OF
          ObjectType2::Page :
            ParentFilter := '''''|rec|currpage';
          ELSE
            ParentFilter := '''''|rec';
        END;

        FOR i := 0 TO CurrentIndent DO
          IF NameOfIndent[i + 1] <> '' THEN
            ParentFilter += '|''' + NameOfIndent[i + 1] + '''';

      END ELSE
        IF ParentName = 'xrec' THEN
          ParentFilter := 'rec'
        ELSE
          ParentFilter := '''' + AddSingleQuotes(ParentName) + '''';

      Variable.SETCURRENTKEY("Parent Name", Name);
      Variable.SETFILTER("Parent Name", ParentFilter);
      Variable.SETRANGE(Name, Name);

      IF Variable.COUNT = 0 THEN BEGIN
        Name := ParentName;
        ParentName := '';
        ParentFilter := '';
        Variable.SETFILTER("Parent Name", ParentFilter);
        Variable.SETRANGE(Name, Name);
      END;

      CASE Variable.COUNT OF
        0 :
          EXIT(FALSE);
        1 :
          EXIT(Variable.FINDSET);

        ELSE BEGIN

          Variable.FILTERGROUP(2);
          Variable.SETRANGE("Parent Name", '');
          Variable.SETRANGE("Parent Name");
          Variable.FILTERGROUP(0);

          IF ParentName = '' THEN BEGIN

            i := CurrentIndent;
            WHILE i >= 1 DO BEGIN
              IF NameOfIndent[i + 1] <> '' THEN BEGIN

                Variable.SETRANGE("Parent Name", NameOfIndent[i + 1]);
                IF Variable.FINDFIRST THEN
                  EXIT(TRUE);

              END;
              i -= 1;
            END;

            Variable.SETFILTER(Scope, '%1|%2', Variable.Scope::"Local", Variable.Scope::Parameter);
            Variable.SETRANGE("Parent Name", '');
            IF Variable.FINDFIRST THEN
              EXIT(TRUE);
            Variable.SETRANGE(Scope);

            IF NameOfIndent[1] <> '' THEN BEGIN
              Variable.SETRANGE("Parent Name", NameOfIndent[1]);
              IF Variable.FINDFIRST THEN
                EXIT(TRUE);
            END;

            Variable.SETFILTER("Parent Name", 'rec');
            IF Variable.FINDFIRST THEN
              EXIT(TRUE);

            Variable.SETRANGE(Scope, Variable.Scope::Global);
            Variable.SETRANGE("Parent Name", '');
            IF Variable.FINDFIRST THEN
              EXIT(TRUE);
            Variable.SETRANGE(Scope);

            Variable.SETFILTER("Parent Name", ParentFilter);
            Variable.FINDSET;
            EXIT(TRUE);

          END ELSE BEGIN

            Variable.SETFILTER(Scope, '%1|%2', Variable.Scope::"Local", Variable.Scope::Parameter);
            IF Variable.FINDFIRST THEN
              EXIT(TRUE);

            Variable.SETRANGE(Scope);
            EXIT(Variable.FINDSET);
          END;
        END;
      END;
    END;

    LOCAL PROCEDURE FlagVariables@34(VAR Variable@1000 : Record 11102062;VAR WhereUsedIn@1001 : Record 11102060;CALLineNo@1002 : Integer;Validation@1003 : Integer);
    BEGIN
      REPEAT
        AddVariableUsedInRecord(Variable, WhereUsedIn, CALLineNo, Validation);

        IF SaveVariableUsage THEN
          IF Variable."Variable Entry No." <> 0 THEN
            AddCrossTableRecord(
              Variable."Variable Entry No.", WhereUsedIn."Entry No.", CALLineNo, Validation, Variable."Temporary Record");

      UNTIL Variable.NEXT = 0;

      Variable.SETRANGE(Scope);
    END;

    LOCAL PROCEDURE FlagReturnValue@35(VAR Variable@1000 : Record 11102062;VAR WhereUsedIn@1001 : Record 11102060;CALLineNo@1002 : Integer);
    BEGIN
      Variable.SETCURRENTKEY("Parent Name", Name);
      Variable.SETRANGE("Parent Name", '');
      Variable.SETRANGE(Name);
      Variable.SETRANGE(Scope, Variable.Scope::"Return Value");
      IF Variable.FINDFIRST THEN BEGIN
        AddVariableUsedInRecord(Variable, WhereUsedIn, CALLineNo, 0);

        IF SaveVariableUsage THEN
          IF Variable."Variable Entry No." <> 0 THEN
            AddCrossTableRecord(Variable."Variable Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, FALSE);

      END;
      Variable.SETRANGE(Scope);
    END;

    LOCAL PROCEDURE GetActiveTable@36(VAR Variable@1000 : Record 11102062;VAR ParentName@1001 : Text;VAR NameOfIndent@1002 : ARRAY [100] OF Text;VAR CurrentIndent@1003 : Integer;MiniIndent@1004 : Boolean) ExitValue : Boolean;
    VAR
      ActiveName@1005 : Text;
      i@1006 : Integer;
    BEGIN
      IF ParentName <> '' THEN
        ActiveName := ParentName
      ELSE
        IF MiniIndent THEN
          ActiveName := NameOfIndent[CurrentIndent + 1]
        ELSE BEGIN
          i := CurrentIndent;
          WHILE (i >= 0) AND (ActiveName = '') DO BEGIN
            IF NameOfIndent[i + 1] <> '' THEN
              ActiveName := NameOfIndent[i + 1];
            i -= 1;
          END;
        END;

      IF ActiveName = '' THEN
        ActiveName := 'rec';

      Variable.SETCURRENTKEY("Parent Name", Name);
      Variable.SETRANGE("Object Type", Variable."Object Type"::Table);
      Variable.SETRANGE("Parent Name", '');
      Variable.SETRANGE(Name, ActiveName);

      CASE Variable.COUNT OF
        0 :
          ExitValue := FALSE;
        1 :
          BEGIN
            ExitValue := TRUE;
            Variable.FINDFIRST;
          END;

        ELSE BEGIN
          ExitValue := TRUE;
          Variable.SETFILTER(Scope, '%1|%2', Variable.Scope::"Local", Variable.Scope::Parameter);
          IF NOT Variable.FINDFIRST THEN BEGIN
            Variable.SETRANGE(Scope);
            Variable.FINDFIRST;
          END;
          Variable.SETRANGE(Scope);

        END;
      END;

      Variable.SETRANGE("Object Type");
    END;

    LOCAL PROCEDURE AddVariablesFromSection@37(VAR CALHistoryLine@1000 : Record 11102053;VAR VariableBuffer@1001 : TEMPORARY Record 11102062;VAR WhereUsedIn@1002 : Record 11102060;Scope@1003 : 'Local,Parameter,Return Value,Global';ObjectLineEntryNo@1004 : Integer) ExitValue : Integer;
    BEGIN
      CALHistoryLine.SETRANGE("Sub Line No.", 1);
      IF CALHistoryLine.FINDSET THEN
        REPEAT
          IF AnalyseVariableLine(CALHistoryLine.Code, VariableBuffer, WhereUsedIn, Scope, ObjectLineEntryNo, CALHistoryLine."Line No.")
          THEN
            ExitValue += 1;
        UNTIL CALHistoryLine.NEXT = 0;
    END;

    LOCAL PROCEDURE AddVariablesFromParameters@38(VAR CALHistoryLine@1000 : Record 11102053;VAR VariableBuffer@1001 : TEMPORARY Record 11102062;VAR WhereUsedIn@1002 : Record 11102060;ObjectLineEntryNo@1003 : Integer) ExitValue : Integer;
    VAR
      WhereUsedIn2@1004 : Record 11102060;
      CodeLine@1005 : Text;
      ParameterCode@1006 : Text;
      ReturnValueCode@1007 : Text;
      Char@1008 : Char;
      i@1009 : Integer;
      NoOfParameters@1010 : Integer;
      ParameterStart@1011 : ARRAY [100] OF Integer;
      Position@1012 : Integer;
      SplitPos@1013 : Integer;
      OptionStringOpen@1014 : Boolean;
      ParametersStart@1015 : Boolean;
      VariableOpen@1016 : Boolean;
    BEGIN
      IF CALHistoryLine.FINDSET THEN
        REPEAT
          CodeLine += CALHistoryLine.Code;
        UNTIL CALHistoryLine.NEXT = 0;

      Position := 1;

      WHILE Position < STRLEN(CodeLine) DO BEGIN
        Char := CodeLine[Position];

        CASE TRUE OF

          VariableOpen :
            IF Char = '"' THEN
              VariableOpen := FALSE;

          OptionStringOpen :
            IF Char = '''' THEN
              OptionStringOpen := FALSE;

          NOT ParametersStart AND (Char = '(') :
            BEGIN
              ParametersStart := TRUE;
              NoOfParameters += 1;
              ParameterStart[NoOfParameters] := Position + 1;
            END;

          Char = '"' :
            VariableOpen := TRUE;

          Char = '''' :
            OptionStringOpen := TRUE;

          Char = ';' :
            BEGIN
              NoOfParameters += 1;
              ParameterStart[NoOfParameters] := Position + 1;
            END;

          Char = ')' :
            BEGIN
              SplitPos := STRPOS(COPYSTR(CodeLine, Position + 1), ':');
              IF SplitPos > 0 THEN BEGIN
                ReturnValueCode := COPYSTR(CodeLine, Position + 2);
                ReturnValueCode := DELCHR(ReturnValueCode, '>', ';');
                IF SplitPos = 2 THEN
                  ReturnValueCode := 'ReturnValue ' + ReturnValueCode;
              END;

              CodeLine := DELSTR(CodeLine, Position + 1);
            END;

        END;
        Position += 1;

      END;

      IF (NoOfParameters > 0) OR (ReturnValueCode <> '') THEN BEGIN
        WhereUsedIn2 := WhereUsedIn;
        UsedInEntryNo += 1;
        WhereUsedIn2."Entry No." := UsedInEntryNo;
        WhereUsedIn2.Type := WhereUsedIn2.Type::Parameter;
        WhereUsedIn2.INSERT;

        FOR i := 1 TO NoOfParameters DO BEGIN
          IF i = NoOfParameters THEN
            ParameterCode := COPYSTR(CodeLine, ParameterStart[i])
          ELSE
            ParameterCode := COPYSTR(CodeLine, ParameterStart[i], ParameterStart[i + 1] - ParameterStart[i]);

          IF DELSTR(ParameterCode, 5) = 'VAR ' THEN
            ParameterCode := COPYSTR(ParameterCode, 5);

          IF ParameterCode <> ')' THEN
            IF AnalyseVariableLine(ParameterCode, VariableBuffer, WhereUsedIn2, 1, ObjectLineEntryNo, CALHistoryLine."Line No.") THEN
              ExitValue += 1;

        END;

        IF ReturnValueCode <> '' THEN
          IF AnalyseVariableLine(ReturnValueCode, VariableBuffer, WhereUsedIn2, 2, ObjectLineEntryNo, CALHistoryLine."Line No.") THEN
            ExitValue += 100;

      END;
    END;

    LOCAL PROCEDURE AnalyseVariableLine@39(VAR CodeLine@1000 : Text;VAR VariableBuffer@1001 : TEMPORARY Record 11102062;VAR WhereUsedIn@1002 : Record 11102060;Scope@1003 : 'Local,Parameter,Return Value,Global';ObjectLineEntryNo@1004 : Integer;CALLineNo@1005 : Integer) : Boolean;
    VAR
      ObjectLine@1006 : Record 11102058;
      Object@1007 : Record 2000000001;
      Mgt@1008 : Codeunit 11102035;
      CodeLine2@1009 : Text;
      IdString@1010 : Text;
      Name@1011 : Text;
      NameId@1012 : Text;
      ObjectNoString@1013 : Text;
      ObjectTypeString@1014 : Text;
      SubType@1015 : Text[1024];
      Type@1016 : Text;
      Id@1017 : Integer;
      ObjectNo@1018 : Integer;
      SplitPos@1019 : Integer;
      SplitPos2@1020 : Integer;
      Advanced@1021 : Boolean;
      IsTemporary2@1022 : Boolean;
    BEGIN
      CodeLine := DELCHR(CodeLine, '<>');

      IF (CodeLine[1] IN ['''', ';']) OR (CodeLine = '') THEN
        EXIT;

      Advanced := CodeLine[1] = '"';
      IF Advanced THEN BEGIN
        SplitPos := STRPOS(CodeLine, ' : ');
        IF STRPOS(CodeLine, '@') > SplitPos THEN BEGIN
          CodeLine2 := COPYSTR(CodeLine, STRPOS(CodeLine, '@'));
          SplitPos := STRPOS(CodeLine, '@') + STRPOS(CodeLine2, ' : ');
        END;
      END ELSE
        SplitPos := STRPOS(CodeLine, ' : ');

      IF SplitPos = 0 THEN
        EXIT;

      NameId := DELSTR(CodeLine, SplitPos);
      Type := COPYSTR(CodeLine, SplitPos + 3);

      IF DELSTR(Type, 8) = 'ARRAY [' THEN BEGIN
        SplitPos := STRPOS(Type, ' OF ');
        IF SplitPos > 0 THEN
          Type := COPYSTR(Type, STRPOS(Type, ' OF ') + 4);
      END;

      SplitPos := STRPOS(Type, ' ');
      IF SplitPos > 0 THEN
        ObjectTypeString := DELSTR(Type, SplitPos);

      IF ObjectTypeString = 'TEMPORARY' THEN BEGIN
        IsTemporary2 := TRUE;
        Type := COPYSTR(Type, SplitPos + 1);
        ObjectTypeString := '';
        SplitPos := STRPOS(Type, ' ');
        IF SplitPos > 0 THEN
          ObjectTypeString := DELSTR(Type, SplitPos);
      END;

      IF ObjectTypeString <> '' THEN BEGIN
        IF ObjectTypeString = 'Record' THEN
          Object.Type := Object.Type::Table
        ELSE
          IF EVALUATE(Object.Type, ObjectTypeString) THEN
            ;
        IF Object.Type <> Object.Type::TableData THEN BEGIN
          ObjectNoString := COPYSTR(Type, STRLEN(ObjectTypeString) + 2);
          ObjectNoString := DELSTR(ObjectNoString, STRLEN(ObjectNoString));
          SplitPos := STRPOS(ObjectNoString, ' ');
          IF SplitPos > 0 THEN
            ObjectNoString := COPYSTR(ObjectNoString, 1, SplitPos);
          IF EVALUATE(ObjectNo, ObjectNoString) THEN
            SubType := FORMAT(ObjectNo);
        END;
      END;

      IF Advanced THEN BEGIN
        SplitPos2 := STRLEN(NameId) - 1;
        IF STRPOS(NameId, '@') = 0 THEN
          SplitPos2 := 0
        ELSE
          WHILE NameId[SplitPos2] <> '@' DO
            SplitPos2 -= 1;
      END ELSE
        SplitPos2 := STRPOS(NameId, '@');

      IF SplitPos2 > 0 THEN BEGIN
        Name := DELSTR(NameId, SplitPos2);
        IdString := COPYSTR(NameId, SplitPos2 + 1);
        EVALUATE(Id, IdString);
      END ELSE BEGIN
        Id := 1;
        Name := NameId;
      END;

      IF Advanced THEN
        Name := DELCHR(Name, '<>', '"');

      SplitPos := STRPOS(Type, ' ');
      IF SplitPos > 0 THEN
        Type := DELSTR(Type, SplitPos);
      Type := DELCHR(Type, '=', '[];)');
      IF Type[1] = '''' THEN
        Type := 'Option';

      IF SaveVariableUsage THEN BEGIN
        ObjectLine.FINDLAST;

        ObjectLine."Object Type" := WhereUsedIn."Object Type";
        ObjectLine."Object No." := WhereUsedIn."Object No.";
        ObjectLine."Entry No." += 1;
        ObjectLine.Enabled := TRUE;

        CASE Scope OF
          Scope::"Local" :
            ObjectLine.Type := ObjectLine.Type::"Local Variable";
          Scope::Parameter :
            ObjectLine.Type := ObjectLine.Type::Parameter;
          Scope::"Return Value" :
            ObjectLine.Type := ObjectLine.Type::"Return Value";
          Scope::Global :
            ObjectLine.Type := ObjectLine.Type::"Global Variable";
        END;

        AddObjectLineRecord(ObjectLine, TRUE, ObjectLine.Type, Id, Name, CALLineNo, ObjectLineEntryNo, Type, SubType);

      END;

      IF AppendVariablesToBuffer(
           VariableBuffer, Scope, FALSE, Name, Id,
           Object.Type, ObjectNo, 0, CALLineNo, ObjectLineEntryNo, ObjectLine."Entry No.", Type, SubType, IsTemporary2)
      THEN
        IF Mgt.IsReservedKeyword(Name) THEN
          IF SaveVariableUsage THEN
            AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, IsTemporary2)
          ELSE BEGIN
            VariableBuffer.RESET;
            VariableBuffer.FIND('=');
            AddVariableUsedInRecord(VariableBuffer, WhereUsedIn, CALLineNo, 0);
            AddCrossTableRecord(VariableBuffer."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, IsTemporary2);
          END;

      IF ObjectNo > 0 THEN
        AddObjectUsedInRecord(WhereUsedIn, Object.Type, ObjectNo, ObjectLine.Type::Object, 0, '', CALLineNo, IsTemporary2);

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE GetNextStatementInCode@40(VAR CALHistoryLine@1000 : Record 11102053;VAR Position@1001 : Integer;VAR Statement@1002 : Text;VAR NextStatement@1003 : Text;VAR First@1004 : Text;VAR CoupleString@1005 : Text;VAR Last@1006 : Text;VAR AccoladeExpr@1007 : Text) ExitValue : Boolean;
    VAR
      NextExp@1008 : Text;
      Stat1@1009 : Text;
      Stat2@1010 : Text;
      Stat3@1011 : Text;
    BEGIN
      AccoladeExpr := '';

      GetNextStatementInCodeSub(CALHistoryLine, Position, NextExp, AccoladeExpr);

      IF NextStatement = '' THEN BEGIN
        IF NextExp = '' THEN
          EXIT(FALSE);
        Statement := NextExp;
        GetNextStatementInCodeSub(CALHistoryLine, Position, NextStatement, AccoladeExpr);
      END ELSE BEGIN
        Statement := NextStatement;
        NextStatement := NextExp;
      END;

      IF NextStatement IN ['.', '::'] THEN BEGIN
        Stat1 := Statement;
        Stat2 := NextStatement;
        GetNextStatementInCodeSub(CALHistoryLine, Position, Statement, AccoladeExpr);
        Stat3 := Statement;

        Statement := Stat1 + Stat2 + Stat3;

        First := Stat1;
        CoupleString := Stat2;
        Last := Stat3;

        GetNextStatementInCodeSub(CALHistoryLine, Position, NextStatement, AccoladeExpr);

      END ELSE BEGIN
        First := Statement;
        CoupleString := '';
        Last := Statement;
      END;

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE GetNextStatementInCodeSub@41(VAR CALHistoryLine@1000 : Record 11102053;VAR Position@1001 : Integer;VAR Statement@1002 : Text;VAR AccoladeExpr@1003 : Text);
    VAR
      Mgt@1004 : Codeunit 11102035;
      Char@1005 : Char;
      AccoladeOpen@1006 : Integer;
      RemarkOpen@1007 : Integer;
      AddChar@1008 : Boolean;
      AddingStarted@1009 : Boolean;
      StopLoop@1010 : Boolean;
      SubTextOpen@1011 : Boolean;
      SubVariableOpen@1012 : Boolean;
      TextOpen@1013 : Boolean;
      VariableOpen@1014 : Boolean;
    BEGIN
      Statement := '';

      WHILE NOT StopLoop DO

        IF NextCharInCode(CALHistoryLine, Position, Char) THEN BEGIN
          AddChar := FALSE;

          CASE TRUE OF

            RemarkOpen > 0 :
              BEGIN
                IF Char = '{' THEN
                  RemarkOpen += 1;
                IF Char = '}' THEN
                  RemarkOpen -= 1;
              END;

            VariableOpen :
              BEGIN
                IF Char = '"' THEN
                  VariableOpen := FALSE;
                AddChar := TRUE;
              END;

            TextOpen :
              IF Char = '''' THEN
                TextOpen := FALSE;

            AccoladeOpen > 0 :
              BEGIN

                CASE TRUE OF

                  SubVariableOpen :
                    IF Char = '"' THEN
                      SubVariableOpen := FALSE;

                  SubTextOpen :
                    IF Char = '''' THEN
                      SubTextOpen := FALSE;

                  Char = '''' :
                    SubTextOpen := TRUE;

                  Char = '"' :
                    SubVariableOpen := TRUE;
                END;

                IF NOT SubVariableOpen AND NOT SubTextOpen THEN BEGIN
                  IF Char = '[' THEN
                    AccoladeOpen += 1;
                  IF Char = ']' THEN
                    AccoladeOpen -= 1;
                END;

                IF AccoladeOpen > 0 THEN
                  AccoladeExpr += FORMAT(Char);

              END;

            Char = '''' :
              TextOpen := TRUE;

            Char = '"' :
              BEGIN
                VariableOpen := TRUE;
                AddChar := TRUE;
              END;

            Char = '[' :
              AccoladeOpen += 1;

            Char = '{' :
              RemarkOpen += 1;

            Char IN [':', '+', '-', '/', '*'] :

              IF (Char = '/') AND (CALHistoryLine.Code[Position] = '/') THEN BEGIN

                CALHistoryLine.FILTERGROUP(2);
                CALHistoryLine.SETRANGE("Line No.", CALHistoryLine."Line No.");
                CALHistoryLine.FINDLAST;
                CALHistoryLine.SETRANGE("Line No.");
                CALHistoryLine.FILTERGROUP(0);

                Position := STRLEN(CALHistoryLine.Code) + 1;
                AddChar := FALSE;

              END ELSE

                CASE CALHistoryLine.Code[Position] OF

                  ':', '=' :
                    IF AddingStarted THEN BEGIN
                      Position -= 1;
                      StopLoop := TRUE;
                    END ELSE BEGIN
                      Statement := ':' + FORMAT(CALHistoryLine.Code[Position]);
                      Position += 1;
                      StopLoop := TRUE;
                    END;

                  ELSE
                    IF AddingStarted THEN
                      StopLoop := TRUE;
                END;

            Char IN [';', '.', '(', ')'] :
              IF AddingStarted THEN BEGIN
                Position -= 1;
                StopLoop := TRUE;
              END ELSE BEGIN
                Statement := FORMAT(Char);
                StopLoop := TRUE;
              END;

            NOT Mgt.SpecialCharacter(Char) :
              AddChar := TRUE;

            ELSE
              IF AddingStarted THEN
                StopLoop := TRUE;

          END;

          IF AddChar THEN BEGIN
            Statement += FORMAT(Char);
            AddingStarted := TRUE;
          END;

        END ELSE
          StopLoop := TRUE;
    END;

    LOCAL PROCEDURE NextCharInCode@42(VAR CALHistoryLine@1000 : Record 11102053;VAR Position@1001 : Integer;VAR Char@1002 : Char) : Boolean;
    VAR
      Length@1003 : Integer;
    BEGIN
      IF Position <= STRLEN(CALHistoryLine.Code) THEN BEGIN
        Char := CALHistoryLine.Code[Position];
        Position += 1;
        EXIT(TRUE);
      END ELSE
        IF CALHistoryLine.NEXT = 0 THEN
          EXIT(FALSE)
        ELSE BEGIN
          Length := STRLEN(CALHistoryLine.Code);
          IF CALHistoryLine."Sub Line No." = 1 THEN
            CALHistoryLine.Code := ' ' + LOWERCASE(DELCHR(CALHistoryLine.Code, '<'))
          ELSE
            IF CALHistoryLine.Code[1] = ' ' THEN
              CALHistoryLine.Code := ' ' + LOWERCASE(DELCHR(CALHistoryLine.Code, '<'))
            ELSE
              CALHistoryLine.Code := LOWERCASE(DELCHR(CALHistoryLine.Code, '<'));

          IF Length < 244 THEN
            CALHistoryLine.Code += ' ';

          Char := CALHistoryLine.Code[1];
          Position := 2;
          EXIT(TRUE);
        END;
    END;

    LOCAL PROCEDURE AddQuotesForFilter@44(Name@1000 : Text) : Text;
    VAR
      Mgt@1001 : Codeunit 11102035;
      i@1002 : Integer;
      Quotes@1003 : Boolean;
    BEGIN
      Name := LOWERCASE(Name);
      WHILE (i < STRLEN(Name)) AND NOT Quotes DO BEGIN
        i += 1;
        Quotes := Mgt.SpecialCharacter(Name[i]);
      END;

      IF Quotes THEN
        Name := AddSingleQuotes(Name);

      IF (Name[1] >= '0') AND (Name[1] <= '9') THEN
        Quotes := TRUE;

      IF NOT Quotes THEN
        IF Name IN ['array', 'event', 'function'] THEN
          Quotes := TRUE;
      IF Quotes THEN
        EXIT('"' + Name + '"')
      ELSE
        EXIT(Name);
    END;

    LOCAL PROCEDURE AddSingleQuotes@45(Name@1000 : Text) : Text;
    VAR
      i@1001 : Integer;
    BEGIN
      FOR i := 1 TO STRLEN(Name) DO
        IF Name[i] = '''' THEN BEGIN
          Name := INSSTR(Name, '''', i);
          i += 1;
        END;

      EXIT(Name);
    END;

    LOCAL PROCEDURE GetPropertyName@46(VAR CALHistoryLine@1000 : Record 11102053;VAR Name@1001 : Text);
    VAR
      Position@1002 : Integer;
    BEGIN
      Name := '';

      Position := STRPOS(CALHistoryLine.Code, '=');
      IF Position <> 0 THEN BEGIN
        Name := DELSTR(CALHistoryLine.Code, Position);
        Name := DELCHR(Name, '<>');
      END;
    END;

    LOCAL PROCEDURE GetPropertyValue@47(VAR CALHistoryLine@1000 : Record 11102053;VAR Value@1001 : Text);
    VAR
      Char@1002 : Char;
      Position@1003 : Integer;
      AccoladeOpen@1004 : Boolean;
      StopLoop@1005 : Boolean;
    BEGIN
      Value := '';

      Position := STRPOS(CALHistoryLine.Code, '=');
      CALHistoryLine.SETRANGE("Sub Line No.");

      IF Position > 0 THEN BEGIN
        AccoladeOpen := CALHistoryLine.Code[Position + 1] = '[';
        IF AccoladeOpen THEN
          Position += 2
        ELSE
          Position += 1;

        WHILE NOT StopLoop DO

          IF NextCharInCode(CALHistoryLine, Position, Char) THEN

            CASE TRUE OF

              AccoladeOpen :
                IF Char = ']' THEN
                  IF CALHistoryLine.Code[Position] = ']' THEN BEGIN
                    Position += 1;
                    Value += FORMAT(Char);
                  END ELSE
                    StopLoop := TRUE
                ELSE
                  Value += FORMAT(Char);

              Char = ';' :
                StopLoop := TRUE;

              Char = '}' :
                BEGIN
                  Value := DELSTR(Value, STRLEN(Value));
                  StopLoop := TRUE;
                END;

              ELSE
                Value += FORMAT(Char);

            END;

      END;

      CALHistoryLine.SETRANGE("Sub Line No.", 1);
    END;

    LOCAL PROCEDURE ReplaceFieldNo@50(VAR FieldName2@1000 : Text;TableNo@1001 : Integer);
    VAR
      Field@1002 : Record 2000000041;
      FieldNo2@1003 : Integer;
    BEGIN
      IF STRLEN(FieldName2) > 5 THEN
        IF EVALUATE(FieldNo2, COPYSTR(FieldName2, 6)) THEN BEGIN
          Field.SETRANGE(TableNo, TableNo);
          Field.SETRANGE("No.", FieldNo2);
          IF Field.FINDFIRST THEN
            FieldName2 := Field.FieldName;
        END;
    END;

    LOCAL PROCEDURE AddObjectLineRecord@51(VAR ObjectLine@1000 : Record 11102058;Enabled@1001 : Boolean;Type@1002 : Integer;Id@1003 : Integer;Name@1004 : Text;CALLineNo@1005 : Integer;ParentId@1006 : Integer;TypeName@1007 : Text;SubType@1008 : Text);
    BEGIN
      ObjectLine."Entry No." += 1;
      ObjectLine.Enabled := Enabled;
      ObjectLine.Type := Type;
      ObjectLine.Id := Id;
      ObjectLine.Name := Name;
      ObjectLine."C/AL Line No." := CALLineNo;
      ObjectLine."Parent No." := ParentId;
      ObjectLine.Used := TRUE;
      ObjectLine."Type Name" := TypeName;
      ObjectLine."Sub Type" := SubType;
      ObjectLine.INSERT;
    END;

    LOCAL PROCEDURE AppendVariablesToBuffer@52(VAR Variable@1000 : Record 11102062;Scope@1001 : 'Local,Parameter,Return Value,Global,Global Used';AddLocalFunctions@1002 : Boolean;ParentName@1003 : Text;Id2@1004 : Integer;ObjectType2@1005 : ' ,Table,,Report,,Codeunit,XMLport,MenuSuite,Page,Query';ObjectId@1006 : Integer;ObjectEntryNo@1007 : Integer;CALLineNo@1008 : Integer;ObjectLineEntryNo@1009 : Integer;VariableEntryNo@1010 : Integer;TypeName@1011 : Text;SubType@1012 : Text;IsTemporary2@1013 : Boolean) ExitValue : Boolean;
    VAR
      ObjectLine@1014 : Record 11102058;
      Mgt@1015 : Codeunit 11102035;
      ParentId@1016 : Integer;
      VariableType@1017 : ' ,Variable,Function';
      SetUsed@1018 : Boolean;
    BEGIN
      IF Scope = Scope::"Global Used" THEN BEGIN
        SetUsed := TRUE;
        Scope := Scope::Global;
      END;

      IF ParentName = '' THEN
        ParentId := -1
      ELSE BEGIN
        AddVariableRecord(
          Variable, Scope, 1, '', Mgt.AddQuotes(ParentName), ParentName,
          Id2, ObjectType2, ObjectId, ObjectEntryNo, CALLineNo, 0, ObjectLineEntryNo, VariableEntryNo, TypeName, SubType, IsTemporary2);
        ParentId := Variable."Entry No.";
        ExitValue := TRUE;
        IF SetUsed THEN
          FlagVariableUsedIn(Variable);
      END;

      IF ObjectType2 <> ObjectType2::" " THEN

        WITH ObjectLine DO BEGIN

          SETCURRENTKEY("Object Type", "Object No.", Type, Id);
          SETRANGE("Object Type", ObjectType2);
          SETRANGE("Object No.", ObjectId);

          IF AddLocalFunctions THEN
            SETFILTER(Type, '%1|%2|%3|%4', Type::Field, Type::"Global Function", Type::"Local Function", Type::Trigger)
          ELSE
            SETFILTER(Type, '%1|%2|%3', Type::Field, Type::"Global Function", Type::Trigger);

          IF FINDSET THEN
            REPEAT

              CASE Type OF

                Type::"Global Function", Type::"Local Function" :
                  VariableType := VariableType::"Function";

                ELSE
                  VariableType := VariableType::" ";
              END;

              AddVariableRecord(
                Variable, Scope, VariableType, Mgt.AddQuotes(ParentName), Mgt.AddQuotes(Name), Name, Id2,
                0, 0, "Entry No.", CALLineNo, ParentId, ObjectLineEntryNo, VariableEntryNo, '', '', IsTemporary2);

              ExitValue := TRUE;

            UNTIL NEXT = 0;
        END;

      Variable."Entry No." := ParentId;
    END;

    LOCAL PROCEDURE AddVariableRecord@53(VAR VariableBuffer@1000 : TEMPORARY Record 11102062;Scope@1001 : 'Local,Parameter,Return Value,Global';Type@1002 : Option;ParentName@1003 : Text;Name@1004 : Text;CaseName@1005 : Text;Id@1006 : Integer;ObjectType2@1007 : Option;ObjectNo@1008 : Integer;ObjectEntryNo@1009 : Integer;CALLineNo@1010 : Integer;ParentEntryNo@1011 : Integer;ObjectLineEntryNo@1012 : Integer;VariableEntryNo@1013 : Integer;TypeName@1014 : Text;SubType@1015 : Text;IsTemporary2@1016 : Boolean);
    BEGIN
      VariableBufferEntryNo += 1;
      VariableBuffer."Entry No." := VariableBufferEntryNo;
      VariableBuffer.Scope := Scope;
      VariableBuffer."Parent Name" := ParentName;
      VariableBuffer.Name := Name;
      VariableBuffer."Case Name" := CaseName;
      VariableBuffer.Id := Id;
      VariableBuffer.Type := Type;
      VariableBuffer."Object Type" := ObjectType2;
      VariableBuffer."Object No." := ObjectNo;
      VariableBuffer."Object Entry No." := ObjectEntryNo;
      VariableBuffer."C/AL Line No." := CALLineNo;
      VariableBuffer."Parent Entry No." := ParentEntryNo;
      VariableBuffer."Object Line Entry No." := ObjectLineEntryNo;
      VariableBuffer."C/AL Line No." := CALLineNo;
      VariableBuffer.Used := FALSE;
      VariableBuffer."Current Key" := 0;
      VariableBuffer."Variable Entry No." := VariableEntryNo;
      VariableBuffer."Type Name" := TypeName;
      VariableBuffer."Sub Type" := SubType;
      VariableBuffer."Temporary Record" := IsTemporary2;
      VariableBuffer.INSERT;
    END;

    LOCAL PROCEDURE AddWhereUsedInRecord@54(VAR WhereUsedIn@1000 : Record 11102060;VAR Object@1001 : Record 2000000001;Type@1002 : Integer;Name@1003 : Text);
    BEGIN
      UsedInEntryNo += 1;
      WhereUsedIn."Entry No." := UsedInEntryNo;
      WhereUsedIn."Object Type" := Object.Type;
      WhereUsedIn."Object No." := Object.ID;
      WhereUsedIn.Type := Type;
      WhereUsedIn.Name := DELSTR(Name, 101);
      WhereUsedIn.INSERT;
    END;

    LOCAL PROCEDURE AddVariableUsedInRecord@55(VAR Variable@1000 : Record 11102062;VAR WhereUsedIn@1001 : Record 11102060;CALObjectLineNo@1002 : Integer;Validation@1003 : Integer);
    BEGIN
      IF NOT Variable.Used THEN BEGIN
        Variable.Used := TRUE;
        Variable.MODIFY;
      END;

      IF Variable.Type <> Variable.Type::Variable THEN
        AddCrossTableRecord(
          Variable."Object Entry No.", WhereUsedIn."Entry No.", CALObjectLineNo, Validation, Variable."Temporary Record");
    END;

    LOCAL PROCEDURE FlagVariableUsedIn@56(VAR Variable@1000 : Record 11102062);
    BEGIN
      IF NOT Variable.Used THEN BEGIN
        Variable.Used := TRUE;
        Variable.MODIFY;
      END;
    END;

    LOCAL PROCEDURE AddObjectUsedInRecord@57(VAR WhereUsedIn@1000 : Record 11102060;ObjectType2@1001 : Option;ObjectNo@1002 : Integer;Type@1003 : Option;Id@1004 : Integer;NameFilter@1005 : Text;CALLineNo@1006 : Integer;IsTemporary2@1007 : Boolean);
    VAR
      ObjectLine@1008 : Record 11102058;
      Mgt@1009 : Codeunit 11102035;
    BEGIN
      ObjectLine.SETCURRENTKEY("Object Type", "Object No.", Type);
      ObjectLine.SETRANGE("Object Type", ObjectType2);
      ObjectLine.SETRANGE("Object No.", ObjectNo);
      ObjectLine.SETRANGE(Type, Type);
      IF Id <> 0 THEN
        ObjectLine.SETRANGE(Id, Id);
      IF NameFilter <> '' THEN
        ObjectLine.SETFILTER(Name, Mgt.CreateFilter(NameFilter, FALSE));
      IF ObjectLine.FINDFIRST THEN
        AddCrossTableRecord(ObjectLine."Entry No.", WhereUsedIn."Entry No.", CALLineNo, 0, IsTemporary2);
    END;

    LOCAL PROCEDURE AddCrossTableRecord@58(ObjectEntryNo@1000 : Integer;InEntryNo@1001 : Integer;CALLineNo@1002 : Integer;Validation@1003 : Integer;IsTemporary2@1004 : Boolean);
    VAR
      CrossTable@1005 : Record 11102061;
    BEGIN
      IF (PrevObjectEntryNo = ObjectEntryNo) AND
         (PrevInEntryNo = InEntryNo) AND
         (PrevCALLineNo = CALLineNo) AND
         (PrevValidation = Validation) AND
         (PrevIsTemporary2 = IsTemporary2)
      THEN
        EXIT;

      CrossTableEntryNo += 1;
      CrossTable."Entry No." := CrossTableEntryNo;
      CrossTable."Object Entry No." := ObjectEntryNo;
      CrossTable."In Entry No." := InEntryNo;
      CrossTable."C/AL Code Line No." := CALLineNo;
      CrossTable.Validation := Validation;
      CrossTable."Temporary Record" := IsTemporary2;
      CrossTable.INSERT;

      PrevObjectEntryNo := ObjectEntryNo;
      PrevInEntryNo := InEntryNo;
      PrevCALLineNo := CALLineNo;
      PrevValidation := Validation;
      PrevIsTemporary2 := IsTemporary2;
    END;

    PROCEDURE SelectStr2@59(Number@1000 : Integer;VAR Options@1001 : Text) ExitValue : Text;
    VAR
      i@1002 : Integer;
      SplitCounter@1003 : Integer;
    BEGIN
      i := 1;
      SplitCounter := 1;
      WHILE (i <= STRLEN(Options)) AND (SplitCounter <= Number) DO BEGIN
        IF Options[i] = ',' THEN
          SplitCounter += 1
        ELSE
          IF SplitCounter = Number THEN
            ExitValue += FORMAT(Options[i]);
        i += 1;
      END;
    END;

    LOCAL PROCEDURE InVariableSection@61(VAR CALHistoryLine@1000 : Record 11102053) : Boolean;
    BEGIN
      IF STRLEN(CALHistoryLine.Code) < 5 THEN
        EXIT(TRUE);

      IF CALHistoryLine.Code[5] = ' ' THEN
        EXIT(TRUE);
    END;

    LOCAL PROCEDURE AddRelationRecord@62(TableNo@1000 : Integer;FieldNo2@1001 : Integer;RelationTableNo@1002 : Integer;RelationFieldNo@1003 : Integer);
    VAR
      Relation@1004 : Record 11102078;
    BEGIN
      Relation."Object Type" := Relation."Object Type"::Table;
      Relation."Table No." := TableNo;
      Relation."Field No." := FieldNo2;
      Relation."Relation Table No." := RelationTableNo;
      Relation."Relation Field No." := RelationFieldNo;
      Relation.INSERT;
    END;

    PROCEDURE DeleteObjectLines@64(VAR WhereUsedObjectLine@1000 : Record 11102058);
    VAR
      CALHistoryObject@1001 : Record 11102052;
      CALHistoryLine@1002 : Record 11102053;
      TmpCALHistoryLine@1003 : TEMPORARY Record 11102053;
      WhereUsedObject@1004 : Record 11102057;
      Object@1005 : Record 2000000001;
      Object2@1006 : Record 2000000001;
      TmpObject@1007 : TEMPORARY Record 2000000001;
      TableInformation@1008 : Record 2000000028;
      Field@1009 : Record 2000000041;
      ActionMgt@1010 : Codeunit 11102038;
      Progressbar@1011 : Codeunit 11102044;
      Progressbar2@1012 : Codeunit 11102044;
      WhereUsedMgt@1013 : Codeunit 11102045;
      ObjectMgt@1014 : Codeunit 11102046;
      SourceControl@1015 : Codeunit 11102050;
      FileHandler@1016 : Codeunit 11102097;
      EmptyRecRef@1017 : RecordRef;
      RecRef@1018 : RecordRef;
      EmptyFldRef@1019 : FieldRef;
      FldRef@1020 : FieldRef;
      FileName@1021 : Text;
      VersionList@1022 : Text;
      EndLineNo@1023 : Integer;
      StartLineNo@1024 : Integer;
      CALIsOutdated@1025 : Boolean;
      StopLoop@1026 : Boolean;
      ctCALIsOutdated@1027 : TextConst 'DEU=C/AL is not up to date.\Please refresh the where used object (Ctrl+F5).;ENU=C/AL is not up to date.\Please refresh the where used object (Ctrl+F5).;ESP=C/AL is not up to date.\Please refresh the where used object (Ctrl+F5).;FRA=C/AL is not up to date.\Please refresh the where used object (Ctrl+F5).;NLD=De C/AL is niet actueel.\Vernieuw het waar-gebruikt object (Ctrl+F5).;DEA=C/AL is not up to date.\Please refresh the where used object (Ctrl+F5).';
      ctCheckingObject@1028 : TextConst 'DEU=Checking object...;ENU=Checking object...;ESP=Checking object...;FRA=Checking object...;NLD=Object controleren...;DEA=Checking object...';
      ctDeletingObjectLines@1029 : TextConst 'DEU=Deleting lines...;ENU=Deleting lines...;ESP=Deleting lines...;FRA=Deleting lines...;NLD=Regels verwijderen...;DEA=Deleting lines...';
      ctStartNotFound@1030 : TextConst 'DEU=Start not found.;ENU=Start not found.;ESP=Start not found.;FRA=Start not found.;NLD=Begin niet gevonden.;DEA=Start not found.';
      ctUpdateFileName@1031 : TextConst 'DEU=UpdateObject.txt;ENU=UpdateObject.txt;ESP=UpdateObject.txt;FRA=UpdateObject.txt;NLD=UpdateObject.txt;DEA=UpdateObject.txt';
      ctUpdateObjectLines@1032 : TextConst 'DEU=Updating Where Used Objects...;ENU=Updating Where Used Objects...;ESP=Updating Where Used Objects...;FRA=Updating Where Used Objects...;NLD=Waar-gebruikt objecten bijwerken...;DEA=Updating Where Used Objects...';
      ctUpdateWhereUsedIn@1033 : TextConst 'DEU=Updating Where Used In...;ENU=Updating Where Used In...;ESP=Updating Where Used In...;FRA=Updating Where Used In...;NLD=Waar-gebruikt in bijwerken...;DEA=Updating Where Used In...';
      ctUpdatingObject@1034 : TextConst 'DEU=Updating object...;ENU=Updating object...;ESP=Updating object...;FRA=Updating object...;NLD=Object bijwerken...;DEA=Updating object...';
    BEGIN
      IF WhereUsedObjectLine.FINDSET THEN
        REPEAT
          IF Object.GET(WhereUsedObjectLine."Object Type", '', WhereUsedObjectLine."Object No.") THEN
            IF NOT TmpObject.GET(WhereUsedObjectLine."Object Type", '', WhereUsedObjectLine."Object No.") THEN BEGIN
              TmpObject := Object;
              TmpObject.INSERT;
            END;
        UNTIL WhereUsedObjectLine.NEXT = 0;

      Progressbar.Open(ctDeletingObjectLines, 2);
      Progressbar.BarSize := TmpObject.COUNT * 4;

      FileName := FileHandler.TempDirectory + ctUpdateFileName;

      IF TmpObject.FINDSET THEN
        REPEAT

          Object.GET(TmpObject.Type, '', TmpObject.ID);

          Progressbar.AddToBar(1);
          Progressbar.Text1Object := Object;
          Progressbar.Text2 := ctCheckingObject;
          Progressbar.UpdateBar;

          VersionList := Object."Version List";
          Object2 := Object;
          Object2.SETRECFILTER;

          IF NOT SourceControl.CheckObjectBeforeChanging(Object2, Progressbar2) THEN
            ERROR('');

          WhereUsedObject.GET(Object.Type, Object.ID);

          IF NOT CALHistoryObject.TryGoToLastRecord(Object.Type, Object.ID) THEN
            CALIsOutdated := TRUE
          ELSE
            IF CALHistoryObject."Entry No." <> WhereUsedObject."C/AL Code Entry No." THEN
              CALIsOutdated := TRUE
            ELSE
              IF SourceControl.ObjectHeaderIsOutdated(Object, TRUE) THEN
                CALIsOutdated := TRUE
              ELSE
                CALIsOutdated := SourceControl.LatestHistoryIsOutdated(Object);

          IF CALIsOutdated THEN
            ERROR(ctCALIsOutdated);

          Progressbar.AddToBar(1);
          Progressbar.Text2 := ctUpdatingObject;
          Progressbar.UpdateBar;

          TmpCALHistoryLine.RESET;
          TmpCALHistoryLine.DELETEALL;

          CALHistoryLine.SETRANGE("Entry No.", WhereUsedObject."C/AL Code Entry No.");
          IF CALHistoryLine.FINDSET THEN
            REPEAT
              TmpCALHistoryLine := CALHistoryLine;
              TmpCALHistoryLine.INSERT;
            UNTIL CALHistoryLine.NEXT = 0;

          WhereUsedObjectLine.SETCURRENTKEY("Object Type", "Object No.");
          WhereUsedObjectLine.SETRANGE("Object Type", Object.Type);
          WhereUsedObjectLine.SETRANGE("Object No.", Object.ID);
          IF WhereUsedObjectLine.FINDSET THEN
            REPEAT
              WhereUsedObjectLine.CALCFIELDS("No. of Times Used");
              WhereUsedObjectLine.TESTFIELD("No. of Times Used", 0);

              StartLineNo := WhereUsedObjectLine."C/AL Line No.";
              EndLineNo := 0;
              CASE WhereUsedObjectLine.Type OF

                WhereUsedObjectLine.Type::Key,
                WhereUsedObjectLine.Type::Field :
                  BEGIN
                    IF WhereUsedObjectLine.Type = WhereUsedObjectLine.Type::Field THEN
                      IF Field.GET(WhereUsedObjectLine."Object No.", WhereUsedObjectLine.Id) THEN
                        IF Field.Class = Field.Class::Normal THEN BEGIN

                          EmptyRecRef.OPEN(Object.ID);
                          EmptyFldRef := EmptyRecRef.FIELD(WhereUsedObjectLine.Id);

                          TableInformation.SETRANGE("Table No.", Object.ID);
                          IF TableInformation.FINDSET THEN
                            REPEAT
                              RecRef.OPEN(Object.ID, FALSE, TableInformation."Company Name");
                              FldRef := RecRef.FIELD(WhereUsedObjectLine.Id);
                              ActionMgt.SetNotEmptyFilter(FldRef, Field);
                              IF RecRef.FINDSET THEN
                                REPEAT
                                  FldRef := RecRef.FIELD(WhereUsedObjectLine.Id);
                                  FldRef.VALUE := EmptyFldRef.VALUE;
                                  RecRef.MODIFY;
                                UNTIL RecRef.NEXT = 0;
                              RecRef.CLOSE;
                              EmptyRecRef.CLOSE;
                            UNTIL TableInformation.NEXT = 0;

                          EmptyRecRef.CLOSE;
                        END;

                    IF CALHistoryObject."Object Type" = CALHistoryObject."Object Type"::Query THEN BEGIN
                      TmpCALHistoryLine.RESET;
                      TmpCALHistoryLine.SETFILTER("Line No.", '<=%1', StartLineNo);
                      TmpCALHistoryLine.SETRANGE("Sub Line No.", 1);
                      IF TmpCALHistoryLine.FINDLAST THEN
                        REPEAT
                          IF TmpCALHistoryLine.NEXT(-1) = 0 THEN
                            ERROR(ctStartNotFound);
                        UNTIL DELSTR(TmpCALHistoryLine.Code, 6) = '    {';
                      StartLineNo := TmpCALHistoryLine."Line No.";
                    END;

                    EndLineNo := StartLineNo;
                    TmpCALHistoryLine.RESET;
                    TmpCALHistoryLine.SETFILTER("Line No.", '>=%1', StartLineNo);
                    TmpCALHistoryLine.SETRANGE("Sub Line No.", 1);
                    IF TmpCALHistoryLine.FINDSET THEN
                      REPEAT
                        StopLoop := TmpCALHistoryLine.NEXT = 0;
                        IF (DELSTR(TmpCALHistoryLine.Code, 6) = '     ') OR
                           (DELCHR(TmpCALHistoryLine.Code, '<>') = '')
                        THEN
                          EndLineNo := TmpCALHistoryLine."Line No."
                        ELSE
                          StopLoop := TRUE;
                      UNTIL StopLoop;

                    IF WhereUsedObjectLine.Type = WhereUsedObjectLine.Type::Key THEN
                      SetUpdateRelatedObject(WhereUsedObjectLine."Object Type", WhereUsedObjectLine."Object No.");

                  END;

                WhereUsedObjectLine.Type::"Global Function",
                WhereUsedObjectLine.Type::"Local Function" :
                  BEGIN
                    TmpCALHistoryLine.RESET;
                    TmpCALHistoryLine.SETFILTER("Line No.", '>=%1', StartLineNo);
                    TmpCALHistoryLine.SETRANGE("Sub Line No.", 1);
                    IF TmpCALHistoryLine.FINDSET THEN
                      REPEAT
                        StopLoop := TmpCALHistoryLine.NEXT = 0;
                        IF DELSTR(TmpCALHistoryLine.Code, 8) = '    END' THEN
                          EndLineNo := TmpCALHistoryLine."Line No.";
                      UNTIL StopLoop OR (EndLineNo <> 0);
                  END;

                WhereUsedObjectLine.Type::"Global Variable",
                WhereUsedObjectLine.Type::"Local Variable" :
                  EndLineNo := StartLineNo;

                ELSE
                  WhereUsedObjectLine.FIELDERROR(Type);

              END;

              IF EndLineNo <> 0 THEN BEGIN
                WhereUsedObjectLine.DELETE(TRUE);

                TmpCALHistoryLine.RESET;
                TmpCALHistoryLine.SETRANGE("Line No.", StartLineNo, EndLineNo);
                TmpCALHistoryLine.DELETEALL;
              END;

            UNTIL WhereUsedObjectLine.NEXT = 0;

          TmpCALHistoryLine.RESET;
          SourceControl.ExportTextFile(FileName, TmpCALHistoryLine);

          ObjectMgt.ImportObject(FileName);
          ObjectMgt.CompileObject(Object);

          Object.FIND('=');
          Object.Modified := TRUE;
          Object.Date := TODAY;
          Object.Time := TIME;
          Object."Version List" := VersionList;
          ObjectMgt.UpdateObject(Object, FALSE);

          SourceControl.AddObject(Object, 0, FALSE, FALSE, 1, FALSE);

          Progressbar.AddToBar(1);
          Progressbar.Text2 := ctUpdateObjectLines;
          Progressbar.UpdateBar;

          WhereUsedMgt.FillEntryNos;
          WhereUsedMgt.UpdateObjectLines(Object);

          Progressbar.AddToBar(1);
          Progressbar.Text2 := ctUpdateWhereUsedIn;
          Progressbar.UpdateBar;

          WhereUsedMgt.UpdateWhereInOfObject(Object);

          IF WhereUsedObject.GET(Object.Type, Object.ID) THEN BEGIN
            WhereUsedObject.Status := WhereUsedObject.Status::"Lines Updated";
            WhereUsedObject."Variable Usage Calculated" := FALSE;
            WhereUsedObject.MODIFY;
          END;

        UNTIL TmpObject.NEXT = 0;
    END;

    PROCEDURE WhatUsedInCALLine@65(VAR ObjectType2@1000 : Option;VAR ObjectNo@1001 : Integer;VAR FromCALLineNo@1002 : Integer;VAR TillCALLineNo@1003 : Integer);
    VAR
      TmpWhereUsedObjectLine@1004 : TEMPORARY Record 11102058;
    BEGIN
      FillWhatUsedInCALLine(ObjectType2, ObjectNo, FromCALLineNo, TillCALLineNo, TmpWhereUsedObjectLine, TRUE);
      PAGE.RUNMODAL(PAGE::"OM - Where Used Object Lines", TmpWhereUsedObjectLine);
    END;

    PROCEDURE FillWhatUsedInCALLine@63(VAR ObjectType2@1000 : Option;VAR ObjectNo@1001 : Integer;VAR FromCALLineNo@1002 : Integer;VAR TillCALLineNo@1003 : Integer;VAR TmpWhereUsedObjectLine@1004 : TEMPORARY Record 11102058;CalculateVariableUsage@1005 : Boolean);
    VAR
      WhereUsedObject@1006 : Record 11102057;
      WhereUsedObjectLine@1007 : Record 11102058;
      WhereUsedObjectLine2@1008 : Record 11102058;
      WhereUsedIn@1009 : Record 11102060;
      WhereUsedCrossTable@1010 : Record 11102061;
    BEGIN
      WhereUsedObject.GET(ObjectType2, ObjectNo);
      IF NOT WhereUsedObject."Variable Usage Calculated" AND CalculateVariableUsage THEN BEGIN
        WhereUsedObject.CalculateVariableUsage;
        COMMIT;
      END;

      WhereUsedIn.SETCURRENTKEY("Object Type", "Object No.", Type, Name);
      WhereUsedIn.SETRANGE("Object Type", ObjectType2);
      WhereUsedIn.SETRANGE("Object No.", ObjectNo);
      IF WhereUsedIn.FINDSET THEN
        REPEAT
          WhereUsedCrossTable.SETCURRENTKEY("In Entry No.");
          WhereUsedCrossTable.SETRANGE("In Entry No.", WhereUsedIn."Entry No.");
          WhereUsedCrossTable.SETRANGE("C/AL Code Line No.", FromCALLineNo, TillCALLineNo);
          IF WhereUsedCrossTable.FINDSET THEN
            REPEAT

              IF WhereUsedObjectLine.GET(WhereUsedCrossTable."Object Entry No.") THEN BEGIN
                IF NOT TmpWhereUsedObjectLine.GET(WhereUsedCrossTable."Object Entry No.") THEN BEGIN
                  TmpWhereUsedObjectLine := WhereUsedObjectLine;
                  TmpWhereUsedObjectLine.INSERT;
                END;
                IF NOT (
                   WhereUsedObjectLine.Type IN [
                     WhereUsedObjectLine.Type::"Global Variable",
                     WhereUsedObjectLine.Type::"Local Variable",
                     WhereUsedObjectLine.Type::Parameter,
                     WhereUsedObjectLine.Type::"Return Value"])
                THEN BEGIN
                  WhereUsedObjectLine2.SETCURRENTKEY("Object Type", "Object No.");
                  WhereUsedObjectLine2.SETRANGE("Object Type", WhereUsedObjectLine."Object Type");
                  WhereUsedObjectLine2.SETRANGE("Object No.", WhereUsedObjectLine."Object No.");
                  WhereUsedObjectLine2.SETRANGE(Type, WhereUsedObjectLine2.Type::Object);
                  IF WhereUsedObjectLine2.FINDFIRST THEN
                    IF NOT TmpWhereUsedObjectLine.GET(WhereUsedObjectLine2."Entry No.") THEN BEGIN
                      TmpWhereUsedObjectLine := WhereUsedObjectLine2;
                      TmpWhereUsedObjectLine.INSERT;
                    END;
                END;
              END;

            UNTIL WhereUsedCrossTable.NEXT = 0;
        UNTIL WhereUsedIn.NEXT = 0;
    END;

    PROCEDURE WhatUsedInObjectLine@66(WhereUsedObjectLine@1000 : Record 11102058);
    VAR
      WhereUsedObjectLine2@1001 : Record 11102058;
      FromCALLineNo@1002 : Integer;
      TillCALLineNo@1003 : Integer;
    BEGIN
      WITH WhereUsedObjectLine DO BEGIN
        FromCALLineNo := "C/AL Line No.";
        TillCALLineNo := 99999;

        IF Type <> Type::Object THEN BEGIN

          WhereUsedObjectLine2 := WhereUsedObjectLine;
          WhereUsedObjectLine2.SETCURRENTKEY("Object Type", "Object No.", "C/AL Line No.");
          WhereUsedObjectLine2.SETRANGE("Object Type", "Object Type");
          WhereUsedObjectLine2.SETRANGE("Object No.", "Object No.");
          WhereUsedObjectLine2.SETFILTER(Type, '<>%1&<>%2&<>%3&<>%4',
           WhereUsedObjectLine2.Type::"Global Variable",
           WhereUsedObjectLine2.Type::"Local Variable",
           WhereUsedObjectLine2.Type::Parameter,
           WhereUsedObjectLine2.Type::"Return Value");

          IF WhereUsedObjectLine2.NEXT <> 0 THEN
            TillCALLineNo := WhereUsedObjectLine2."C/AL Line No." - 1;

        END;

        WhatUsedInCALLine("Object Type", "Object No.", FromCALLineNo, TillCALLineNo);

      END;
    END;

    LOCAL PROCEDURE GuiConfirm@67(Question@1000 : Text;DefaultAnswer@1001 : Boolean) : Boolean;
    BEGIN
      IF NOT GUIALLOWED THEN
        EXIT(DefaultAnswer);

      EXIT(CONFIRM(Question, DefaultAnswer));
    END;

    LOCAL PROCEDURE RemoveFromTill@69(VAR CALHistoryLine@1000 : Record 11102053;BeginText@1001 : Text;EndText@1002 : Text);
    VAR
      TillLineNo@1003 : Integer;
    BEGIN
      CALHistoryLine.SETRANGE("Sub Line No.", 1);
      CALHistoryLine.SETRANGE(Code, EndText);
      IF NOT CALHistoryLine.FINDLAST THEN
        EXIT;

      TillLineNo := CALHistoryLine."Line No.";
      CALHistoryLine.SETFILTER("Line No.", '<%1', TillLineNo);
      CALHistoryLine.SETRANGE(Code, BeginText);
      IF NOT CALHistoryLine.FINDLAST THEN
        EXIT;

      CALHistoryLine.RESET;
      CALHistoryLine.SETRANGE("Line No.", CALHistoryLine."Line No.", TillLineNo);
      CALHistoryLine.DELETEALL;
    END;

    LOCAL PROCEDURE UseTestFile@70(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053);
    VAR
      TmpCALHistoryObject@1002 : TEMPORARY Record 11102052;
      ProgressBar@1003 : Codeunit 11102044;
      SourceControl@1004 : Codeunit 11102050;
      FileName@1005 : Text;
    BEGIN
      //IF (Object.Type = Object.Type::Page) AND (Object.ID = PAGE::"Opportunities Matrix") THEN
      //  FileName := 'C:\Users\reijer\Desktop\page9257.txt';

      IF FileName <> '' THEN BEGIN
        TmpCALHistoryObject."Entry No." := CALHistoryLine."Entry No." - 1;
        CALHistoryLine.DELETEALL;
        SourceControl.ImportTextFile2(FileName, 1, ProgressBar, 0, TmpCALHistoryObject, CALHistoryLine, TRUE);
      END;
    END;

    PROCEDURE ToggleKeyEnabled@71(VAR WhereUsedObjectLine@1000 : Record 11102058);
    VAR
      CALHistoryObject@1001 : Record 11102052;
      CALHistoryLine@1002 : Record 11102053;
      TmpCALHistoryLine@1003 : TEMPORARY Record 11102053;
      WhereUsedObject@1004 : Record 11102057;
      TmpWhereUsedObjectLine@1005 : TEMPORARY Record 11102058;
      Object@1006 : Record 2000000001;
      Progressbar@1007 : Codeunit 11102044;
      WhereUsedMgt@1008 : Codeunit 11102045;
      ObjectMgt@1009 : Codeunit 11102046;
      SourceControl@1010 : Codeunit 11102050;
      FileHandler@1011 : Codeunit 11102097;
      Directory@1012 : Text;
      FileName@1013 : Text;
      ctCheckingObject@1014 : TextConst 'DEU=Checking object...;ENU=Checking object...;ESP=Checking object...;FRA=Checking object...;NLD=Object controleren...;DEA=Checking object...';
      ctUpdateObject@1015 : TextConst 'DEU=UpdateObject.txt;ENU=UpdateObject.txt;ESP=UpdateObject.txt;FRA=UpdateObject.txt;NLD=UpdateObject.txt;DEA=UpdateObject.txt';
      ctUpdateObjectLines@1016 : TextConst 'DEU=Updating Where Used Objects...;ENU=Updating Where Used Objects...;ESP=Updating Where Used Objects...;FRA=Updating Where Used Objects...;NLD=Waar-gebruikt objecten bijwerken...;DEA=Updating Where Used Objects...';
      ctUpdateWhereUsedIn@1017 : TextConst 'DEU=Updating Where Used In...;ENU=Updating Where Used In...;ESP=Updating Where Used In...;FRA=Updating Where Used In...;NLD=Waar-gebruikt in bijwerken...;DEA=Updating Where Used In...';
      ctUpdatingObject@1018 : TextConst 'DEU=Updating object...;ENU=Updating object...;ESP=Updating object...;FRA=Updating object...;NLD=Object bijwerken...;DEA=Updating object...';
    BEGIN
      Directory := FileHandler.TempDirectory;
      FileName := Directory + ctUpdateObject;

      Progressbar.Open('', 1);
      Progressbar.Text1 := ctCheckingObject;
      Progressbar.BarSize := 4;

      Progressbar.AddToBar(1);

      Object.GET(WhereUsedObjectLine."Object Type", '', WhereUsedObjectLine."Object No.");
      IF NOT SourceControl.CheckObjectBeforeChanging(Object, Progressbar) THEN
        ERROR(FORMAT(''));

      Progressbar.Text1 := ctUpdatingObject;
      Progressbar.AddToBar(1);

      CALHistoryObject.GoToLastRecord(WhereUsedObjectLine."Object Type", WhereUsedObjectLine."Object No.");
      GetObjectLines(CALHistoryObject, TmpWhereUsedObjectLine, WhereUsedObjectLine."Object No.");

      TmpWhereUsedObjectLine.SETRANGE(Type, WhereUsedObjectLine.Type);
      TmpWhereUsedObjectLine.SETRANGE("Name to Display", WhereUsedObjectLine."Name to Display");
      TmpWhereUsedObjectLine.FINDFIRST;

      CALHistoryLine.SETRANGE("Entry No.", CALHistoryObject."Entry No.");
      IF CALHistoryLine.FINDSET THEN
        REPEAT
          TmpCALHistoryLine := CALHistoryLine;
          TmpCALHistoryLine.INSERT;

          IF (TmpCALHistoryLine."Line No." = TmpWhereUsedObjectLine."C/AL Line No.") AND
             (TmpCALHistoryLine."Sub Line No." = 1)
          THEN BEGIN
            TmpCALHistoryLine.Code := DELSTR(TmpCALHistoryLine.Code, 6, 4);
            IF WhereUsedObjectLine.Enabled THEN
              TmpCALHistoryLine.Code := INSSTR(TmpCALHistoryLine.Code, '    ', 6)
            ELSE
              TmpCALHistoryLine.Code := INSSTR(TmpCALHistoryLine.Code, ' 0  ', 6);
            TmpCALHistoryLine.MODIFY;
          END;
        UNTIL CALHistoryLine.NEXT = 0;

      SourceControl.ExportTextFile(FileName, TmpCALHistoryLine);
      SourceControl.SetModifyFlagInHistoryLines(TmpCALHistoryLine, TODAY, TIME);
      ObjectMgt.ImportObject(FileName);

      SourceControl.AddObject(Object, 0, FALSE, FALSE, 1, FALSE);

      Progressbar.Text1 := ctUpdateObjectLines;
      Progressbar.AddToBar(1);
      WhereUsedMgt.FillEntryNos;
      WhereUsedMgt.UpdateObjectLines(Object);

      Progressbar.Text1 := ctUpdateWhereUsedIn;
      Progressbar.AddToBar(1);
      WhereUsedMgt.UpdateWhereInOfObject(Object);

      IF WhereUsedObject.GET(Object.Type, Object.ID) THEN BEGIN
        WhereUsedObject.Status := WhereUsedObject.Status::"Lines Updated";
        WhereUsedObject."Variable Usage Calculated" := FALSE;
        WhereUsedObject.MODIFY;
      END;
    END;

    PROCEDURE SetAskSqlTriggerInstalled@72(NewValue@1000 : Boolean);
    BEGIN
      IF NewValue THEN
        AskSqlTriggerInstalled := AskSqlTriggerInstalled::Yes
      ELSE
        AskSqlTriggerInstalled := AskSqlTriggerInstalled::No;
    END;

    LOCAL PROCEDURE GetTableByName@73(VAR AllObj@1000 : Record 2000000038;Name@1001 : Text;RemoveQuotes@1002 : Boolean) : Boolean;
    VAR
      Mgt@1003 : Codeunit 11102035;
    BEGIN
      IF DELCHR(Name) = '' THEN
        EXIT(FALSE);

      EXIT(Mgt.GetTableByName(AllObj, Mgt.CreateFilter(Name, RemoveQuotes)));
    END;

    LOCAL PROCEDURE QueryFieldName@79(FieldName2@1000 : Text;Method@1001 : Text) : Text;
    BEGIN
      IF Method = '' THEN
        EXIT(QueryTableName(FieldName2))
      ELSE
        EXIT(Method + '_' + QueryTableName(FieldName2));
    END;

    LOCAL PROCEDURE QueryTableName@74(TableName2@1000 : Text) ExitValue : Text;
    VAR
      i@1001 : Integer;
      PrevWasSpecial@1002 : Boolean;
    BEGIN
      FOR i := 1 TO STRLEN(TableName2) DO
        IF TableName2[i] IN [' ', '-', '_', '.', '"', '\', '/', '%', '(', ')'] THEN BEGIN
          IF NOT PrevWasSpecial THEN
            ExitValue += '_';
          PrevWasSpecial := TRUE;
        END ELSE BEGIN
          ExitValue += FORMAT(TableName2[i]);
          PrevWasSpecial := FALSE;
        END;

      ExitValue := DELCHR(ExitValue, '<>', '_');
    END;

    PROCEDURE OpenCardWithObject@75(VAR Object@1000 : Record 2000000001);
    VAR
      WhereUsedObject@1001 : Record 11102057;
      WhereUsedMgt@1002 : Codeunit 11102045;
      WhereUsedObjectCard@1003 : Page 11102085;
    BEGIN
      WhereUsedMgt.RUN;

      WhereUsedObject.SETRANGE("Object Type", Object.Type);
      WhereUsedObject.SETRANGE("Object No.", Object.ID);
      WhereUsedObjectCard.SETTABLEVIEW(WhereUsedObject);
      WhereUsedObjectCard.RUN;
    END;

    LOCAL PROCEDURE UpdateData@76();
    VAR
      Object@1000 : Record 2000000001;
    BEGIN
      FillEntryNos;

      UpdateDataTable(DATABASE::"Web Service", 0, 3, 6);
      UpdateDataTable(DATABASE::"Report Selections", Object.Type::Report, 0, 3);
    END;

    LOCAL PROCEDURE UpdateDataTable@60(TableNo@1000 : Integer;ObjectTypePar@1001 : ' ,Table,Form,Report,Dataport,Codeunit,XMLport,MenuSuite,Page';ObjectTypeFieldNo@1002 : Integer;ObjectNoFieldNo@1003 : Integer);
    VAR
      ObjectLine@1004 : Record 11102058;
      WhereUsedIn@1005 : Record 11102060;
      Object@1006 : Record 2000000001;
      Object2@1007 : Record 2000000001;
      TmpFoundObject@1008 : TEMPORARY Record 2000000001;
      TableInformation@1009 : Record 2000000028;
      RecRef@1010 : RecordRef;
      ObjectNoFldRef@1011 : FieldRef;
      ObjectTypeFldRef@1012 : FieldRef;
      ObjectType2@1013 : ' ,Table,Form,Report,Dataport,Codeunit,XMLport,MenuSuite,Page';
    BEGIN
      IF NOT Object.GET(Object.Type::Table, '', TableNo) THEN
        EXIT;

      WhereUsedIn.SETCURRENTKEY("Object Type", "Object No.");
      WhereUsedIn.SETRANGE("Object Type", WhereUsedIn."Object Type"::Table);
      WhereUsedIn.SETRANGE("Object No.", TableNo);
      WhereUsedIn.SETRANGE(Type, WhereUsedIn.Type::Data);
      WhereUsedIn.DELETEALL(TRUE);

      TableInformation.SETRANGE("Table No.", TableNo);
      IF TableInformation.FINDSET THEN
        REPEAT
          RecRef.OPEN(TableNo, FALSE, TableInformation."Company Name");
          IF RecRef.FINDSET THEN
            REPEAT
              ObjectType2 := ObjectTypePar;
              IF ObjectType2 = ObjectType2::" " THEN BEGIN
                ObjectTypeFldRef := RecRef.FIELD(ObjectTypeFieldNo);
                IF EVALUATE(Object2.Type, FORMAT(ObjectTypeFldRef.VALUE)) THEN
                  ObjectType2 := Object2.Type;
              END;

              ObjectNoFldRef := RecRef.FIELD(ObjectNoFieldNo);
              IF EVALUATE(Object2.ID, FORMAT(ObjectNoFldRef.VALUE)) THEN
                IF NOT TmpFoundObject.GET(ObjectType2, '', Object2.ID) THEN BEGIN
                  TmpFoundObject.Type := ObjectType2;
                  TmpFoundObject.ID := Object2.ID;
                  TmpFoundObject.INSERT;
                END;
            UNTIL RecRef.NEXT = 0;
          RecRef.CLOSE;
        UNTIL TableInformation.NEXT = 0;

      IF TmpFoundObject.FINDSET THEN BEGIN
        AddWhereUsedInRecord(WhereUsedIn, Object, WhereUsedIn.Type::Data, Object.Name);
        REPEAT
          AddObjectUsedInRecord(WhereUsedIn, TmpFoundObject.Type, TmpFoundObject.ID, ObjectLine.Type::Object, 0, '', 1, FALSE);
          IF TmpFoundObject.Type <> TmpFoundObject.Type::Table THEN
            AddObjectUsedInRecord(WhereUsedIn, TmpFoundObject.Type, TmpFoundObject.ID, ObjectLine.Type::Trigger, 1, '', 1, FALSE);
        UNTIL TmpFoundObject.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE GetTriggers@80(ObjectType2@1000 : Integer;VAR Trigger@1001 : ARRAY [10] OF Text);
    VAR
      Object@1002 : Record 2000000001;
    BEGIN
      CLEAR(Trigger);
      CASE ObjectType2 OF

        Object.Type::Table :
          BEGIN
            Trigger[1] := 'Insert';
            Trigger[2] := 'Modify';
            Trigger[3] := 'Delete';
            Trigger[4] := 'Rename';
            Trigger[5] := 'Get';
            Trigger[6] := 'Find';
            Trigger[7] := 'Transferfields';
            Trigger[8] := 'Init';
          END;

        Object.Type::Report,
        Object.Type::XMLport,
        Object.Type::Codeunit,
        Object.Type::Page :
          Trigger[1] := 'Run';

        Object.Type::Query :
          BEGIN
            Trigger[1] := 'Run';
            Trigger[2] := 'Open';
            Trigger[3] := 'Read';
            Trigger[4] := 'Close';
          END;

      END;
    END;

    BEGIN
    END.
  }
}

