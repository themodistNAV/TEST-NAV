OBJECT Codeunit 9062683 Convert
{
  OBJECT-PROPERTIES
  {
    Date=23/03/16;
    Time=12:00:00 PM;
    Version List=NA2016.14;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      TableFieldBuffer@1000000000 : Record 9062231;
      tDataTypeNotSupported@1000000002 : TextConst 'ENU=Data type "%1" is not supported for %2.;ENG=Data type "%1" is not supported for %2.';
      tCantParse@1000000001 : TextConst 'ENU=Can''t parse "%1" text to %2.;ENG=Can''t parse "%1" text to %2.';
      String@1000000004 : Codeunit 9062236;
      TnpToolkit@1000000003 : Codeunit 9062230;

    LOCAL PROCEDURE "--- General ---"@1000000042();
    BEGIN
    END;

    PROCEDURE EmptyValue@1000000053(pDataType@1000000001 : Integer;VAR pValue@1000000000 : Variant);
    VAR
      lEmptyDateFormula@1000000002 : DateFormula;
      lEmptyDuration@1000000003 : Duration;
      lEmptyGuid@1000000004 : GUID;
      lEmptyRecordId@1000000005 : RecordID;
      lEmptyBlob@1000000006 : Record 99008535;
      eActivity@1000000007 : TextConst 'ENU=empty value;ENG=empty value';
    BEGIN
      //DOC NA2016.14 - Returning empty value
      //  -> pDataType: Data type
      //  <> pValue: Target value

      CASE (pDataType) OF
        TableFieldBuffer."Data Type"::Boolean: pValue := FALSE;
        TableFieldBuffer."Data Type"::BigInteger: pValue := 0L;
        TableFieldBuffer."Data Type"::Integer: pValue := 0;
        TableFieldBuffer."Data Type"::Option: pValue := 0;
        TableFieldBuffer."Data Type"::Decimal: pValue := 0D;
        TableFieldBuffer."Data Type"::Code: pValue := '';
        TableFieldBuffer."Data Type"::OemCode: pValue := '';
        TableFieldBuffer."Data Type"::Text: pValue := '';
        TableFieldBuffer."Data Type"::OemText: pValue := '';
        TableFieldBuffer."Data Type"::Date: pValue := 0D;
        TableFieldBuffer."Data Type"::Time: pValue := 0T;
        TableFieldBuffer."Data Type"::DateTime: pValue := 0DT;
        TableFieldBuffer."Data Type"::DateFormula: pValue := lEmptyDateFormula;
        TableFieldBuffer."Data Type"::Duration: pValue := lEmptyDuration;
        TableFieldBuffer."Data Type"::GUID: pValue := lEmptyGuid;
        TableFieldBuffer."Data Type"::RecordID: pValue := lEmptyRecordId;
        TableFieldBuffer."Data Type"::BLOB: pValue := lEmptyBlob.Blob;
        ELSE ERROR(tDataTypeNotSupported, DataTypeName(pDataType), eActivity);
      END;
    END;

    PROCEDURE IsValueEmpty@1000000056(pDataType@1000000001 : Integer;pValue@1000000000 : Variant) : Boolean;
    VAR
      lEmptyValue@1000000002 : Variant;
    BEGIN
      //DOC NA2016.14 - Responding if given value is empty
      //  -> pDataType: Data type
      //  -> pValue: The value
      //  <- Response

      EmptyValue(pDataType, lEmptyValue);
      EXIT(FORMAT(pValue, 0, 1) = FORMAT(lEmptyValue, 0, 1));
    END;

    PROCEDURE AreVariantsEqual@1000000055(VAR pVariant1@1000000000 : Variant;VAR pVariant2@1000000001 : Variant) : Boolean;
    BEGIN
      //DOC NA2016.14 - Answering if two variants are equal
      //  -> pVariant1: First variant
      //  -> pVariant2: Second variant
      //  <- The answer

      IF (((pVariant1.ISACTION()) AND (pVariant2.ISACTION())) OR
          ((pVariant1.ISAUTOMATION()) AND (pVariant2.ISAUTOMATION())) OR
          ((pVariant1.ISBIGINTEGER()) AND (pVariant2.ISBIGINTEGER())) OR
          ((pVariant1.ISBINARY()) AND (pVariant2.ISBINARY())) OR
          ((pVariant1.ISBOOLEAN()) AND (pVariant2.ISBOOLEAN())) OR
          ((pVariant1.ISCHAR()) AND (pVariant2.ISCHAR())) OR
          ((pVariant1.ISCLIENTTYPE()) AND (pVariant2.ISCLIENTTYPE())) OR
          ((pVariant1.ISCODE()) AND (pVariant2.ISCODE())) OR
          ((pVariant1.ISCODEUNIT()) AND (pVariant2.ISCODEUNIT())) OR
          ((pVariant1.ISDATE()) AND (pVariant2.ISDATE())) OR
          ((pVariant1.ISDATEFORMULA()) AND (pVariant2.ISDATEFORMULA())) OR
          ((pVariant1.ISDATETIME()) AND (pVariant2.ISDATETIME())) OR
          ((pVariant1.ISDECIMAL()) AND (pVariant2.ISDECIMAL())) OR
          ((pVariant1.ISDEFAULTLAYOUT()) AND (pVariant2.ISDEFAULTLAYOUT())) OR
          ((pVariant1.ISDOTNET()) AND (pVariant2.ISDOTNET())) OR
          ((pVariant1.ISDURATION()) AND (pVariant2.ISDURATION())) OR
          ((pVariant1.ISEXECUTIONMODE()) AND (pVariant2.ISEXECUTIONMODE())) OR
          ((pVariant1.ISFIELDREF()) AND (pVariant2.ISFIELDREF())) OR
          ((pVariant1.ISFILE()) AND (pVariant2.ISFILE())) OR
          ((pVariant1.ISFILTERPAGEBUILDER()) AND (pVariant2.ISFILTERPAGEBUILDER())) OR
          ((pVariant1.ISGUID()) AND (pVariant2.ISGUID())) OR
          ((pVariant1.ISINSTREAM()) AND (pVariant2.ISINSTREAM())) OR
          ((pVariant1.ISINTEGER()) AND (pVariant2.ISINTEGER())) OR
          ((pVariant1.ISOBJECTTYPE()) AND (pVariant2.ISOBJECTTYPE())) OR
          ((pVariant1.ISOPTION()) AND (pVariant2.ISOPTION())) OR
          ((pVariant1.ISOUTSTREAM()) AND (pVariant2.ISOUTSTREAM())) OR
          ((pVariant1.ISRECORD()) AND (pVariant2.ISRECORD())) OR
          ((pVariant1.ISRECORDID()) AND (pVariant2.ISRECORDID())) OR
          ((pVariant1.ISRECORDREF()) AND (pVariant2.ISRECORDREF())) OR
          ((pVariant1.ISREPORTFORMAT()) AND (pVariant2.ISREPORTFORMAT())) OR
          ((pVariant1.ISSECURITYFILTERING()) AND (pVariant2.ISSECURITYFILTERING())) OR
          ((pVariant1.ISTABLECONNECTIONTYPE()) AND (pVariant2.ISTABLECONNECTIONTYPE())) OR
          ((pVariant1.ISTEXT()) AND (pVariant2.ISTEXT())) OR
          ((pVariant1.ISTEXTENCODING()) AND (pVariant2.ISTEXTENCODING())) OR
          ((pVariant1.ISTIME()) AND (pVariant2.ISTIME())) OR
          ((pVariant1.ISTRANSACTIONTYPE()) AND (pVariant2.ISTRANSACTIONTYPE())) OR
          ((pVariant1.ISWIDECHAR()) AND (pVariant2.ISWIDECHAR()))) THEN
        EXIT(FORMAT(pVariant1, 0, 1) = FORMAT(pVariant2, 0, 1))
      ELSE
        EXIT(FALSE);
    END;

    LOCAL PROCEDURE "--- Parsing ---"@1000000007();
    BEGIN
    END;

    PROCEDURE Parse@1000000002(pText@1000000000 : Text;pDataType@1000000001 : Integer;VAR pValue@1000000002 : Variant);
    VAR
      eActivity@1000000003 : TextConst 'ENU=parsing;ENG=parsing';
    BEGIN
      //DOC NA2016.12 - Parsing text to value of given type
      //  -> pText: Text
      //  -> pDataType: Data type
      //  <> pValue: Target value

      CASE (pDataType) OF
        TableFieldBuffer."Data Type"::Boolean:
          pValue := ParseBoolean(pText);
        TableFieldBuffer."Data Type"::BigInteger:
          pValue := ParseBigInteger(pText);
        TableFieldBuffer."Data Type"::Integer,
        TableFieldBuffer."Data Type"::Option:
          pValue := ParseInteger(pText);
        TableFieldBuffer."Data Type"::Decimal:
          pValue := ParseDecimal(pText);
        TableFieldBuffer."Data Type"::Code,
        TableFieldBuffer."Data Type"::OemCode:
          pValue := ParseCode(pText);
        TableFieldBuffer."Data Type"::Text,
        TableFieldBuffer."Data Type"::OemText:
          pValue := pText;
        TableFieldBuffer."Data Type"::Date:
          pValue := ParseDate(pText);
        TableFieldBuffer."Data Type"::Time:
          pValue := ParseTime(pText);
        TableFieldBuffer."Data Type"::DateTime:
          pValue := ParseDateTime(pText);
        TableFieldBuffer."Data Type"::DateFormula:
          ParseDateFormula(pText, pValue);
        TableFieldBuffer."Data Type"::Duration:
          ParseDuration(pText, pValue);
        TableFieldBuffer."Data Type"::GUID:
          pValue := ParseGuid(pText);
        TableFieldBuffer."Data Type"::RecordID:
          ParseRecordId(pText, pValue);
        TableFieldBuffer."Data Type"::BLOB:
          ParseBlob(pText, pValue);
        ELSE
          ERROR(tDataTypeNotSupported, DataTypeName(pDataType), eActivity);
      END;
    END;

    PROCEDURE ParseBoolean@1000000004(pText@1000000000 : Text) : Boolean;
    VAR
      lResult@1000000002 : Boolean;
      lValue@1000000001 : Boolean;
      lText@1000000003 : Text;
    BEGIN
      //DOC NA2016.12 - Parsing text to boolean value
      //  -> pText: Text
      //  <- Value

      IF (pText <> '') THEN
      BEGIN
        lResult := EVALUATE(lValue, pText);
        IF ( NOT (lResult)) THEN
        BEGIN
          lText := DELCHR(LOWERCASE(pText), '<>', ' ');
          IF (lText IN ['true', 'yes', '1']) THEN
          BEGIN
            lValue := TRUE;
            lResult := TRUE;
          END
          ELSE IF (lText IN ['false', 'no', '0']) THEN
          BEGIN
            lValue := FALSE;
            lResult := TRUE;
          END
        END;
        IF ( NOT (lResult)) THEN
          ERROR(tCantParse, pText, DataTypeName(TableFieldBuffer."Data Type"::Boolean));
      END
      ELSE
        lValue := FALSE;
      EXIT(lValue);
    END;

    PROCEDURE ParseBigInteger@1000000011(pText@1000000000 : Text) : BigInteger;
    VAR
      lValue@1000000001 : BigInteger;
    BEGIN
      //DOC NA2016.12 - Parsing text to big integer value
      //  -> pText: Text
      //  <- Value

      IF (pText <> '') THEN
        EVALUATE(lValue, pText)
      ELSE
        lValue := 0L;
      EXIT(lValue);
    END;

    PROCEDURE ParseInteger@1000000012(pText@1000000000 : Text) : Integer;
    VAR
      lValue@1000000001 : Integer;
    BEGIN
      //DOC NA2016.12 - Parsing text to integer value
      //  -> pText: Text
      //  <- Value

      IF (pText <> '') THEN
        EVALUATE(lValue, pText)
      ELSE
        lValue := 0;
      EXIT(lValue);
    END;

    PROCEDURE ParseDecimal@1000000013(pText@1000000000 : Text) : Decimal;
    VAR
      lValue@1000000001 : Decimal;
    BEGIN
      //DOC NA2016.12 - Parsing text to decimal value
      //  -> pText: Text
      //  <- Value

      IF (pText <> '') THEN
        EVALUATE(lValue, pText)
      ELSE
        lValue := 0.0;
      EXIT(lValue);
    END;

    PROCEDURE ParseCode@1000000039(pText@1000000000 : Text) : Code[1024];
    VAR
      lValue@1000000001 : Code[1024];
      eTextTooLong@1000000002 : TextConst 'ENU=Text "%1" is too long to convert to code (having maximum length of %2).;ENG=Text "%1" is too long to convert to code (having maximum length of %2).';
    BEGIN
      //DOC NA2016.12 - Parsing text to code value
      //  -> pText: Text
      //  <- Value

      pText := DELCHR(UPPERCASE(pText), '<>', ' ');
      IF (STRLEN(pText) > MAXSTRLEN(lValue)) THEN
        ERROR(eTextTooLong, pText, MAXSTRLEN(lValue));
      lValue := pText;
      EXIT(lValue);
    END;

    PROCEDURE ParseDate@1000000014(pText@1000000000 : Text) : Date;
    VAR
      lValue@1000000001 : Date;
    BEGIN
      //DOC NA2016.12 - Parsing text to date value
      //  -> pText: Text
      //  <- Value

      IF (pText <> '') THEN
        EVALUATE(lValue, pText)
      ELSE
        lValue := 0D;
      EXIT(lValue);
    END;

    PROCEDURE ParseTime@1000000016(pText@1000000000 : Text) : Time;
    VAR
      lValue@1000000001 : Time;
    BEGIN
      //DOC NA2016.12 - Parsing text to time value
      //  -> pText: Text
      //  <- Value

      IF (pText <> '') THEN
        EVALUATE(lValue, pText)
      ELSE
        lValue := 0T;
      EXIT(lValue);
    END;

    PROCEDURE ParseDateTime@1000000015(pText@1000000000 : Text) : DateTime;
    VAR
      lValue@1000000001 : DateTime;
    BEGIN
      //DOC NA2016.12 - Parsing text to datetime value
      //  -> pText: Text
      //  <- Value

      IF (pText <> '') THEN
        EVALUATE(lValue, pText)
      ELSE
        lValue := 0DT;
      EXIT(lValue);
    END;

    PROCEDURE ParseDateFormula@1000000017(pText@1000000000 : Text;VAR pValue@1000000002 : DateFormula);
    VAR
      lEmptyValue@1000000001 : DateFormula;
    BEGIN
      //DOC NA2016.12 - Parsing text to dateformula value
      //  -> pText: Text
      //  <> pValue: Target value

      IF (pText <> '') THEN
        EVALUATE(pValue, pText)
      ELSE
        pValue := lEmptyValue;
    END;

    PROCEDURE ParseDuration@1000000018(pText@1000000000 : Text;VAR pValue@1000000002 : Duration);
    VAR
      lEmptyValue@1000000001 : Duration;
    BEGIN
      //DOC NA2016.12 - Parsing text to duration value
      //  -> pText: Text
      //  <> pValue: Target value

      IF (pText <> '') THEN
        EVALUATE(pValue, pText)
      ELSE
        pValue := lEmptyValue;
    END;

    PROCEDURE ParseGuid@1000000019(pText@1000000000 : Text) : GUID;
    VAR
      lValue@1000000001 : GUID;
      lEmptyValue@1000000002 : GUID;
    BEGIN
      //DOC NA2016.12 - Parsing text to GUID value
      //  -> pText: Text
      //  <- Value

      IF (pText <> '') THEN
        EVALUATE(lValue, pText)
      ELSE
        lValue := lEmptyValue;
      EXIT(lValue);
    END;

    PROCEDURE ParseRecordId@1000000047(pText@1000000000 : Text;VAR pValue@1000000002 : RecordID);
    VAR
      lEmptyValue@1000000001 : RecordID;
    BEGIN
      //DOC NA2016.12 - Parsing text to RecordID value
      //  -> pText: Text
      //  <> pValue: Target value

      IF (pText <> '') THEN
        EVALUATE(pValue, pText)
      ELSE
        pValue := lEmptyValue;
    END;

    PROCEDURE ParseBlob@1000000043(pText@1000000000 : Text;VAR pValue@1000000001 : Record 99008535);
    VAR
      lBlobToolkit@1000000002 : Codeunit 9062242;
      lTextBlob@1000000003 : Record 99008535;
      lEmptyBlob@1000000004 : Record 99008535;
    BEGIN
      //DOC NA2016.14 - Parsing text to BLOB value
      //  -> pText: Text
      //  <> pValue: Target Value

      IF (pText <> '') THEN
      BEGIN
        lBlobToolkit.TextToBlob(pText, lTextBlob);
        lBlobToolkit.FromBase64(lTextBlob, pValue);
      END
      ELSE
        pValue := lEmptyBlob;
    END;

    LOCAL PROCEDURE "--- Safe Parsing ---"@1000000054();
    BEGIN
    END;

    PROCEDURE SafeParseBoolean@1000000052(pText@1000000000 : Text;pDefaultValue@1000000004 : Boolean) : Boolean;
    VAR
      lValue@1000000001 : Boolean;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to boolean value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <- Value

      IF ( NOT (TryToParseBoolean(pText, lValue))) THEN
        lValue := pDefaultValue;
      EXIT(lValue);
    END;

    PROCEDURE SafeParseBigInteger@1000000051(pText@1000000000 : Text;pDefaultValue@1000000002 : BigInteger) : BigInteger;
    VAR
      lValue@1000000001 : BigInteger;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to big integer value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <- Value

      IF ( NOT (TryToParseBigInteger(pText, lValue))) THEN
        lValue := pDefaultValue;
      EXIT(lValue);
    END;

    PROCEDURE SafeParseInteger@1000000048(pText@1000000000 : Text;pDefaultValue@1000000002 : Integer) : Integer;
    VAR
      lValue@1000000001 : Integer;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to integer value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <- Value

      IF ( NOT (TryToParseInteger(pText, lValue))) THEN
        lValue := pDefaultValue;
      EXIT(lValue);
    END;

    PROCEDURE SafeParseDecimal@1000000044(pText@1000000000 : Text;pDefaultValue@1000000002 : Decimal) : Decimal;
    VAR
      lValue@1000000001 : Decimal;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to decimal value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <- Value

      IF ( NOT (TryToParseDecimal(pText, lValue))) THEN
        lValue := pDefaultValue;
      EXIT(lValue);
    END;

    PROCEDURE SafeParseDate@1000000041(pText@1000000000 : Text;pDefaultValue@1000000002 : Date) : Date;
    VAR
      lValue@1000000001 : Date;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to date value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <- Value

      IF ( NOT (TryToParseDate(pText, lValue))) THEN
        lValue := pDefaultValue;
      EXIT(lValue);
    END;

    PROCEDURE SafeParseTime@1000000040(pText@1000000000 : Text;pDefaultValue@1000000002 : Time) : Time;
    VAR
      lValue@1000000001 : Time;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to time value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <- Value

      IF ( NOT (TryToParseTime(pText, lValue))) THEN
        lValue := pDefaultValue;
      EXIT(lValue);
    END;

    PROCEDURE SafeParseDateTime@1000000038(pText@1000000000 : Text;pDefaultValue@1000000002 : DateTime) : DateTime;
    VAR
      lValue@1000000001 : DateTime;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to datetime value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <- Value

      IF ( NOT (TryToParseDateTime(pText, lValue))) THEN
        lValue := pDefaultValue;
      EXIT(lValue);
    END;

    PROCEDURE SafeParseDateFormula@1000000037(pText@1000000000 : Text;pDefaultValue@1000000001 : DateFormula;VAR pValue@1000000002 : DateFormula);
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to dateformula value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <> pValue: Target value

      IF ( NOT (TryToParseDateFormula(pText, pValue))) THEN
        pValue := pDefaultValue;
    END;

    PROCEDURE SafeParseDuration@1000000036(pText@1000000000 : Text;pDefaultValue@1000000001 : Duration;VAR pValue@1000000002 : Duration);
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to duration value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <> pValue: Target value

      IF ( NOT (TryToParseDuration(pText, pValue))) THEN
        pValue := pDefaultValue;
    END;

    PROCEDURE SafeParseGuid@1000000027(pText@1000000000 : Text;pDefaultValue@1000000002 : GUID) : GUID;
    VAR
      lValue@1000000001 : GUID;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to GUID value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <- Value

      IF ( NOT (TryToParseGuid(pText, lValue))) THEN
        lValue := pDefaultValue;
      EXIT(lValue);
    END;

    PROCEDURE SafeParseRecordId@1000000025(pText@1000000000 : Text;pDefaultValue@1000000001 : RecordID;VAR pValue@1000000002 : RecordID);
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to RecordID value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <> pValue: Target value

      IF ( NOT (TryToParseRecordId(pText, pValue))) THEN
        pValue := pDefaultValue;
    END;

    PROCEDURE SafeParseBlob@1000000022(pText@1000000000 : Text;pDefaultValue@1000000003 : Record 99008535;VAR pValue@1000000001 : Record 99008535);
    VAR
      lBlobToolkit@1000000002 : Codeunit 9062242;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to BLOB value
      //  -> pText: Text
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <> pValue: Target value

      IF ( NOT (TryToParseBlob(pText, pValue))) THEN
        pValue.Blob := pDefaultValue.Blob;
    END;

    LOCAL PROCEDURE "--- Trying to Parse ---"@1000000008();
    BEGIN
    END;

    [TryFunction]
    PROCEDURE TryToParse@1000000006(pText@1000000002 : Text;pDataType@1000000001 : Integer;VAR pValue@1000000000 : Variant);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to value of given type
      //  -> pText: Text
      //  -> pDataType: Data type
      //  <> pValue: Target value

      Parse(pText, pDataType, pValue);
    END;

    [TryFunction]
    PROCEDURE TryToParseBoolean@1000000000(pText@1000000000 : Text;VAR pValue@1000000001 : Boolean);
    VAR
      lResult@1000000002 : Boolean;
      lText@1000000003 : Text;
    BEGIN
      //DOC NA2016.12 - Trying to parse text to boolean value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      pValue := ParseBoolean(pText);
    END;

    [TryFunction]
    PROCEDURE TryToParseBigInteger@1000000026(pText@1000000001 : Text;VAR pValue@1000000000 : BigInteger);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to biginteger value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      pValue := ParseBigInteger(pText);
    END;

    [TryFunction]
    PROCEDURE TryToParseInteger@1000000024(pText@1000000001 : Text;VAR pValue@1000000000 : Integer);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to integer value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      pValue := ParseInteger(pText);
    END;

    [TryFunction]
    PROCEDURE TryToParseDecimal@1000000034(pText@1000000001 : Text;VAR pValue@1000000000 : Decimal);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to decimal value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      pValue := ParseDecimal(pText);
    END;

    [TryFunction]
    PROCEDURE TryToParseDate@1000000033(pText@1000000001 : Text;VAR pValue@1000000000 : Date);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to date value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      pValue := ParseDate(pText);
    END;

    [TryFunction]
    PROCEDURE TryToParseTime@1000000032(pText@1000000001 : Text;VAR pValue@1000000000 : Time);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to time value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      pValue := ParseTime(pText);
    END;

    [TryFunction]
    PROCEDURE TryToParseDateTime@1000000031(pText@1000000001 : Text;VAR pValue@1000000000 : DateTime);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to datetime value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      pValue := ParseDateTime(pText);
    END;

    [TryFunction]
    PROCEDURE TryToParseDateFormula@1000000030(pText@1000000001 : Text;VAR pValue@1000000000 : DateFormula);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to dateformula value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      ParseDateFormula(pText, pValue);
    END;

    [TryFunction]
    PROCEDURE TryToParseDuration@1000000029(pText@1000000001 : Text;VAR pValue@1000000000 : Duration);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to duration value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      ParseDuration(pText, pValue);
    END;

    [TryFunction]
    PROCEDURE TryToParseGuid@1000000028(pText@1000000001 : Text;VAR pValue@1000000000 : GUID);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to GUID value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      pValue := ParseGuid(pText);
    END;

    [TryFunction]
    PROCEDURE TryToParseRecordId@1000000049(pText@1000000001 : Text;VAR pValue@1000000000 : RecordID);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to GUID value
      //  -> pText: Text
      //  <> pValue: Target value
      //  <- Try result

      ParseRecordId(pText, pValue);
    END;

    [TryFunction]
    PROCEDURE TryToParseBlob@1000000050(pText@1000000000 : Text;VAR pValue@1000000001 : Record 99008535);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to BLOB value
      //  -> pText: Text
      //  <> pValue: Target Value
      //  <- Try result

      ParseBlob(pText, pValue);
    END;

    LOCAL PROCEDURE "--- Option ---"@1000000057();
    BEGIN
    END;

    PROCEDURE ParseTableFieldOption@1000000046(pText@1000000000 : Text;pTableId@1000000001 : Integer;pFieldId@1000000002 : Integer) : Integer;
    VAR
      lField@1000000003 : Record 2000000041;
      eOptionWithIndexNotAvailable@1000000009 : TextConst 'ENU=Option with index %1 is not available.;ENG=Option with index %1 is not available.';
      eUnknownOption@1000000010 : TextConst 'ENU=Unknown option "%1";ENG=Unknown option "%1"';
    BEGIN
      //DOC NA2016.12 - Parsing text to option value
      //  -> pText: Text
      //  -> pTableId: Table ID
      //  -> pFieldId: Field ID
      //  <- Value (integer)

      lField.GET(pTableId, pFieldId);
      lField.TESTFIELD(Type, lField.Type::Option);
      EXIT(ParseOptionInternal(pText, lField.OptionString));
    END;

    PROCEDURE ParseFieldRefOption@1000000059(pText@1000000001 : Text;pFieldRef@1000000000 : FieldRef) : Integer;
    BEGIN
      //DOC NA2016.14 - Parsing FieldRef option
      //  -> pText: Text
      //  -> pFieldRef: The FieldRef
      //  <- Value (integer)

      EXIT(ParseOptionInternal(pText, pFieldRef.OPTIONCAPTION()));
    END;

    PROCEDURE ParseOptionInternal@1000000058(pText@1000000000 : Text;pOptionString@1000000001 : Text) : Integer;
    VAR
      lOptionBuffer@1000000004 : TEMPORARY Record 9062730;
      lOptionsFound@1000000007 : Boolean;
      lOptionIndex@1000000008 : Integer;
      lResult@1000000005 : Boolean;
      lText@1000000006 : Text;
      eOptionWithIndexNotAvailable@1000000009 : TextConst 'ENU=Option with index %1 is not available.;ENG=Option with index %1 is not available.';
      eUnknownOption@1000000010 : TextConst 'ENU=Unknown option "%1";ENG=Unknown option "%1"';
    BEGIN
      //DOC NA2016.12 - Parsing text to option value
      //  -> pText: Text
      //  -> pOptionString: Option string
      //  <- Value (integer)

      String.SplitAdvanced(pOptionString, ',', FALSE, TRUE, lOptionBuffer);
      lOptionsFound := ( NOT (lOptionBuffer.ISEMPTY()));
      IF (lOptionsFound) THEN
      BEGIN
        lOptionBuffer.FINDSET();
        REPEAT
          lOptionBuffer.Value := DELCHR(LOWERCASE(lOptionBuffer.Value), '<>', ' ');
          lOptionBuffer.MODIFY();
        UNTIL (lOptionBuffer.NEXT() = 0);
        lText := DELCHR(LOWERCASE(pText), '<>', ' ');
        lResult := FALSE;
        IF ( NOT (lResult)) THEN
          IF (EVALUATE(lOptionIndex, pText)) THEN
          BEGIN
            IF ( NOT (lOptionBuffer.GET(lOptionIndex))) THEN
              ERROR(eOptionWithIndexNotAvailable, lOptionIndex);
            IF (lOptionBuffer.Name = '') THEN
              ERROR(eOptionWithIndexNotAvailable, lOptionIndex);
            lResult := TRUE;
          END;
        IF ( NOT (lResult)) THEN
          IF (STRLEN(pText) <= MAXSTRLEN(lOptionBuffer.Value)) THEN
          BEGIN
            lOptionBuffer.SETRANGE(Value, lText);
            lResult := lOptionBuffer.FINDFIRST();
          END;
        IF ( NOT (lResult)) THEN
        BEGIN
          lOptionBuffer.SETFILTER(Value, lText + '*');
          lResult := lOptionBuffer.FINDFIRST();
        END;
        IF ( NOT (lResult)) THEN
        BEGIN
          lOptionBuffer.SETFILTER(Value, '*' + lText + '*');
          lResult := lOptionBuffer.FINDFIRST();
        END;
        IF ( NOT (lResult)) THEN
          ERROR(eUnknownOption, pText);
      END;
      EXIT(lOptionBuffer.ID);
    END;

    PROCEDURE SafeParseTableFieldOption@1000000045(pText@1000000000 : Text;pTableId@1000000001 : Integer;pFieldId@1000000002 : Integer;pDefaultValue@1000000004 : Option) : Integer;
    VAR
      eOptionWithIndexNotAvailable@1000000009 : TextConst 'ENU=Option with index %1 is not available.;ENG=Option with index %1 is not available.';
      eUnknownOption@1000000010 : TextConst 'ENU=Unknown option "%1";ENG=Unknown option "%1"';
      lValue@1000000003 : Option;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to (table field) option value
      //  -> pText: Text
      //  -> pTableId: Table ID
      //  -> pFieldId: Field ID
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <- Value (integer)

      IF ( NOT (TryToParseTableFieldOption(pText, pTableId, pFieldId, lValue))) THEN
        lValue := pDefaultValue;
      EXIT(lValue);
    END;

    PROCEDURE SafeParseFieldRefOption@1000000061(pText@1000000004 : Text;pFieldRef@1000000003 : FieldRef;pDefaultValue@1000000001 : Option) : Integer;
    VAR
      lValue@1000000000 : Integer;
    BEGIN
      //DOC NA2016.14 - Safe-parsing text to (FieldRef) option
      //  -> pText: Text
      //  -> pFieldRef: The FieldRef
      //  -> pDefaultValue: Default value (used if parsing fails)
      //  <- Value (integer)

      IF ( NOT (TryToParseFieldRefOption(pText, pFieldRef, lValue))) THEN
        lValue := pDefaultValue;
      EXIT(lValue);
    END;

    [TryFunction]
    PROCEDURE TryToParseTableFieldOption@1000000023(pText@1000000001 : Text;pTableId@1000000003 : Integer;pFieldId@1000000002 : Integer;VAR pValue@1000000000 : Option);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to (table field) option value
      //  -> pText: Text
      //  -> pTableId: Table ID
      //  -> pFieldId: Field ID
      //  <> pValue: Target value (integer)
      //  <- Try result

      pValue := ParseTableFieldOption(pText, pTableId, pFieldId);
    END;

    [TryFunction]
    PROCEDURE TryToParseFieldRefOption@1000000060(pText@1000000000 : Text;pFieldRef@1000000001 : FieldRef;VAR pValue@1000000002 : Integer);
    BEGIN
      //DOC NA2016.12 - Trying to parse text to (FieldRef) option value
      //  -> pText: Text
      //  -> pFieldRef: The FieldRef
      //  <> pValue: Target value (integer)
      //  <- Try result

      pValue := ParseFieldRefOption(pText, pFieldRef);
    END;

    LOCAL PROCEDURE "--- Conversion ---"@1000000062();
    BEGIN
    END;

    PROCEDURE ConvertValue@1000000063(pSourceDataType@1000000001 : Integer;pSourceValue@1000000000 : Variant;pTargetDataType@1000000002 : Integer;VAR pTargetValue@1000000003 : Variant) : Boolean;
    VAR
      lResult@1000000004 : Boolean;
      eCantConvert@1000000005 : TextConst 'ENU=Cannot convert %1 value of "%2" to %3.;ENG=Cannot convert %1 value of "%2" to %3.';
    BEGIN
      //DOC NA2016.14 - Converting value from one data type to another
      //  -> pSourceDataType: Source data type
      //  -> pSourceValue: Source value
      //  -> pTargetDataType: Target data type
      //  <> pTargetValue: Target value
      //  <- TRUE = Converted successfully, FALSE = Not really

      lResult := FALSE;

      IF (pSourceDataType = pTargetDataType) THEN
      BEGIN
        pTargetValue := pSourceValue;
        lResult := TRUE;
      END
      ELSE
        CASE (pSourceDataType) OF
          TableFieldBuffer."Data Type"::Boolean:
            lResult := ConvertValueFromBoolean(pSourceValue, pTargetDataType, pTargetValue);
          TableFieldBuffer."Data Type"::BigInteger,
          TableFieldBuffer."Data Type"::Integer,
          TableFieldBuffer."Data Type"::Option:
            lResult := ConvertValueFromInteger(pSourceValue, pTargetDataType, pTargetValue);
          TableFieldBuffer."Data Type"::Decimal:
            lResult := ConvertValueFromDecimal(pSourceValue, pTargetDataType, pTargetValue);
          TableFieldBuffer."Data Type"::Date:
            lResult := ConvertValueFromDate(pSourceValue, pTargetDataType, pTargetValue);
          TableFieldBuffer."Data Type"::DateTime:
            lResult := ConvertValueFromDateTime(pSourceValue, pTargetDataType, pTargetValue);
          TableFieldBuffer."Data Type"::Code,
          TableFieldBuffer."Data Type"::OemCode,
          TableFieldBuffer."Data Type"::Text,
          TableFieldBuffer."Data Type"::OemText:
            lResult := TryToParse(pSourceValue, pTargetDataType, pTargetValue);
          TableFieldBuffer."Data Type"::Time,
          TableFieldBuffer."Data Type"::DateFormula,
          TableFieldBuffer."Data Type"::Duration,
          TableFieldBuffer."Data Type"::GUID,
          TableFieldBuffer."Data Type"::RecordID:
            lResult := ConvertValueByFormatting(pSourceValue, pTargetDataType, pTargetValue);
        END;

      IF ( NOT (lResult)) THEN
        ERROR(eCantConvert, DataTypeName(pSourceDataType), FORMAT(pSourceValue, 0, 1), DataTypeName(pTargetDataType));

      EXIT(lResult);
    END;

    LOCAL PROCEDURE ConvertValueFromBoolean@1000000066(pSourceValue@1000000002 : Variant;pTargetDataType@1000000001 : Integer;VAR pTargetValue@1000000000 : Variant) : Boolean;
    VAR
      lSourceValue@1000000003 : Boolean;
      lResult@1000000004 : Boolean;
    BEGIN
      //DOC NA2016.14 - Converting value from boolean to given target data type
      //  -> pSourceValue: Source value
      //  -> pTargetDataType: Target data type
      //  <> pTargetValue: Target value
      //  <- TRUE = Converted successfully, FALSE = Not really

      lSourceValue := pSourceValue;
      lResult := FALSE;

      CASE (pTargetDataType) OF
        TableFieldBuffer."Data Type"::BigInteger,
        TableFieldBuffer."Data Type"::Integer,
        TableFieldBuffer."Data Type"::Option,
        TableFieldBuffer."Data Type"::Decimal:
          BEGIN
            pTargetValue := TnpToolkit.IIFInteger(lSourceValue, 1, 0);
            lResult := TRUE;
          END;
        TableFieldBuffer."Data Type"::Code,
        TableFieldBuffer."Data Type"::OemCode,
        TableFieldBuffer."Data Type"::Text,
        TableFieldBuffer."Data Type"::OemText:
          BEGIN
            pTargetValue := FORMAT(lSourceValue, 0, 1);
            lResult := TRUE;
          END;
      END;

      EXIT(lResult);
    END;

    LOCAL PROCEDURE ConvertValueFromInteger@1000000067(pSourceValue@1000000002 : Variant;pTargetDataType@1000000001 : Integer;VAR pTargetValue@1000000000 : Variant) : Boolean;
    VAR
      lSourceValue@1000000003 : Integer;
      lResult@1000000004 : Boolean;
    BEGIN
      //DOC NA2016.14 - Converting value from integer to given target data type
      //  -> pSourceValue: Source value
      //  -> pTargetDataType: Target data type
      //  <> pTargetValue: Target value
      //  <- TRUE = Converted successfully, FALSE = Not really

      lSourceValue := pSourceValue;
      lResult := FALSE;

      CASE (pTargetDataType) OF
        TableFieldBuffer."Data Type"::Boolean:
          IF (lSourceValue IN [0, 1]) THEN
          BEGIN
            pTargetValue := (lSourceValue = 1);
            lResult := TRUE;
          END;
        TableFieldBuffer."Data Type"::BigInteger,
        TableFieldBuffer."Data Type"::Option,
        TableFieldBuffer."Data Type"::Decimal:
          BEGIN
            pTargetValue := lSourceValue;
            lResult := TRUE;
          END;
        TableFieldBuffer."Data Type"::Code,
        TableFieldBuffer."Data Type"::OemCode,
        TableFieldBuffer."Data Type"::Text,
        TableFieldBuffer."Data Type"::OemText:
          BEGIN
            pTargetValue := FORMAT(lSourceValue, 0, 1);
            lResult := TRUE;
          END;
      END;

      EXIT(lResult);
    END;

    LOCAL PROCEDURE ConvertValueFromDecimal@1000000068(pSourceValue@1000000002 : Variant;pTargetDataType@1000000001 : Integer;VAR pTargetValue@1000000000 : Variant) : Boolean;
    VAR
      lSourceValue@1000000003 : Decimal;
      lResult@1000000004 : Boolean;
    BEGIN
      //DOC NA2016.14 - Converting value from decimal to given target data type
      //  -> pSourceValue: Source value
      //  -> pTargetDataType: Target data type
      //  <> pTargetValue: Target value
      //  <- TRUE = Converted successfully, FALSE = Not really

      lSourceValue := pSourceValue;
      lResult := FALSE;

      CASE (pTargetDataType) OF
        TableFieldBuffer."Data Type"::Boolean:
          IF (lSourceValue IN [0, 1]) THEN
          BEGIN
            pTargetValue := (lSourceValue = 1);
            lResult := TRUE;
          END;
        TableFieldBuffer."Data Type"::BigInteger,
        TableFieldBuffer."Data Type"::Integer,
        TableFieldBuffer."Data Type"::Option:
          IF (ROUND(lSourceValue, 1) = lSourceValue) THEN
          BEGIN
            pTargetValue := lSourceValue;
            lResult := TRUE;
          END;
        TableFieldBuffer."Data Type"::Code,
        TableFieldBuffer."Data Type"::OemCode,
        TableFieldBuffer."Data Type"::Text,
        TableFieldBuffer."Data Type"::OemText:
          BEGIN
            pTargetValue := FORMAT(lSourceValue, 0, 1);
            lResult := TRUE;
          END;
      END;

      EXIT(lResult);
    END;

    LOCAL PROCEDURE ConvertValueFromDate@1000000070(pSourceValue@1000000002 : Variant;pTargetDataType@1000000001 : Integer;VAR pTargetValue@1000000000 : Variant) : Boolean;
    VAR
      lSourceValue@1000000003 : Date;
      lResult@1000000004 : Boolean;
    BEGIN
      //DOC NA2016.14 - Converting value from date to given target data type
      //  -> pSourceValue: Source value
      //  -> pTargetDataType: Target data type
      //  <> pTargetValue: Target value
      //  <- TRUE = Converted successfully, FALSE = Not really

      lSourceValue := pSourceValue;
      lResult := FALSE;

      CASE (pTargetDataType) OF
        TableFieldBuffer."Data Type"::DateTime:
          BEGIN
            pTargetValue := CREATEDATETIME(lSourceValue, 000000T);
            lResult := TRUE;
          END;
        TableFieldBuffer."Data Type"::Code,
        TableFieldBuffer."Data Type"::OemCode,
        TableFieldBuffer."Data Type"::Text,
        TableFieldBuffer."Data Type"::OemText:
          BEGIN
            pTargetValue := FORMAT(lSourceValue, 0, 1);
            lResult := TRUE;
          END;
      END;

      EXIT(lResult);
    END;

    LOCAL PROCEDURE ConvertValueFromDateTime@1000000071(pSourceValue@1000000002 : Variant;pTargetDataType@1000000001 : Integer;VAR pTargetValue@1000000000 : Variant) : Boolean;
    VAR
      lSourceValue@1000000003 : DateTime;
      lResult@1000000004 : Boolean;
    BEGIN
      //DOC NA2016.14 - Converting value from datetime to given target data type
      //  -> pSourceValue: Source value
      //  -> pTargetDataType: Target data type
      //  <> pTargetValue: Target value
      //  <- TRUE = Converted successfully, FALSE = Not really

      lSourceValue := pSourceValue;
      lResult := FALSE;

      CASE (pTargetDataType) OF
        TableFieldBuffer."Data Type"::Date:
          BEGIN
            pTargetValue := DT2DATE(lSourceValue);
            lResult := TRUE;
          END;
        TableFieldBuffer."Data Type"::Time:
          BEGIN
            pTargetValue := DT2TIME(lSourceValue);
            lResult := TRUE;
          END;
        TableFieldBuffer."Data Type"::Code,
        TableFieldBuffer."Data Type"::OemCode,
        TableFieldBuffer."Data Type"::Text,
        TableFieldBuffer."Data Type"::OemText:
          BEGIN
            pTargetValue := FORMAT(lSourceValue, 0, 1);
            lResult := TRUE;
          END;
      END;

      EXIT(lResult);
    END;

    LOCAL PROCEDURE ConvertValueByFormatting@1000000072(pSourceValue@1000000002 : Variant;pTargetDataType@1000000001 : Integer;VAR pTargetValue@1000000000 : Variant) : Boolean;
    VAR
      lResult@1000000004 : Boolean;
    BEGIN
      //DOC NA2016.14 - Converting value by formatting
      //  -> pSourceValue: Source value
      //  -> pTargetDataType: Target data type
      //  <> pTargetValue: Target value
      //  <- TRUE = Converted successfully, FALSE = Not really

      lResult := FALSE;

      CASE (pTargetDataType) OF
        TableFieldBuffer."Data Type"::Code,
        TableFieldBuffer."Data Type"::OemCode,
        TableFieldBuffer."Data Type"::Text,
        TableFieldBuffer."Data Type"::OemText:
          BEGIN
            pTargetValue := FORMAT(pSourceValue, 0, 1);
            lResult := TRUE;
          END;
      END;

      EXIT(lResult);
    END;

    LOCAL PROCEDURE "--- DDT ---"@1000000005();
    BEGIN
    END;

    PROCEDURE DataTypeToDdt@1000000035(pDataType@1000000000 : Integer) : Integer;
    VAR
      lDdt@1000000001 : Integer;
    BEGIN
      //DOC NA2016.12 - Converting data type to DDT (decimal / datetime / text)
      //  -> pDataType: The data type
      //  <- DDT (empty if data type not supported)

      CLEAR(lDdt);

      CASE (pDataType) OF
        TableFieldBuffer."Data Type"::Boolean,
        TableFieldBuffer."Data Type"::BigInteger,
        TableFieldBuffer."Data Type"::Integer,
        TableFieldBuffer."Data Type"::Option,
        TableFieldBuffer."Data Type"::Decimal:
          lDdt := TableFieldBuffer.DDT::Decimal;
        TableFieldBuffer."Data Type"::Date,
        TableFieldBuffer."Data Type"::Time,
        TableFieldBuffer."Data Type"::DateTime:
          lDdt := TableFieldBuffer.DDT::DateTime;
        TableFieldBuffer."Data Type"::Code,
        TableFieldBuffer."Data Type"::OemCode,
        TableFieldBuffer."Data Type"::Text,
        TableFieldBuffer."Data Type"::OemText,
        TableFieldBuffer."Data Type"::DateFormula,
        TableFieldBuffer."Data Type"::Duration,
        TableFieldBuffer."Data Type"::GUID,
        TableFieldBuffer."Data Type"::RecordID:
          lDdt := TableFieldBuffer.DDT::Text;
      END;

      EXIT(lDdt);
    END;

    PROCEDURE GetDtdValue@1000000020(pDataType@1000000011 : Integer;pDecimalValue@1000000009 : Decimal;pDateTimeValue@1000000008 : DateTime;pTextValue@1000000002 : Text;VAR pValue@1000000000 : Variant);
    VAR
      lIntegerValue@1000000004 : Integer;
      lDateFormulaValue@1000000003 : DateFormula;
      lDurationValue@1000000006 : Duration;
      lGuidValue@1000000005 : GUID;
      lRecordIdValue@1000000007 : RecordID;
    BEGIN
      //DOC NA2016.12 - Returning DDT (decimal / datetime / text) value
      //  -> pDataType: Data type
      //  -> pDecimalValue: Decimal value
      //  -> pDateTimeValue: Datetime value
      //  -> pTextValue: Text value
      //  <> pValue: Target value (variant)

      CASE (pDataType) OF
        TableFieldBuffer."Data Type"::Boolean:
          pValue := (pDecimalValue <> 0);
        TableFieldBuffer."Data Type"::BigInteger,
        TableFieldBuffer."Data Type"::Integer,
        TableFieldBuffer."Data Type"::Option:
          BEGIN
            lIntegerValue := ROUND(pDecimalValue, 1);
            pValue := lIntegerValue;
          END;
        TableFieldBuffer."Data Type"::Decimal:
          pValue := pDecimalValue;
        TableFieldBuffer."Data Type"::Date:
          pValue := DT2DATE(pDateTimeValue);
        TableFieldBuffer."Data Type"::Time:
          pValue := DT2TIME(pDateTimeValue);
        TableFieldBuffer."Data Type"::DateTime:
          pValue := pDateTimeValue;
        TableFieldBuffer."Data Type"::Code,
        TableFieldBuffer."Data Type"::Text,
        TableFieldBuffer."Data Type"::OemCode,
        TableFieldBuffer."Data Type"::OemText:
          pValue := pTextValue;
        TableFieldBuffer."Data Type"::DateFormula:
          BEGIN
            IF ( NOT (EVALUATE(lDateFormulaValue, pTextValue))) THEN
              CLEAR(lDateFormulaValue);
            pValue := lDateFormulaValue;
          END;
        TableFieldBuffer."Data Type"::Duration:
          BEGIN
            IF ( NOT (EVALUATE(lDurationValue, pTextValue))) THEN
              CLEAR(lDurationValue);
            pValue := lDurationValue;
          END;
        TableFieldBuffer."Data Type"::GUID:
          BEGIN
            IF ( NOT (EVALUATE(lGuidValue, pTextValue))) THEN
              CLEAR(lGuidValue);
            pValue := lGuidValue;
          END;
        TableFieldBuffer."Data Type"::RecordID:
          BEGIN
            IF ( NOT (EVALUATE(lRecordIdValue, pTextValue))) THEN
              CLEAR(lRecordIdValue);
            pValue := lRecordIdValue;
          END;
        ELSE
          BEGIN
            TableFieldBuffer."Data Type" := pDataType;
            ERROR(tDataTypeNotSupported, TableFieldBuffer."Data Type");
          END;
      END;
    END;

    PROCEDURE FormatDdt@1000000021(pDataType@1000000003 : Integer;VAR pDecimalValue@1000000002 : Decimal;VAR pDateTimeValue@1000000001 : DateTime;VAR pTextValue@1000000000 : Text) : Text;
    VAR
      lValue@1000000004 : Variant;
    BEGIN
      //DOC NA2016.12 - Formatting DDT (decimal / datetime / text) to text
      //  -> pDataType: Data type
      //  -> pDecimalValue: Decimal value
      //  -> pDateTimeValue: Datetime value
      //  -> pTextValue: Text value
      //  <- Text value

      GetDtdValue(pDataType, pDecimalValue, pDateTimeValue, pTextValue, lValue);
      EXIT(FORMAT(lValue, 0, 1));
    END;

    PROCEDURE ParseToDdt@1000000009(pText@1000000000 : Text;pDataType@1000000001 : Integer;VAR pDecimalValue@1000000002 : Decimal;VAR pDateTimeValue@1000000003 : DateTime;VAR pTextValue@1000000004 : Text);
    VAR
      lValue@1000000006 : Variant;
      eActivity@1000000007 : TextConst 'ENU=DDT parsing;ENG=DDT parsing';
    BEGIN
      //DOC NA2016.12 - Parsing text to DDT (decimal / dateTime / text) value
      //  -> pText: Text
      //  -> pDataType: Data type
      //  <> pDecimalValue: Target decimal value
      //  <> pDateTimeValue: Target datetime value
      //  <> pTextValue: Target text value

      Parse(pText, pDataType, lValue);

      CASE (pDataType) OF
        TableFieldBuffer."Data Type"::Boolean:
          pDecimalValue := TnpToolkit.IIFDecimal(lValue, 1, 0);
        TableFieldBuffer."Data Type"::BigInteger,
        TableFieldBuffer."Data Type"::Integer,
        TableFieldBuffer."Data Type"::Option,
        TableFieldBuffer."Data Type"::Decimal:
          pDecimalValue := lValue;
        TableFieldBuffer."Data Type"::Code,
        TableFieldBuffer."Data Type"::OemCode,
        TableFieldBuffer."Data Type"::Text,
        TableFieldBuffer."Data Type"::OemText:
          pTextValue := lValue;
        TableFieldBuffer."Data Type"::Date:
          pDateTimeValue := CREATEDATETIME(lValue, 000000T);
        TableFieldBuffer."Data Type"::Time:
          pDateTimeValue := CREATEDATETIME(DMY2DATE(1, 1, 1900), lValue);
        TableFieldBuffer."Data Type"::DateTime:
          pDateTimeValue := lValue;
        TableFieldBuffer."Data Type"::DateFormula,
        TableFieldBuffer."Data Type"::Duration,
        TableFieldBuffer."Data Type"::GUID,
        TableFieldBuffer."Data Type"::RecordID:
          pTextValue := FORMAT(lValue, 0, 2);
        ELSE
          ERROR(tDataTypeNotSupported, DataTypeName(pDataType), eActivity);
      END;
    END;

    [TryFunction]
    PROCEDURE TryToParseToDdt@1000000010(pText@1000000005 : Text;pDataType@1000000004 : Integer;VAR pDecimalValue@1000000002 : Decimal;VAR pDateTimeValue@1000000001 : DateTime;VAR pTextValue@1000000000 : Text);
    BEGIN
      //DOC NA2016.12 - Parsing text to DDT (Decimal / DateTime / Text) value
      //  -> pText: Text
      //  -> pDataType: Data type
      //  <> pDecimalValue: Target decimal value
      //  <> pDateTimeValue: Target datetime value
      //  <> pTextValue: Target text value

      ParseToDdt(pText, pDataType, pDecimalValue, pDateTimeValue, pTextValue);
    END;

    LOCAL PROCEDURE "--- Tools ---"@1000000001();
    BEGIN
    END;

    LOCAL PROCEDURE DataTypeName@1000000003(pDataType@1000000000 : Integer) : Text;
    VAR
      lTableFieldBuffer@1000000001 : Record 9062231;
    BEGIN
      //DOC NA2016.12 - Returning data type name
      //  -> pDataType: The data type
      //  <- The name

      lTableFieldBuffer."Data Type" := pDataType;
      EXIT(FORMAT(lTableFieldBuffer."Data Type"));
    END;

    BEGIN
    {
      //DOC NA2016.12 JH 15/01/2016 - Created
      //DOC NA2016.12 JH 28/01/2016 - New string codeunit
      //DOC NA2016.14 JH 29/02/2016 - Fixes, "Safe" functions
      //DOC NA2016.14 JH 14/03/2016 - Bugfixes
    }
    END.
  }
}

