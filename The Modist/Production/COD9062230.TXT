OBJECT Codeunit 9062230 TNP Toolkit
{
  OBJECT-PROPERTIES
  {
    Date=02/03/16;
    Time=12:00:00 PM;
    Version List=NA2016.14;
  }
  PROPERTIES
  {
    OnRun=BEGIN
          END;

  }
  CODE
  {
    VAR
      mActiveSession@1000000005 : Record 2000000110;
      mAllObjWithCaption@1000000004 : Record 2000000058;
      mField@1000000003 : Record 2000000041;
      mGeneralLedgerSetup@1000000001 : Record 98;
      mObject@1000000002 : Record 2000000058;
      String@1000000006 : Codeunit 9062236;
      XmlToolkit@1000000007 : Codeunit 9062641;
      mDateTimePart@1000000000 : ' ,Year,Month,Day,Hour,Minute,Second';

    PROCEDURE "--- Client Type ---"@1000000128();
    BEGIN
    END;

    PROCEDURE GetClientType@1000000131() : Integer;
    VAR
      lClientType@1000000002 : Integer;
    BEGIN
      //DOC NA2016.10 - Returning if we are working on client side at the moment
      //  <- TRUE = client side, FALSE = server side

      lClientType := mActiveSession."Client Type"::Unknown;

      IF (mActiveSession.GET(SERVICEINSTANCEID(), SESSIONID())) THEN
        lClientType := mActiveSession."Client Type";

      EXIT(lClientType);
    END;

    PROCEDURE IsWindowsClient@1000000134() : Boolean;
    BEGIN
      //DOC NA2016.10 - Returning if we are working with windows client
      //  <- Result

      EXIT(GetClientType() = mActiveSession."Client Type"::"Windows Client");
    END;

    PROCEDURE IsWebClient@1000000135() : Boolean;
    BEGIN
      //DOC NA2016.10 - Returning if we are working with web client
      //  <- Result

      EXIT(GetClientType() IN [mActiveSession."Client Type"::"Web Client", mActiveSession."Client Type"::Tablet,
        mActiveSession."Client Type"::Phone]);
    END;

    PROCEDURE WindowsVsWebClient@1000000139(VAR pWindowsClient@1000000000 : Boolean;VAR pWebClient@1000000001 : Boolean);
    VAR
      lClientType@1000000002 : Integer;
    BEGIN
      //DOC NA2015.4 - Setting two variables windows client / web client
      //  <> pWindowsClient: Target "Windows Client" flag
      //  <> pWebClient: Target "web client" flag

      lClientType := GetClientType();

      pWindowsClient := (mActiveSession."Client Type" = mActiveSession."Client Type"::"Windows Client");
      pWebClient := (mActiveSession."Client Type" = mActiveSession."Client Type"::"Web Client");
    END;

    PROCEDURE ClientSideDotNetAvailable@1000000032() : Boolean;
    BEGIN
      EXIT(IsWindowsClient());
    END;

    PROCEDURE "--- Created / Modified By ---"@1000000066();
    BEGIN
    END;

    PROCEDURE UpdateCreatedBy@1000000002(VAR pCreatedBy@1000000000 : Code[50];VAR pCreatedDateTime@1000000001 : DateTime);
    BEGIN
      //DOC NA2015.1 - Updating "Created By" fields
      //  <> pCreatedBy: Source / target "Created By"
      //  <> pCreatedDateTime: Source / target "Created Date Time"

      IF (pCreatedBy = '') THEN
        pCreatedBy := USERID();

      IF (pCreatedDateTime = 0DT) THEN
        pCreatedDateTime := CURRENTDATETIME();
    END;

    PROCEDURE UpdateModifiedBy@1000000003(VAR pModifiedBy@1000000001 : Code[50];VAR pModifiedDateTime@1000000000 : DateTime);
    BEGIN
      //DOC NA2015.1 - Updating "Created By" fields
      //  <> pModifiedBy: Target "Modified By"
      //  <> pModifiedDateTime: Target "Modified Date Time"

      pModifiedBy := USERID();
      pModifiedDateTime := CURRENTDATETIME();
    END;

    PROCEDURE "--- User Validation / Lookup ---"@1000000107();
    BEGIN
    END;

    PROCEDURE UserValidate@1000000106(pUserId@1000000000 : Code[50]);
    VAR
      lUserManagement@1000000001 : Codeunit 418;
    BEGIN
      //DOC NA2015.1 - Validating user
      //  <> pUserId: User ID to validate

      lUserManagement.ValidateUserID(pUserId);
    END;

    PROCEDURE UserLookup@1000000105(VAR pUserId@1000000000 : Code[50];pEditable@1000000001 : Boolean);
    VAR
      lUserManagement@1000000002 : Codeunit 418;
    BEGIN
      //DOC NA2015.1 - Performing user lookup
      //  <> pUserId: User ID to run lookup for (if editable - can be updated)
      //  -> pEditable; If the lookup should be editable and allow user update

      lUserManagement.LookupUserID(pUserId);
    END;

    PROCEDURE "--- Default ---"@1000000048();
    BEGIN
    END;

    PROCEDURE DefaultInteger@1000000049(VAR pValue@1000000001 : Integer;pDefaultValue@1000000000 : Integer) : Integer;
    BEGIN
      //DOC NA2015.1 - Defaulting integer to another value if empty
      //  <> pValue: Current / target value
      //  -> pDefaultValue: Default value
      //  <- Value or default value if empty

      IF (pValue = 0) THEN
        pValue := pDefaultValue;

      EXIT(pValue)
    END;

    PROCEDURE DefaultDecimal@1000000050(VAR pValue@1000000001 : Decimal;pDefaultValue@1000000000 : Decimal) : Decimal;
    BEGIN
      //DOC NA2015.1 - Defaulting integer to another value if empty
      //  <> pValue: Current / target value
      //  -> pDefaultValue: Default value
      //  <- Value or default value if empty

      IF (pValue = 0) THEN
        pValue := pDefaultValue;

      EXIT(pValue)
    END;

    PROCEDURE DefaultString@1000000038(VAR pValue@1190000012 : Text;pDefaultValue@1190000013 : Text) : Text;
    BEGIN
      //DOC NA2015.3 - Defaulting string to another value if empty
      //  <> pValue: Current / target value
      //  -> pDefaultValue: Default value
      //  <- Value or default value if empty

      IF (pValue = '') THEN
        pValue := pDefaultValue;

      EXIT(pValue)
    END;

    PROCEDURE DefaultCode@1000000041(VAR pValue@1190000012 : Code[1024];pDefaultValue@1190000013 : Code[1024]) : Code[1024];
    BEGIN
      //DOC NA2015.1 - Defaulting code to another value if empty
      //  <> pValue: Current / target value
      //  -> pDefaultValue: Default value
      //  <- Value or default value if empty

      IF (pValue = '') THEN
        pValue := pDefaultValue;

      EXIT(pValue)
    END;

    PROCEDURE DefaultDate@1000000051(VAR pValue@1000000001 : Date;pDefaultValue@1000000000 : Date) : Date;
    BEGIN
      //DOC NA2015.1 - Defaulting integer to another value if empty
      //  <> pValue: Current / target value
      //  -> pDefaultValue: Default value
      //  <- Value or default value if empty

      IF (pValue = 0D) THEN
        pValue := pDefaultValue;

      EXIT(pValue)
    END;

    PROCEDURE DefaultTime@1000000052(VAR pValue@1000000001 : Time;pDefaultValue@1000000000 : Time) : Time;
    BEGIN
      //DOC NA2015.1 - Defaulting integer to another value if empty
      //  <> pValue: Current / target value
      //  -> pDefaultValue: Default value
      //  <- Value or default value if empty

      IF (pValue = 0T) THEN
        pValue := pDefaultValue;

      EXIT(pValue)
    END;

    PROCEDURE DefaultDateTime@1000000053(VAR pValue@1000000001 : DateTime;pDefaultValue@1000000000 : DateTime) : DateTime;
    BEGIN
      //DOC NA2015.1 - Defaulting integer to another value if empty
      //  <> pValue: Current / target value
      //  -> pDefaultValue: Default value
      //  <- Value or default value if empty

      IF (pValue = 0DT) THEN
        pValue := pDefaultValue;

      EXIT(pValue)
    END;

    PROCEDURE "--- Type Conversion ---"@1000000057();
    BEGIN
    END;

    PROCEDURE ToBoolean@1000000058(pTextValue@1000000000 : Text;pError@1000000002 : Boolean) : Boolean;
    VAR
      lBooleanValue@1000000001 : Boolean;
    BEGIN
      //DOC NA2015.3 - Converting text value to boolean
      //  -> pTextValue: Text value
      //  -> pError: TRUE: Raise an error if conversion is impossible, FALSE: Use default value
      //  <- Boolean

      IF (pError) THEN
        EVALUATE(lBooleanValue, pTextValue)
      ELSE
        IF ( NOT (EVALUATE(lBooleanValue, pTextValue))) THEN
          lBooleanValue := FALSE;

      EXIT(lBooleanValue);
    END;

    PROCEDURE ToInteger@1000000068(pTextValue@1000000000 : Text;pError@1000000002 : Boolean) : Integer;
    VAR
      lIntegerValue@1000000001 : Integer;
    BEGIN
      //DOC NA2015.3 - Converting text value to integer
      //  -> pTextValue: Text value
      //  -> pError: TRUE: Raise an error if conversion is impossible, FALSE: Use default value
      //  <- Integer

      IF (pError) THEN
        EVALUATE(lIntegerValue, pTextValue)
      ELSE
        IF ( NOT (EVALUATE(lIntegerValue, pTextValue))) THEN
          lIntegerValue := 0;

      EXIT(lIntegerValue);
    END;

    PROCEDURE ToDecimal@1000000067(pTextValue@1000000000 : Text;pError@1000000002 : Boolean) : Decimal;
    VAR
      lDecimalValue@1000000001 : Decimal;
    BEGIN
      //DOC NA2015.3 - Converting text value to decimal
      //  -> pTextValue: Text value
      //  -> pError: TRUE: Raise an error if conversion is impossible, FALSE: Use default value
      //  <- Decimal

      IF (pError) THEN
        EVALUATE(lDecimalValue, pTextValue)
      ELSE
        IF ( NOT (EVALUATE(lDecimalValue, pTextValue))) THEN
          lDecimalValue := 0;

      EXIT(lDecimalValue);
    END;

    PROCEDURE ToDate@1000000073(pTextValue@1000000000 : Text;pError@1000000002 : Boolean) : Date;
    VAR
      lDateValue@1000000001 : Date;
    BEGIN
      //DOC NA2015.3 - Converting text value to date
      //  -> pTextValue: Text value
      //  -> pError: TRUE: Raise an error if conversion is impossible, FALSE: Use default value
      //  <- Date

      IF (pError) THEN
        EVALUATE(lDateValue, pTextValue)
      ELSE
        IF ( NOT (EVALUATE(lDateValue, pTextValue))) THEN
          lDateValue := 0D;

      EXIT(lDateValue);
    END;

    PROCEDURE ToTime@1000000072(pTextValue@1000000000 : Text;pError@1000000002 : Boolean) : Time;
    VAR
      lTimeValue@1000000001 : Time;
    BEGIN
      //DOC NA2015.3 - Converting text value to time
      //  -> pTextValue: Text value
      //  -> pError: TRUE: Raise an error if conversion is impossible, FALSE: Use default value
      //  <- Time

      IF (pError) THEN
        EVALUATE(lTimeValue, pTextValue)
      ELSE
        IF ( NOT (EVALUATE(lTimeValue, pTextValue))) THEN
          lTimeValue := 0T;

      EXIT(lTimeValue);
    END;

    PROCEDURE ToDateTime@1000000071(pTextValue@1000000000 : Text;pError@1000000002 : Boolean) : DateTime;
    VAR
      lDateTimeValue@1000000001 : DateTime;
    BEGIN
      //DOC NA2015.3 - Converting text value to datetime
      //  -> pTextValue: Text value
      //  -> pError: TRUE: Raise an error if conversion is impossible, FALSE: Use default value
      //  <- Datetime

      IF (pError) THEN
        EVALUATE(lDateTimeValue, pTextValue)
      ELSE
        IF ( NOT (EVALUATE(lDateTimeValue, pTextValue))) THEN
          lDateTimeValue := 0DT;

      EXIT(lDateTimeValue);
    END;

    PROCEDURE ToVariant@1000000079(pTextValue@1000000000 : Text;pFieldType@1000000010 : Integer;pError@1000000001 : Boolean;VAR pVariantValue@1000000002 : Variant);
    VAR
      tlTypeNotSupported@1000000009 : TextConst 'ENU=Type "%1" is not supported for automatic conversion.;ENG=Type "%1" is not supported for automatic conversion.';
    BEGIN
      //DOC NA2015.3 - Converting text to specified type and then to variant
      //  -> pTextValue: Text value
      //  -> pFieldType: Field type
      //  -> pError: TRUE: Raise an error if conversion is impossible, FALSE: Use default value
      //  <> pVariant: Target variant

      CASE (pFieldType) OF
        mField.Type::Boolean:
          pVariantValue := ToBoolean(pTextValue, pError);
        mField.Type::Integer,
        mField.Type::Option:
          pVariantValue := ToInteger(pTextValue, pError);
        mField.Type::Decimal:
          pVariantValue := ToDecimal(pTextValue, pError);
        mField.Type::OemCode,
        mField.Type::OemText:
          pVariantValue := pTextValue;
        mField.Type::Date:
          pVariantValue := ToDate(pTextValue, pError);
        mField.Type::Time:
          pVariantValue := ToTime(pTextValue, pError);
        mField.Type::DateTime:
          pVariantValue := ToDateTime(pTextValue, pError);
        ELSE
          BEGIN
            mField.Type := pFieldType;
            ERROR(tlTypeNotSupported, FORMAT(mField.Type));
          END;
      END;
    END;

    PROCEDURE "--- Math ---"@1000000056();
    BEGIN
    END;

    PROCEDURE Divide@1000000054(pValue1@1000000001 : Decimal;pValue2@1000000000 : Decimal) : Decimal;
    BEGIN
      //DOC NA2015.1 - Zero-secure dividing
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- pValue1 divided by pValue2

      IF (pValue2 <> 0) THEN
        EXIT(pValue1 / pValue2)
      ELSE
        EXIT(0);
    END;

    PROCEDURE MinInteger@1000000031(pValue1@1000000000 : Integer;pValue2@1000000001 : Integer) : Integer;
    BEGIN
      //DOC NA2015.1 - Returning minimum integer of two
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- Minimum

      IF (pValue1 < pValue2) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE MaxInteger@1000000008(pValue1@1000000000 : Integer;pValue2@1000000001 : Integer) : Integer;
    BEGIN
      //DOC NA2015.1 - Returning maximum integer of two
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- Minimum

      IF (pValue1 >= pValue2) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE MinDecimal@1000000001(pValue1@1000000001 : Decimal;pValue2@1000000000 : Decimal) : Decimal;
    BEGIN
      //DOC NA2015.1 - Returning minimum decimal of two
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- Minimum

      IF (pValue1 < pValue2) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE MaxDecimal@1000000009(pValue1@1000000001 : Decimal;pValue2@1000000000 : Decimal) : Decimal;
    BEGIN
      //DOC NA2015.1 - Returning maximum decimal of two
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- Minimum

      IF (pValue1 >= pValue2) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE MinDate@1000000000(pValue1@1000000001 : Date;pValue2@1000000000 : Date) : Date;
    BEGIN
      //DOC NA2015.1 - Returning minimum date of two
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- Minimum

      IF (pValue1 < pValue2) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE MaxDate@1000000010(pValue1@1000000001 : Date;pValue2@1000000000 : Date) : Date;
    BEGIN
      //DOC NA2015.1 - Returning maximum date of two
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- Minimum

      IF (pValue1 >= pValue2) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE MinTime@1000000004(pValue1@1000000001 : Time;pValue2@1000000000 : Time) : Time;
    BEGIN
      //DOC NA2015.1 - Returning minimum time of two
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- Minimum

      IF (pValue1 < pValue2) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE MaxTime@1000000011(pValue1@1000000001 : Time;pValue2@1000000000 : Time) : Time;
    BEGIN
      //DOC NA2015.1 - Returning maximum time of two
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- Minimum

      IF (pValue1 >= pValue2) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE MinDateTime@1000000005(pValue1@1000000001 : DateTime;pValue2@1000000000 : DateTime) : DateTime;
    BEGIN
      //DOC NA2015.1 - Returning minimum datetime of two
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- Minimum

      IF (pValue1 < pValue2) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE MaxDateTime@1000000012(pValue1@1000000001 : DateTime;pValue2@1000000000 : DateTime) : DateTime;
    BEGIN
      //DOC NA2015.1 - Returning maximum datetime of two
      //  -> pValue1: First value
      //  -> pValue2: Second value
      //  <- Minimum

      IF (pValue1 >= pValue2) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE "--- IIF ---"@1000000018();
    BEGIN
    END;

    PROCEDURE IIFBoolean@1000000026(pCondition@1000000000 : Boolean;pValue1@1000000001 : Boolean;pValue2@1000000002 : Boolean) : Boolean;
    BEGIN
      //DOC NA2015.1 - Returning first value if condition = TRUE, second if condition = FALSE
      //  -> pCondition: Condition
      //  -> pValue1, pValue2: Values
      //  <- Returned value

      IF (pCondition) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE IIFInteger@1000000020(pCondition@1000000000 : Boolean;pValue1@1000000002 : Integer;pValue2@1000000001 : Integer) : Integer;
    BEGIN
      //DOC NA2015.1 - Returning first value if condition = TRUE, second if condition = FALSE
      //  -> pCondition: Condition
      //  -> pValue1, pValue2: Values
      //  <- Returned value

      IF (pCondition) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE IIFDecimal@1000000021(pCondition@1000000002 : Boolean;pValue1@1000000001 : Decimal;pValue2@1000000000 : Decimal) : Decimal;
    BEGIN
      //DOC NA2015.1 - Returning first value if condition = TRUE, second if condition = FALSE
      //  -> pCondition: Condition
      //  -> pValue1, pValue2: Values
      //  <- Returned value

      IF (pCondition) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE IIFText@1000000025(pCondition@1000000002 : Boolean;pValue1@1000000001 : Text;pValue2@1000000000 : Text) : Text;
    BEGIN
      //DOC NA2015.3 - Returning first value if condition = TRUE, second if condition = FALSE
      //  -> pCondition: Condition
      //  -> pValue1, pValue2: Values
      //  <- Returned value

      IF (pCondition) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE IIFDate@1000000022(pCondition@1000000002 : Boolean;pValue1@1000000001 : Date;pValue2@1000000000 : Date) : Date;
    BEGIN
      //DOC NA2015.1 - Returning first value if condition = TRUE, second if condition = FALSE
      //  -> pCondition: Condition
      //  -> pValue1, pValue2: Values
      //  <- Returned value

      IF (pCondition) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE IIFTime@1000000023(pCondition@1000000002 : Boolean;pValue1@1000000001 : Time;pValue2@1000000000 : Time) : Time;
    BEGIN
      //DOC NA2015.1 - Returning first value if condition = TRUE, second if condition = FALSE
      //  -> pCondition: Condition
      //  -> pValue1, pValue2: Values
      //  <- Returned value

      IF (pCondition) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE IIFDateTime@1000000024(pCondition@1000000002 : Boolean;pValue1@1000000001 : DateTime;pValue2@1000000000 : DateTime) : DateTime;
    BEGIN
      //DOC NA2015.1 - Returning first value if condition = TRUE, second if condition = FALSE
      //  -> pCondition: Condition
      //  -> pValue1, pValue2: Values
      //  <- Returned value

      IF (pCondition) THEN
        EXIT(pValue1)
      ELSE
        EXIT(pValue2);
    END;

    PROCEDURE "--- Inc / Dec ---"@1000000111();
    BEGIN
    END;

    PROCEDURE Inc@1000000112(VAR pValue@1000000000 : Integer) : Integer;
    BEGIN
      //DOC NA2015.1 - Incrementing and returning a value
      //  <> pValue: Value
      //  <- Incremented value

      pValue += 1;
      EXIT(pValue);
    END;

    PROCEDURE IncPrev@1000000113(VAR pValue@1000000000 : Integer) : Integer;
    VAR
      lValue@1000000001 : Integer;
    BEGIN
      //DOC NA2015.1 - Incrementing a value and returning previous value
      //  <> pValue: Value
      //  <- Previous value

      lValue := pValue;
      pValue += 1;
      EXIT(lValue);
    END;

    PROCEDURE Dec@1000000114(VAR pValue@1000000000 : Integer) : Integer;
    BEGIN
      //DOC NA2015.1 - Derementing and returning a value
      //  <> pValue: Value
      //  <- Decremented value

      pValue -= 1;
      EXIT(pValue);
    END;

    PROCEDURE DecPrev@1000000115(VAR pValue@1000000000 : Integer) : Integer;
    VAR
      lValue@1000000001 : Integer;
    BEGIN
      //DOC NA2015.1 - Incrementing a value and returning previous value
      //  <> pValue: Value
      //  <- Previous value

      lValue := pValue;
      pValue -= 1;
      EXIT(lValue);
    END;

    PROCEDURE "--- Position and Filtering ---"@1190000021();
    BEGIN
    END;

    PROCEDURE AddToPosition@1000000034(VAR pPosition@1000000000 : Text;pTableId@1000000001 : Integer;pFieldId@1000000002 : Integer;pFieldValue@1000000003 : Text);
    VAR
      tField@1000000004 : TextConst 'ENU="""%1"": %2";ENG="""%1"": %2"';
    BEGIN
      //DOC NA2015.3 - Adding another part to record position
      //  <> pPosition: Source / target position
      //  -> pTableId: Table ID
      //  -> pFieldId: Field ID
      //  -> pFieldValue: Field value

      IF (pPosition <> '') THEN
        pPosition := pPosition + ', ';

      pPosition := pPosition + STRSUBSTNO(tField, GetFieldCaption(pTableId, pFieldId), pFieldValue);
    END;

    PROCEDURE AddToFilter@1190000019(VAR pFilter@1190000009 : Code[1024];pID@1190000010 : Integer) : Code[1024];
    BEGIN
      //DOC NA2015.1 - Adding another ID to filter
      //  <> pFilter: Filter to add to
      //  -> pID: Identifier to add
      //  <- Final filter

      IF (pID = 0) THEN
        EXIT;

      IF (pFilter <> '') THEN
        pFilter := pFilter + '|';
      pFilter := pFilter + FORMAT(pID);

      EXIT(pFilter);
    END;

    PROCEDURE ArrayOfBooleansToOptionFilter@1000000007(pArray@1000000000 : ARRAY [10] OF Boolean;pArrayLength@1000000004 : Integer;pZeroBased@1000000001 : Boolean) : Code[1024];
    VAR
      lFilter@1000000002 : Code[100];
      lIdx@1000000003 : Integer;
      lAllTrue@1000000005 : Boolean;
      lAllFalse@1000000007 : Boolean;
      lDifference@1000000006 : Integer;
    BEGIN
      //DOC NA2015.1 - Converting array of booleans to option filter
      //  -> pArray: Array
      //  -> pArrayLength: Array length
      //  -> pZeroBased: TRUE: Array keeps values from index 0, FALSE: from index 1
      //  <- Filter

      IF (pZeroBased) THEN
        lDifference := 1
      ELSE
        lDifference := 0;

      lAllTrue := FALSE;
      lAllFalse := TRUE;
      FOR lIdx := 1 TO pArrayLength DO
      BEGIN
        IF (pArray[lIdx]) THEN
        BEGIN
          lAllFalse := FALSE;
          IF (lFilter <> '') THEN
            lFilter := lFilter + '|';
          lFilter := lFilter + FORMAT(lIdx - lDifference);
        END
        ELSE
          lAllTrue := FALSE;
      END;

      IF (lAllTrue) THEN
        lFilter := '';
      IF (lAllFalse) THEN
        lFilter := '0&1';

      EXIT(lFilter);
    END;

    PROCEDURE CombineFilters@1000000017(pFilter1@1000000000 : Text;pFilter2@1000000001 : Text;pAnd@1000000003 : Boolean) : Text;
    VAR
      lFilter@1000000002 : Text[1024];
      tlCombinedFilter@1000000004 : TextConst 'ENU=(%1)%2(%3);ENG=(%1)%2(%3)';
      lOperator@1000000005 : Code[1];
    BEGIN
      //DOC NA2015.3 - Combining filters
      //  -> pFilter1: First filter
      //  -> pFilter2: Second filter
      //  -> pAnd: TRUE: Use 'and', FALSE: Use 'or'
      //  <- Combined filter

      IF (pAnd) THEN
        lOperator := '&'
      ELSE
        lOperator := '|';

      IF ((pFilter1 <> '') AND (pFilter2 <> '')) THEN
        lFilter := STRSUBSTNO(tlCombinedFilter, pFilter1, lOperator, pFilter2)
      ELSE IF (pFilter1 <> '') THEN
        lFilter := pFilter1
      ELSE
        lFilter := pFilter2;

      EXIT(lFilter);
    END;

    PROCEDURE "--- Currency ---"@1190000022();
    BEGIN
    END;

    PROCEDURE FCYToLCY@1190000023(pFCYValue@1190000012 : Decimal;pCurrencyCode@1190000013 : Code[10];pCurrencyFactor@1190000014 : Decimal) : Decimal;
    VAR
      lLCYValue@1190000015 : Decimal;
    BEGIN
      //DOC NA2015.1 - Converting FCY value to LCY value
      //  -> pFCYValue: FCY value to convert
      //  -> pCurrencyCode: Currency code
      //  -> pCurrencyFactor: Currency factor
      //  <- LCY value

      mGeneralLedgerSetup.GET();

      IF (pCurrencyCode IN ['', mGeneralLedgerSetup."LCY Code"]) THEN
        lLCYValue := pFCYValue
      ELSE
      BEGIN
        IF (pCurrencyFactor = 0) THEN
          pCurrencyFactor := 1;
        lLCYValue := pFCYValue / pCurrencyFactor;
      END;

      EXIT(lLCYValue);
    END;

    PROCEDURE LCYToFCY@1190000024(pLCYValue@1190000014 : Decimal;pCurrencyCode@1190000013 : Code[10];pCurrencyFactor@1190000012 : Decimal) : Decimal;
    VAR
      lFCYValue@1190000015 : Decimal;
    BEGIN
      //DOC NA2015.1 - Converting LCY value to FCY value
      //  -> pFCYValue: LCY value to convert
      //  -> pCurrencyCode: Currency code
      //  -> pCurrencyFactor: Currency factor
      //  <- FCY value

      mGeneralLedgerSetup.GET();

      IF (pCurrencyCode IN ['', mGeneralLedgerSetup."LCY Code"]) THEN
        lFCYValue := pLCYValue
      ELSE
      BEGIN
        IF (pCurrencyFactor = 0) THEN
          pCurrencyFactor := 1;
        lFCYValue := pLCYValue * pCurrencyFactor;
      END;

      EXIT(lFCYValue);
    END;

    PROCEDURE "--- Formatting ---"@1000000013();
    BEGIN
    END;

    PROCEDURE IntegerWithLeadingZeros@1000000014(pInteger@1000000000 : Integer;pLength@1000000001 : Integer) : Text[250];
    VAR
      lString@1000000002 : Text[250];
      lLength@1000000004 : Integer;
      lNegative@1000000003 : Boolean;
    BEGIN
      //DOC NA2015.1 - Returning integer with leading zeros
      //  -> pInteger: The integer
      //  -> pLength: Length
      //  <- Formatted integer with leading zeros

      IF (pInteger < 0) THEN
      BEGIN
        lNegative := TRUE;
        pInteger := -pInteger;
      END;

      lString := FORMAT(pInteger);
      lLength := STRLEN(lString);
      IF (lNegative) THEN
        lLength += 1;

      IF (lLength < pLength) THEN
        lString := PADSTR('0', pLength - lLength ,'0') + lString;

      IF (lNegative) THEN
        lString := '-' + lString;

      EXIT(lString);
    END;

    LOCAL PROCEDURE IntegerToStringWithZeros@1000000040(pInteger@1190000009 : Integer;pLength@1190000010 : Integer) : Text;
    VAR
      lInteger@1190000011 : Text[1024];
      lFiller@1190000012 : Text[1024];
    BEGIN
      //DOC NA2015.3 - Converting integer to string with zeros
      //  -> pInteger: Integer value
      //  -> pLength: Length of final string
      //  <- String

      lInteger := FORMAT(pInteger);
      IF (STRLEN(lInteger) < pLength) THEN
        lFiller := PADSTR('', pLength - STRLEN(lInteger), '0');

      EXIT(lFiller + lInteger);
    END;

    PROCEDURE "--- Tables and Fields ---"@1000000015();
    BEGIN
    END;

    PROCEDURE GetTableName@1000000016(pTableId@1000000000 : Integer) : Text[50];
    BEGIN
      //DOC NA2015.1 - Returning table name
      //  -> pTableId: Table ID
      //  <- Table name

      mObject.RESET();
      mObject.SETRANGE("Object Type", mObject."Object Type"::Table);
      mObject.SETRANGE("Object ID", pTableId);
      IF ( NOT (mObject.FINDFIRST())) THEN
        CLEAR(mObject);

      EXIT(mObject."Object Name");
    END;

    PROCEDURE GetTableCaption@1000000028(pTableId@1000000000 : Integer) : Text[100];
    BEGIN
      //DOC NA2015.1 - Returning table caption
      //  -> pTableId: Table ID
      //  <- Table caption

      mAllObjWithCaption.RESET();
      mAllObjWithCaption.SETRANGE("Object Type", mObject."Object Type"::Table);
      mAllObjWithCaption.SETRANGE("Object ID", pTableId);
      IF ( NOT (mAllObjWithCaption.FINDFIRST())) THEN
        CLEAR(mAllObjWithCaption);

      EXIT(mAllObjWithCaption."Object Caption");
    END;

    PROCEDURE GetFieldName@1000000029(pTableId@1000000000 : Integer;pFieldId@1000000001 : Integer) : Text[50];
    BEGIN
      //DOC NA2015.1 - Returning field name
      //  -> pTableId: Table ID
      //  -> pFieldId: Field ID
      //  <- Field name

      mField.RESET();
      mField.SETRANGE(TableNo, pTableId);
      mField.SETRANGE("No.", pFieldId);
      IF ( NOT (mField.FINDFIRST())) THEN
        CLEAR(mField);

      EXIT(mField.FieldName);
    END;

    PROCEDURE GetFieldCaption@1000000030(pTableId@1000000002 : Integer;pFieldId@1000000001 : Integer) : Text[100];
    BEGIN
      //DOC NA2015.1 - Returning field caption
      //  -> pTableId: Table ID
      //  -> pFieldId: Field ID
      //  <- Field caption

      mField.RESET();
      mField.SETRANGE(TableNo, pTableId);
      mField.SETRANGE("No.", pFieldId);
      IF ( NOT (mField.FINDFIRST())) THEN
        CLEAR(mField);

      EXIT(mField."Field Caption");
    END;

    PROCEDURE GetFieldType@1000000078(pTableId@1000000002 : Integer;pFieldId@1000000001 : Integer) : Integer;
    BEGIN
      //DOC NA2015.1 - Returning field type
      //  -> pTableId: Table ID
      //  -> pFieldId: Field ID
      //  <- Field type

      mField.RESET();
      mField.SETRANGE(TableNo, pTableId);
      mField.SETRANGE("No.", pFieldId);
      IF ( NOT (mField.FINDFIRST())) THEN
        CLEAR(mField);

      EXIT(mField.Type);
    END;

    PROCEDURE ObjectIdLookup@1000000035(pObjectType@1000000000 : Integer;VAR pObjectId@1000000001 : Integer) : Boolean;
    VAR
      lResult@1000000002 : Boolean;
    BEGIN
      //DOC NA2015.1 - Lookup for object ID
      //  -> pObjectType: Object type
      //  <> pObjectId: Source / target object ID
      //  <- Lookup result

      mObject.RESET();
      mObject.FILTERGROUP(2);
      mObject.SETRANGE("Object Type", pObjectType);
      mObject.FILTERGROUP(0);
      IF (pObjectId <> 0) THEN
      BEGIN
        mObject.SETRANGE("Object ID", pObjectId);
        IF (mObject.FINDFIRST()) THEN;
        mObject.SETRANGE("Object ID");
      END;
      IF (PAGE.RUNMODAL(PAGE::Objects, mObject) = ACTION::LookupOK) THEN
      BEGIN
        pObjectId := mObject."Object ID";
        lResult := TRUE;
      END;

      EXIT(lResult);
    END;

    PROCEDURE ObjectIdAssistEdit@1000000036(pObjectType@1000000001 : Integer;VAR pObjectId@1000000000 : Integer) : Boolean;
    VAR
      tlConfirmation@1000000002 : TextConst 'ENU=Do you want to clear the %1 ID?;ENG=Do you want to clear the %1 ID?';
      lResult@1000000003 : Boolean;
    BEGIN
      //DOC NA2015.1 - Assist edit for object ID
      //  -> pObjectType: Object type
      //  <> pObjectId: Target object ID
      //  <- Lookup result

      mObject."Object Type" := pObjectType;
      IF (CONFIRM(tlConfirmation, TRUE, LOWERCASE(FORMAT(mObject."Object Type")))) THEN
      BEGIN
        pObjectId := 0;
        lResult := TRUE;
      END;

      EXIT(lResult);
    END;

    PROCEDURE TableIdLookup@1000000064(VAR pTableId@1000000001 : Integer) : Boolean;
    BEGIN
      //DOC NA2015.1 - Lookup for table ID
      //  <> pTableId: Source / target table ID
      //  <- Lookup result

      EXIT(ObjectIdLookup(mObject."Object Type"::Table, pTableId));
    END;

    PROCEDURE TableIdAssistEdit@1000000061(VAR pTableId@1000000000 : Integer) : Boolean;
    BEGIN
      //DOC NA2015.1 - Assist edit for table ID
      //  <> pTableId: Target table ID
      //  <- Lookup result

      EXIT(ObjectIdAssistEdit(mObject."Object Type"::Table, pTableId));
    END;

    PROCEDURE FieldIdLookup@1000000037(pTableId@1000000000 : Integer;VAR pFieldId@1000000001 : Integer) : Boolean;
    VAR
      lResult@1000000002 : Boolean;
    BEGIN
      //DOC NA2015.1 - Lookup for field ID
      //  -> pTableId: Table ID
      //  <> pFieldId: Source / target field ID
      //  <- Lookup result

      mField.RESET();
      mField.FILTERGROUP(2);
      mField.SETRANGE(TableNo, pTableId);
      mField.FILTERGROUP(0);
      IF (pFieldId <> 0) THEN
      BEGIN
        mField.SETRANGE("No.", pFieldId);
        IF (mField.FINDFIRST()) THEN;
        mField.SETRANGE("No.");
      END;
      IF (PAGE.RUNMODAL(PAGE::Fields, mField) = ACTION::LookupOK) THEN
      BEGIN
        pFieldId := mField."No.";
        lResult := TRUE;
      END;

      EXIT(lResult);
    END;

    PROCEDURE FieldIdAssistEdit@1000000039(VAR pFieldId@1000000000 : Integer) : Boolean;
    VAR
      tlConfirmation@1000000001 : TextConst 'ENU=Do you want to clear the field ID?;ENG=Do you want to clear the field ID?';
      lResult@1000000002 : Boolean;
    BEGIN
      //DOC NA2015.1 - Assist edit for field ID
      //  <> pObjectId: Target field ID
      //  <- Lookup result

      IF (CONFIRM(tlConfirmation, TRUE)) THEN
      BEGIN
        pFieldId := 0;
        lResult := TRUE;
      END;

      EXIT(lResult);
    END;

    PROCEDURE "--- XML Data Conversion ---"@1000000062();
    BEGIN
    END;

    PROCEDURE ToXmlBoolean@1000000059(pBoolean@1000000000 : Boolean) : Text[50];
    BEGIN
      //DOC NA2015.1 - Converting boolean to XML (OBSOLETE)
      //  -> pBooleanValue: Boolean value
      //  <- XML boolean

      EXIT(XmlToolkit.FormatXmlBoolean(pBoolean));
    END;

    PROCEDURE ToXmlDate@1000000055(pDateValue@1000000000 : Date) : Text[50];
    BEGIN
      //DOC NA2015.1 - Converting date to XML (OBSOLETE)
      //  -> pDateValue: Date value
      //  <- XML date

      EXIT(XmlToolkit.FormatXmlDate(pDateValue));
    END;

    PROCEDURE ToXmlDateTime@1000000074(pDateTimeValue@1000000000 : DateTime) : Text[50];
    VAR
      tXmlDateTimeFormat@1000000001 : TextConst 'ENU=<Year4,4>-<Month,2>-<Day,2>T<Hour,2>:<Minute,2>:<Second,2>;ENG=<Year4,4>-<Month,2>-<Day,2>T<Hour,2>:<Minute,2>:<Second,2>';
    BEGIN
      //DOC NA2015.1 - Converting date & time to XML (OBSOLETE)
      //  -> pDateTimeValue: Date value
      //  <- XML date

      EXIT(XmlToolkit.FormatXmlDateTime(pDateTimeValue));
    END;

    PROCEDURE FromXmlBoolean@1000000063(pXmlBoolean@1000000000 : Code[30]) : Boolean;
    VAR
      lXmlBoolean@1000000001 : Code[30];
    BEGIN
      //DOC NA2015.1 - Converting XML boolean to boolean (OBSOLETE)
      //  -> pXmlBoolean: XML boolean
      //  <- Boolean

      EXIT(XmlToolkit.ParseXmlBoolean(pXmlBoolean));
    END;

    PROCEDURE FromXmlDateTime@1000000075(pXmlDateTime@1000000000 : Text[50]) : DateTime;
    BEGIN
      //DOC NA2015.1 - Converting XML date & time to datetime (OBSOLETE)
      //  -> pXmlDateTime: XML date & time
      //  <- Datetime

      EXIT(XmlToolkit.ParseXmlDateTime(pXmlDateTime));
    END;

    PROCEDURE "--- JSON Data Conversion ---"@1000000130();
    BEGIN
    END;

    PROCEDURE ToJsonBoolean@1000000132(pValue@1000000000 : Boolean) : Text;
    BEGIN
      //DOC NA2015.5 - Converting boolean to JSON boolean
      //  -> pValue: Boolean value
      //  <- JSON value

      IF (pValue) THEN
        EXIT('true')
      ELSE
        EXIT('false');
    END;

    PROCEDURE "--- Diagnostics ---"@1000000060();
    BEGIN
    END;

    PROCEDURE DumpBlobToFile@1000000065(VAR pBlob@1000000000 : Record 99008535;pFilePath@1000000001 : Text;pTextMode@1000000005 : Boolean);
    VAR
      lFile@1000000002 : File;
      lOutStream@1000000004 : OutStream;
      lInStream@1000000003 : InStream;
    BEGIN
      //DOC NA2015.3 - Dumping the passed BLOB to specified file
      //  <> pBlob: Blob to dump
      //  -> pFilePath: File path
      //  -> pTextMode: Text mode / binary mode

      pBlob.Blob.CREATEINSTREAM(lInStream);

      IF (FILE.EXISTS(pFilePath)) THEN
        FILE.ERASE(pFilePath);

      lFile.WRITEMODE(TRUE);
      lFile.TEXTMODE(pTextMode);
      lFile.CREATE(pFilePath);
      lFile.CREATEOUTSTREAM(lOutStream);
      COPYSTREAM(lOutStream, lInStream);
      lFile.CLOSE();
    END;

    PROCEDURE DumpBigTextToFile@1000000069(VAR pBigText@1000000002 : BigText;pFilePath@1000000001 : Text;pTextMode@1000000000 : Boolean);
    VAR
      lFile@1000000003 : File;
      lOutStream@1000000004 : OutStream;
    BEGIN
      //DOC NA2015.3 - Dumping the passed BigText to specified file
      //  <> pBigText: The big text
      //  -> pFilePath: File path
      //  -> pTextMode: Text mode / binary mode

      IF (FILE.EXISTS(pFilePath)) THEN
        FILE.ERASE(pFilePath);

      lFile.WRITEMODE(TRUE);
      lFile.TEXTMODE(pTextMode);
      lFile.CREATE(pFilePath);
      lFile.CREATEOUTSTREAM(lOutStream);
      pBigText.WRITE(lOutStream);
      lFile.CLOSE();
    END;

    PROCEDURE "--- Refs ---"@1000000080();
    BEGIN
    END;

    PROCEDURE CalculateFieldRef@1000000081(VAR pFieldRef@1000000000 : FieldRef);
    BEGIN
      //DOC NA2015.1 - Calculating field ref if it is a flowfield
      //  <> pFieldRef: The field ref

      IF (FORMAT(pFieldRef.CLASS()) = 'FlowField') THEN
        pFieldRef.CALCFIELD();
    END;

    PROCEDURE "--- Streams and BLOBs ---"@1000000083();
    BEGIN
    END;

    PROCEDURE TempBlobToStream@1000000087(VAR pOutStream@1000000000 : OutStream;pTempBlob@1000000001 : Record 99008535);
    VAR
      lInStream@1000000002 : InStream;
    BEGIN
      //DOC NA2015.1 - Copying given temporary blob to stream
      //  <> pOutStream: The stream to write to
      //  -> pTempBlob: Temp BLOB to write

      pTempBlob.Blob.CREATEINSTREAM(lInStream);
      COPYSTREAM(pOutStream, lInStream);
    END;

    PROCEDURE FourBytesToStream@1000000084(VAR pOutStream@1000000000 : OutStream;pValue@1000000001 : Integer) : Integer;
    BEGIN
      //DOC NA2015.1 - Copying 4 bytes to a stream
      //  <> pOutStream: The stream to write to
      //  -> pValue: Value to write
      //  <- Bytes written

      pOutStream.WRITE(pValue);

      EXIT(4);
    END;

    PROCEDURE ThreeBytesToStream@1000000088(VAR pOutStream@1000000001 : OutStream;pValue@1000000002 : Integer) : Integer;
    VAR
      lByte1@1000000000 : Byte;
      lByte2@1000000003 : Byte;
      lByte3@1000000004 : Byte;
    BEGIN
      //DOC NA2015.1 - Copying 3 bytes to a stream
      //  <> pOutStream: The stream to write to
      //  -> pValue: Value to write
      //  <- Bytes written

      lByte1 := pValue MOD 256;
      lByte2 := (pValue DIV 256) MOD 256;
      lByte3 := (pValue DIV 65536) MOD 256;

      pOutStream.WRITE(lByte1);
      pOutStream.WRITE(lByte2);
      pOutStream.WRITE(lByte3);

      EXIT(3);
    END;

    PROCEDURE TwoBytesToStream@1000000086(VAR pOutStream@1000000001 : OutStream;pValue@1000000002 : Integer) : Integer;
    VAR
      lByte1@1000000000 : Byte;
      lByte2@1000000003 : Byte;
    BEGIN
      //DOC NA2015.1 - Copying 2 bytes to a stream
      //  <> pOutStream: The stream to write to
      //  -> pValue: Value to write
      //  <- Bytes written

      lByte1 := pValue MOD 256;
      lByte2 := (pValue DIV 256) MOD 256;

      pOutStream.WRITE(lByte1);
      pOutStream.WRITE(lByte2);

      EXIT(2);
    END;

    PROCEDURE OneByteToStream@1000000085(VAR pOutStream@1000000000 : OutStream;pValue@1000000001 : Integer) : Integer;
    VAR
      lByte@1000000002 : Byte;
    BEGIN
      //DOC NA2015.1 - Copying a byte to a stream
      //  -> pOutStream: The stream to write to
      //  -> pValue: Value to write
      //  <- Bytes written

      lByte := pValue MOD 256;
      pOutStream.WRITE(lByte);

      EXIT(1);
    END;

    PROCEDURE BytesToStream@1000000089(VAR pOutStream@1000000000 : OutStream;pValue@1000000001 : Integer;pBytes@1000000003 : Integer) : Integer;
    VAR
      lByte@1000000002 : Char;
    BEGIN
      //DOC NA2015.1 - Copying a number of bytes to a stream
      //  -> pOutStream: The stream to write to
      //  -> pValue: Value to write
      //  -> pBytes: Number of bytes
      //  <- Bytes written

      CASE (pBytes) OF
        1: OneByteToStream(pOutStream, pValue);
        2: TwoBytesToStream(pOutStream, pValue);
        3: ThreeBytesToStream(pOutStream, pValue);
        4: FourBytesToStream(pOutStream, pValue);
      END;

      EXIT(pBytes);
    END;

    PROCEDURE "--- Information ---"@1000000090();
    BEGIN
    END;

    PROCEDURE BooleanInformation@1000000092(pValue@1000000000 : Boolean;pTemplateIfTrue@1000000003 : Text[50];pTemplateIfFalse@1000000001 : Text[50]) : Text[100];
    BEGIN
      //DOC NA2015.1 - Boolean information (true / false)
      //  -> pValue: Value
      //  -> pTemplateIfTrue: Format template if value is true
      //  -> pTemplateIfFales: Format template if value is false

      IF (pValue) THEN
        EXIT(STRSUBSTNO(pTemplateIfTrue, pValue))
      ELSE
        EXIT(STRSUBSTNO(pTemplateIfFalse, pValue));
    END;

    PROCEDURE IntegerInformation@1000000091(pValue@1000000000 : Integer;pTemplateIfZero@1000000003 : Text[50];pTemplateIfOne@1000000001 : Text[50];pTemplateIfMany@1000000002 : Text[50]) : Text[100];
    BEGIN
      //DOC NA2015.1 - Integer information (0 / 1 / many)
      //  -> pValue: Value
      //  -> pTemplateIfZero: Format template if value is zero
      //  -> pTemplateIfOne: Format template if value is one
      //  -> pTemplateIfMany: Format template if value is many

      IF (pValue = 0) THEN
        EXIT(STRSUBSTNO(pTemplateIfZero, pValue))
      ELSE IF (pValue IN [-1, 1]) THEN
        EXIT(STRSUBSTNO(pTemplateIfOne, pValue))
      ELSE
        EXIT(STRSUBSTNO(pTemplateIfMany, pValue));
    END;

    PROCEDURE DecimalInformation@1000000119(pValue@1000000000 : Decimal;pTemplateIfZero@1000000003 : Text[50];pTemplateIfNonZero@1000000002 : Text[50]) : Text[100];
    BEGIN
      //DOC NA2015.1 - Decimal information (0 / non-zero)
      //  -> pValue: Value
      //  -> pTemplateIfZero: Format template if value is zero
      //  -> pTemplateIfNonZero: Format template if non zero

      IF (pValue = 0) THEN
        EXIT(STRSUBSTNO(pTemplateIfZero, pValue))
      ELSE
        EXIT(STRSUBSTNO(pTemplateIfNonZero, pValue));
    END;

    PROCEDURE "--- Permissions ---"@1000000099();
    BEGIN
    END;

    PROCEDURE GetUserByUserId@1000000104(pUserId@1000000000 : Code[50];VAR pUser@1000000001 : Record 2000000120);
    VAR
      eUnknownUser@1000000002 : TextConst 'ENU=Unknown user with ID "%1";ENG=Unknown user with ID "%1"';
    BEGIN
      //DOC NA2015.1 - Getting "User" record with given user ID; if not found - raising an error
      //  -> pUserId: User ID
      //  <> pUser: Target "User" record

      IF ( NOT (FindUserByUserId(pUserId, pUser))) THEN
        ERROR(eUnknownUser);
    END;

    PROCEDURE FindUserByUserId@1000000103(pUserId@1000000000 : Code[50];VAR pUser@1000000001 : Record 2000000120) : Boolean;
    VAR
      lUser@1000000002 : Record 2000000120;
    BEGIN
      //DOC NA2015.1 - Finding "User" record with given user ID
      //  -> pUserId: User ID
      //  <> pUser: Target "User" record
      //  <- User found / not

      lUser.RESET();
      lUser.SETCURRENTKEY("User Name");
      lUser.SETRANGE("User Name", pUserId);
    END;

    PROCEDURE UserIdIsSuper@1000000101(pUserId@1000000000 : Code[50]) : Boolean;
    BEGIN
      //DOC NA2015.1 - Returning if user with given ID is a superuser
      //  -> pUserId: User ID
      //  <- User is / isn't a superuser

      EXIT(UserIdIsAssignedToPermissionSet(pUserId, 'SUPER'));
    END;

    PROCEDURE UserIdIsSuperData@1000000102(pUserId@1000000000 : Code[50]) : Boolean;
    BEGIN
      //DOC NA2015.1 - Returning if user with given ID is a superuser of data (or a superuser)
      //  -> pUserId: User ID
      //  <- User is / isn't a superuser of data

      IF (UserIdIsSuper(pUserId)) THEN
        EXIT(TRUE);

      EXIT(UserIdIsAssignedToPermissionSet(pUserId, 'SUPER (DATA)'));
    END;

    PROCEDURE UserIdIsAssignedToPermissionSet@1000000100(pUserId@1000000000 : Code[50];pPermissionSetCode@1000000001 : Code[20]) : Boolean;
    VAR
      lAccessControl@1000000002 : Record 2000000053;
    BEGIN
      //DOC NA2015.1 - Returning if user with given ID is assigned to given permission set
      //  -> pUserId: User ID
      //  -> pPermissionSetCode: Permission set code
      //  <- User assigned / not assigned to the permission set
    END;

    PROCEDURE "--- Miscellaneous ---"@1000000117();
    BEGIN
    END;

    PROCEDURE CodeToName@1000000120(pCode@1000000001 : Code[50];VAR pName@1000000002 : Text[50]) : Boolean;
    VAR
      lResult@1000000000 : Boolean;
    BEGIN
      //DOC NA2015.1 - Converting code to name
      //  -> pCode: Code
      //  <> pName: Target name
      //  <- TRUE = Converted, FALSE = Not

      lResult := FALSE;
      IF ((pCode <> '') AND (pName = '')) THEN
      BEGIN
        pName := String.ToTitleCase(pCode);
        lResult := TRUE;
      END;
      EXIT(lResult);
    END;

    PROCEDURE IntegerToHex@1000000125(pInteger@1000000000 : Integer;pAddPrefix@1000000006 : Boolean) : Code[20];
    VAR
      lIntegerReminder@1000000002 : Integer;
      lHexDigit@1000000003 : Integer;
      lHexValue@1000000004 : Code[20];
      lNegative@1000000001 : Boolean;
      eHexDigits@1000000005 : TextConst 'ENU=0123456789ABCDEF;ENG=0123456789ABCDEF';
    BEGIN
      //DOC NA2015.1 - Converting integer to hex value
      //  -> pInteger: The integer
      //  -> pAddPrefix: TRUE = add '0x' prefix, FALSE = don't
      //  <- Hex value

      lNegative := (pInteger < 0);
      pInteger := ABS(pInteger);

      IF (pInteger > 0) THEN
      BEGIN
        lIntegerReminder := pInteger;
        WHILE (lIntegerReminder > 0) DO
        BEGIN
          lHexDigit := lIntegerReminder MOD 16;
          lHexValue := COPYSTR(eHexDigits, lHexDigit + 1, 1) + lHexValue;
          lIntegerReminder := lIntegerReminder DIV 16;
        END;
      END
      ELSE
        lHexValue := '0';

      IF (pAddPrefix) THEN
        lHexValue := '0x' + lHexValue;
      IF (lNegative) THEN
        lHexValue := '-' + lHexValue;

      EXIT(lHexValue);
    END;

    PROCEDURE "--- Position ---"@1000000126();
    BEGIN
    END;

    PROCEDURE PositionToDescription@1000000127(pTableID@1000000001 : Integer;pPosition@1000000000 : Text) : Text;
    VAR
      lRecordRef@1000000005 : RecordRef;
      lObjectFieldToolkit@1000000004 : Codeunit 9062343;
      lDescription@1000000002 : Text;
      lTableName@1000000003 : Text;
    BEGIN
      //DOC NA2015.3 - Converting position to description
      //  -> pTableID: Table ID (if zero - ignored)
      //  -> pPosition: The position
      //  <- The description

      IF ((pTableID <> 0) AND (pPosition <> '')) THEN
      BEGIN
        lRecordRef.OPEN(pTableID);
        lRecordRef.SETPOSITION(pPosition);

        lDescription := lRecordRef.GETPOSITION(TRUE);
        lDescription := DELCHR(lDescription, '<>', ' ');
        lDescription := String.ReplaceAll(lDescription, '=CONST(', ' = ');
        lDescription := String.ReplaceAll(lDescription, '),', ', ');
        IF (STRLEN(lDescription) > 0) THEN
          lDescription := COPYSTR(lDescription, 1, STRLEN(lDescription) - 1);

        lTableName := lObjectFieldToolkit.GetTableName(pTableID);
        IF (lDescription <> '') THEN
          lDescription := STRSUBSTNO('%1: %2', lTableName, lDescription)
        ELSE
          lDescription := lTableName;

        lRecordRef.CLOSE();
      END;

      EXIT(lDescription);
    END;

    BEGIN
    {
      //DOC NA2015.1  JH 09/10/2012 - Planning Board 2013
      //DOC NA2015.1  JH 04/10/2013 - Renamed to "TNP Toolkit", cleaned a bit
      //DOC NA2015.1  JH 13/02/2014 - "CodeToName" added
      //DOC NA2015.3  JH 27/08/2014 - Text unlimited everywhere
      //DOC NA2015.4  JH 28/01/2015 - Client type functions added
      //DOC NA2015.5  JH 20/02/2015 - JSON data conversion added
      //DOC NA2015.8  PC 13/07/2015 - Fixes
      //DOC NA2016.10 JH 26/08/2015 - Upgraded to 2016
      //DOC NA2016.11 JH 31/10/2015 - String split with .NET array fixed, title case fixed
      //DOC NA2016.12 JH 27/12/2015 - Planning board-specific functions removed
      //DOC NA2016.12 JH 28/01/2016 - String functions moved to "String" codeunit
      //DOC NA2016.12 JH 01/02/2016 - Date functions moved to "Date Time" codeunit
      //DOC NA2016.14 JH 02/03/2016 - XML functions moved to "XML Toolkit" codeunit
    }
    END.
  }
}

