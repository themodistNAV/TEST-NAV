OBJECT Codeunit 11102060 OM - Check Guidelines Mgt.
{
  OBJECT-PROPERTIES
  {
    Date=19/11/15;
    Time=12:00:00 PM;
    Version List=OMA10.00;
  }
  PROPERTIES
  {
    OnRun=VAR
            Setup@1000 : Record 11102035;
            Mgt@1001 : Codeunit 11102035;
            Progressbar@1002 : Codeunit 11102044;
            SourceControl@1003 : Codeunit 11102050;
            CheckGuidelinesMgt@1004 : Codeunit 11102060;
            ctCheckingGuidelines@1005 : TextConst 'DEU=Checking guidelines...;ENU=Checking guidelines...;ESP=Checking guidelines...;FRA=Checking guidelines...;NLD=Richtlijnen controleren...;DEA=Checking guidelines...';
            ctObjectFailed@1006 : TextConst 'DEU=Checking guidelines failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;ENU=Checking guidelines failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;ESP=Checking guidelines failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;FRA=Checking guidelines failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6;NLD=Richtlijnen controleren mislukt bij object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Foutmelding: %6;DEA=Checking guidelines failed for object:\\%1 %2 %3\\OMA Version No.:%4 (%5)\Error: %6';
          BEGIN
            CASE RunType OF
              RunType::Default :
                BEGIN

                  SourceControl.AddObjects(TmpObject, 0, TRUE, TRUE, 2, FALSE);

                  Progressbar.Open(ctCheckingGuidelines, 1);
                  Progressbar.BarSize := TmpObject.COUNT;

                  IF TmpObject.FINDSET THEN
                    REPEAT
                      Progressbar.AddToBar(1);
                      Progressbar.Text1Object := TmpObject;

                      COMMIT;
                      CLEAR(CheckGuidelinesMgt);
                      CheckGuidelinesMgt.SetRunType(RunType::"Check Object", TmpObject);
                      CheckGuidelinesMgt.SetProjectObjects(TmpProjectObject);
                      IF NOT CheckGuidelinesMgt.RUN THEN
                        MESSAGE(
                          STRSUBSTNO(
                            ctObjectFailed, TmpObject.Type, TmpObject.ID, TmpObject.Name,
                            Setup.OMAVersionNo, Setup.DateOfObject, Mgt.GetLastError2));

                    UNTIL TmpObject.NEXT = 0;

                  Progressbar.Close;
                END;

              RunType::"Check Object" :
                BEGIN
                  IF NOT Initialized THEN
                    Initialize;
                  AnalyseAndSaveObject(ObjectToCheck);
                END;

            END;
          END;

  }
  CODE
  {
    VAR
      TmpProjectObject@1000 : TEMPORARY Record 11102037;
      ObjectToCheck@1001 : Record 2000000001;
      TmpObject@1002 : TEMPORARY Record 2000000001;
      BufferIdentifier@1003 : ARRAY [4] OF Text[30];
      CheckRunIntegerString@1004 : ARRAY [17] OF Text[30];
      FunctionName@1005 : Text;
      MandLanguage@1006 : ARRAY [100] OF Code[10];
      CheckFieldNo@1007 : ARRAY [7,50] OF Integer;
      MandLanguageId@1008 : ARRAY [100] OF Integer;
      NoOfMandLanguages@1009 : Integer;
      VariableBufferEntryNo@1010 : Integer;
      CaptionCheck@1011 : ' ,Missing Captions';
      CheckType@1012 : ' ,Coding,Layout,Data,Naming,Captions,Transport,Comma Space';
      CodingCheck@1013 : ' ,Indent,IF THEN,Line Break,Missing Spaces,Missing ;,BEGIN END,= TRUE,= FALSE,Tablename SETRANGE,Redundant Tablename,Empty Lines,Redundant Spaces,Redundant (),FIND,Double Var. Name,Properties,TODO,Text,Project,SetCurrentKey,Broken Lines,CALCDATE,MARK,RUN Integer,OnLookup,Brackets,Is Servicetier,TextConst';
      CommaSpaceCheck@1014 : ' ,Mandatory,Prohibited';
      DataCheck@1015 : ' ,Key Field is Code,NotBlank,Testfield,Flowfield,Options Strings,Key in Relation,Type in Relation,Missing Relations,Assignments,Delete Relating Table,Const in Relation,Transferfields,Lookup Page,Data Caption Fields,AltSearchField';
      LayoutCheck@1016 : ' ,Image,Double Access Keys,Shortcut Keys,Lowercase Shortcut Keys,Properties,Check Keys,Empty Action';
      NamingCheck@1017 : ',Temp,Variable,Object,Field,Reserved,Function,Double Captions';
      RunType@1018 : 'Default,Check Object';
      TransportCheck@1019 : ',Project Tag,Object in License,Indirect Permission';
      CheckCaptionOption@1020 : ARRAY [50] OF Boolean;
      CheckCodeOption@1021 : ARRAY [50] OF Boolean;
      CheckDataOption@1022 : ARRAY [50] OF Boolean;
      CheckLayoutOption@1023 : ARRAY [50] OF Boolean;
      CheckNamingOption@1024 : ARRAY [50] OF Boolean;
      CheckTransportOption@1025 : ARRAY [50] OF Boolean;
      Initialized@1026 : Boolean;
      IsCriticalCheck@1027 : ARRAY [7,50] OF Boolean;

    PROCEDURE SetRunType@1(NewValue@1000 : Option;VAR NewObject@1001 : Record 2000000001);
    BEGIN
      RunType := NewValue;
      ObjectToCheck := NewObject;
    END;

    PROCEDURE SetObjectRange@2(VAR NewObject@1000 : Record 2000000001);
    BEGIN
      IF NewObject.FINDSET THEN
        REPEAT
          TmpObject := NewObject;
          TmpObject.INSERT;
        UNTIL NewObject.NEXT = 0;
    END;

    PROCEDURE AnalyseFile@3(FileName@1000 : Text;ResultsFileName@1001 : Text;CorrectedFileName@1002 : Text);
    VAR
      TmpSourceObject@1003 : TEMPORARY Record 11102052;
      TmpCALHistoryLine@1004 : TEMPORARY Record 11102053;
      TmpSelectedCALLine@1005 : TEMPORARY Record 11102053;
      TmpSourceLine@1006 : TEMPORARY Record 11102053;
      TmpCheckGuidelinesComment@1007 : TEMPORARY Record 11102081;
      TmpCheckGuidelinesComment2@1008 : TEMPORARY Record 11102081;
      Object@1009 : Record 2000000001;
      Progressbar@1010 : Codeunit 11102044;
      SourceControl@1011 : Codeunit 11102050;
      AutoApplyGuidelines@1012 : Codeunit 11102061;
      oCorrectedFile@1013 : File;
      oFile@1014 : File;
      oResultFile@1015 : File;
      NoOfComments@1016 : Integer;
      Steps@1017 : Integer;
      ctCheckingGuidelines@1018 : TextConst 'DEU=Checking Guidelines...;ENU=Checking Guidelines...;ESP=Checking Guidelines...;FRA=Checking Guidelines...;NLD=Richtlijnen controleren...;DEA=Checking Guidelines...';
      ctComment@1019 : TextConst 'DEU=Line %1: %2;ENU=Line %1: %2;ESP=Line %1: %2;FRA=Line %1: %2;NLD=Regel %1: %2;DEA=Line %1: %2';
      ctNoComments@1020 : TextConst 'DEU=%1 comments found.;ENU=%1 comments found.;ESP=%1 comments found.;FRA=%1 comments found.;NLD=%1 opmerkingen gevonden.;DEA=%1 comments found.';
      ctReadingFile@1021 : TextConst 'DEU=Reading File...;ENU=Reading File...;ESP=Reading File...;FRA=Reading File...;NLD=Bestand inlezen...;DEA=Reading File...';
      ctWriteObjects@1022 : TextConst 'DEU=Writing Corrected Objects...;ENU=Writing Corrected Objects...;ESP=Writing Corrected Objects...;FRA=Writing Corrected Objects...;NLD=Gecorrigeerde objecten schrijven...;DEA=Writing Corrected Objects...';
    BEGIN
      Initialize;

      Steps := 1;
      IF ResultsFileName <> '' THEN
        Steps += 1;
      IF CorrectedFileName <> '' THEN
        Steps += 1;

      oFile.OPEN(FileName);
      Progressbar.Open('', 2);
      Progressbar.Text1 := ctReadingFile;
      Progressbar.BarSize := oFile.LEN * Steps;
      oFile.CLOSE;

      SourceControl.ImportTextFile2(FileName, 2, Progressbar, 0, TmpSourceObject, TmpSourceLine, TRUE);

      Progressbar.BarSize := TmpSourceObject.COUNT * Steps;
      Progressbar.BarPosition := TmpSourceObject.COUNT;

      IF ResultsFileName <> '' THEN BEGIN

        Progressbar.Text1 := ctCheckingGuidelines;

        IF EXISTS(ResultsFileName) THEN
          ERASE(ResultsFileName);

        oResultFile.WRITEMODE(TRUE);
        oResultFile.TEXTMODE(TRUE);
        oResultFile.CREATE(ResultsFileName);

        IF TmpSourceObject.FINDSET THEN
          REPEAT
            TmpSourceObject.FillObjectFields(Object);

            Progressbar.AddToBar(1);
            Progressbar.Text2Object := Object;

            TmpCALHistoryLine.RESET;
            TmpCALHistoryLine.DELETEALL;

            TmpSourceLine.SETRANGE("Entry No.", TmpSourceObject."Entry No.");
            IF TmpSourceLine.FINDSET THEN
              REPEAT
                TmpCALHistoryLine := TmpSourceLine;
                TmpCALHistoryLine."Entry No." := 0;
                TmpCALHistoryLine.INSERT;
              UNTIL TmpSourceLine.NEXT = 0;

            TmpCheckGuidelinesComment.RESET;
            TmpCheckGuidelinesComment.DELETEALL;

            AnalyseObject(Object, TmpCALHistoryLine, TmpCheckGuidelinesComment);

            IF TmpCheckGuidelinesComment.FINDSET THEN BEGIN
              oResultFile.WRITE(FORMAT(Object.Type) + ' ' + FORMAT(Object.ID) + ' ' + Object.Name);
              REPEAT
                NoOfComments += 1;
                oResultFile.WRITE(STRSUBSTNO(ctComment, TmpCheckGuidelinesComment."C/AL Line No.", TmpCheckGuidelinesComment.Comment));
              UNTIL TmpCheckGuidelinesComment.NEXT = 0;
              oResultFile.WRITE('');
            END;

          UNTIL TmpSourceObject.NEXT = 0;

        IF NoOfComments = 0 THEN
          oResultFile.WRITE(STRSUBSTNO(ctNoComments, NoOfComments));

        MESSAGE(STRSUBSTNO(ctNoComments, NoOfComments));

        oResultFile.CLOSE;
      END;

      IF CorrectedFileName <> '' THEN BEGIN

        Progressbar.Text1 := ctWriteObjects;

        IF EXISTS(CorrectedFileName) THEN
          ERASE(CorrectedFileName);

        oCorrectedFile.WRITEMODE(TRUE);
        oCorrectedFile.TEXTMODE(TRUE);
        oCorrectedFile.CREATE(CorrectedFileName);

        IF TmpSourceObject.FINDSET THEN
          REPEAT
            TmpSourceObject.FillObjectFields(Object);
            Progressbar.Text2Object := Object;
            Progressbar.AddToBar(1);

            TmpCALHistoryLine.RESET;
            TmpCALHistoryLine.DELETEALL;
            TmpSourceLine.SETRANGE("Entry No.", TmpSourceObject."Entry No.");
            IF TmpSourceLine.FINDSET THEN
              REPEAT
                TmpCALHistoryLine := TmpSourceLine;
                TmpCALHistoryLine."Entry No." := 0;
                TmpCALHistoryLine.INSERT;
              UNTIL TmpSourceLine.NEXT = 0;

            AutoApplyGuidelines.AutocorrectCode(Object, TmpCALHistoryLine, TmpCheckGuidelinesComment2, TmpSelectedCALLine);

            TmpCALHistoryLine.RESET;
            SourceControl.AppendHistoryLinesToFile(oCorrectedFile, TmpCALHistoryLine);

          UNTIL TmpSourceObject.NEXT = 0;
        oCorrectedFile.CLOSE;

      END;

      Progressbar.Close;
    END;

    PROCEDURE Initialize@4();
    VAR
      Setup@1000 : Record 11102035;
      Fld@1001 : Record 2000000041;
      Fld2@1002 : Record 2000000041;
      RecRef@1003 : RecordRef;
      FldRef@1004 : FieldRef;
      FldRefValue@1005 : Boolean;
      ctSpecifyType@1006 : TextConst 'DEU=Specify guidelines type for field %1.;ENU=Specify guidelines type for field %1.;ESP=Specify guidelines type for field %1.;FRA=Specify guidelines type for field %1.;NLD=Specificeer richtlijnsoort voor veld %1.;DEA=Specify guidelines type for field %1.';
    BEGIN
      Setup.CustomGet;
      RecRef.GETTABLE(Setup);

      Fld2.SETRANGE(TableNo, DATABASE::"OM - Setup");
      IF Setup."Critical Guideline Checks" = '' THEN
        Fld2.SETRANGE("No.", 0)
      ELSE
        Fld2.SETFILTER("No.", Setup."Critical Guideline Checks");

      Fld.SETRANGE(TableNo, DATABASE::"OM - Setup");
      Fld.SETFILTER("No.", '>=100');
      Fld.SETFILTER(FieldName, 'Check *');
      IF Fld.FINDSET THEN
        REPEAT

          FldRef := RecRef.FIELD(Fld."No.");
          EVALUATE(FldRefValue, FORMAT(FldRef.VALUE));

          Fld2 := Fld;

          CASE TRUE OF

            CodingCheckNo(Fld."No.") <> 0 :
              BEGIN
                CheckCodeOption[CodingCheckNo(Fld."No.")] := FldRefValue;
                CheckFieldNo[CheckType::Coding, CodingCheckNo(Fld."No.")] := Fld."No.";
                IsCriticalCheck[CheckType::Coding, CodingCheckNo(Fld."No.")] := Fld2.FIND('=');
              END;

            LayoutCheckNo(Fld."No.") <> 0 :
              BEGIN
                CheckLayoutOption[LayoutCheckNo(Fld."No.")] := FldRefValue;
                CheckFieldNo[CheckType::Layout, LayoutCheckNo(Fld."No.")] := Fld."No.";
                IsCriticalCheck[CheckType::Layout, LayoutCheckNo(Fld."No.")] := Fld2.FIND('=');
              END;

            DataCheckNo(Fld."No.") <> 0 :
              BEGIN
                CheckDataOption[DataCheckNo(Fld."No.")] := FldRefValue;
                CheckFieldNo[CheckType::Data, DataCheckNo(Fld."No.")] := Fld."No.";
                IsCriticalCheck[CheckType::Data, DataCheckNo(Fld."No.")] := Fld2.FIND('=');
              END;

            NamingCheckNo(Fld."No.") <> 0 :
              BEGIN
                CheckNamingOption[NamingCheckNo(Fld."No.")] := FldRefValue;
                CheckFieldNo[CheckType::Naming, NamingCheckNo(Fld."No.")] := Fld."No.";
                IsCriticalCheck[CheckType::Naming, NamingCheckNo(Fld."No.")] := Fld2.FIND('=');
              END;

            TransportCheckNo(Fld."No.") <> 0 :
              BEGIN
                CheckTransportOption[TransportCheckNo(Fld."No.")] := FldRefValue;
                CheckFieldNo[CheckType::Transport, TransportCheckNo(Fld."No.")] := Fld."No.";
                IsCriticalCheck[CheckType::Transport, TransportCheckNo(Fld."No.")] := Fld2.FIND('=');
              END;

            CaptionCheckNo(Fld."No.") <> 0 :
              BEGIN
                CheckCaptionOption[CaptionCheckNo(Fld."No.")] := FldRefValue;
                CheckFieldNo[CheckType::Captions, CaptionCheckNo(Fld."No.")] := Fld."No.";
                IsCriticalCheck[CheckType::Captions, CaptionCheckNo(Fld."No.")] := Fld2.FIND('=');
              END;

            ELSE
              ERROR(ctSpecifyType, Fld."No.");
          END;

        UNTIL Fld.NEXT = 0;

      RecRef.CLOSE;

      InitializeLanguages;

      CommaSpaceCheck := Setup."Space after Comma";
      CheckFieldNo[CheckType::"Comma Space", 1] := Setup.FIELDNO("Space after Comma");

      Fld2."No." := 172;
      IsCriticalCheck[CheckType::"Comma Space", 1] := Fld2.FIND('=');

      BufferIdentifier[1] := 'tmp';
      BufferIdentifier[2] := 'temp';
      BufferIdentifier[3] := 'buffer';
      BufferIdentifier[4] := 'buf';

      CheckRunIntegerString[1] := 'PAGE.RUN';
      CheckRunIntegerString[2] := 'PAGE.RUNMODAL';
      CheckRunIntegerString[3] := 'REPORT.RUN';
      CheckRunIntegerString[4] := 'REPORT.RUNMODAL';
      CheckRunIntegerString[5] := 'REPORT.SAVEASHTML';
      CheckRunIntegerString[6] := 'REPORT.SAVEASXML';
      CheckRunIntegerString[7] := 'REPORT.SAVEASPDF';
      CheckRunIntegerString[8] := 'REPORT.SAVEASEXCEL';
      CheckRunIntegerString[9] := 'REPORT.SAVEASWORD';
      CheckRunIntegerString[10] := 'CODEUNIT.RUN';
      CheckRunIntegerString[11] := 'XMLPORT.IMPORT';
      CheckRunIntegerString[12] := 'XMLPORT.EXPORT';
      CheckRunIntegerString[13] := 'XMLPORT.RUN';
      CheckRunIntegerString[14] := 'PAGE.RUN';
      CheckRunIntegerString[15] := 'PAGE.RUNMODAL';
      CheckRunIntegerString[16] := 'QUERY.SAVEASCSV';
      CheckRunIntegerString[17] := 'QUERY.SAVEASXML';

      Initialized := TRUE;
    END;

    LOCAL PROCEDURE InitializeLanguages@5();
    VAR
      Setup@1000 : Record 11102035;
      TmpUser@1001 : TEMPORARY Record 11102056;
      WindowsLanguage2@1002 : Record 2000000045;
      LanguageId@1003 : Integer;
    BEGIN
      Setup.CustomGet;
      IF Setup."Mandatory Languages" <> '' THEN BEGIN
        WindowsLanguage2.SETFILTER("Abbreviated Name", Setup."Mandatory Languages");
        IF WindowsLanguage2.FINDSET THEN
          REPEAT
            IF NOT TmpUser.GET(WindowsLanguage2."Abbreviated Name") THEN BEGIN
              TmpUser.Code := WindowsLanguage2."Abbreviated Name";
              LanguageId := WindowsLanguage2."Language ID";
              TmpUser."Line Type" := LanguageId;
              TmpUser.INSERT;
            END;
          UNTIL WindowsLanguage2.NEXT = 0;

        IF TmpUser.FINDSET THEN
          REPEAT
            NoOfMandLanguages += 1;
            MandLanguage[NoOfMandLanguages] := TmpUser.Code;
            MandLanguageId[NoOfMandLanguages] := TmpUser."Line Type";
          UNTIL TmpUser.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE CodingCheckNo@6(FieldNo2@1000 : Integer) : Integer;
    VAR
      Setup@1001 : Record 11102035;
    BEGIN
      CASE FieldNo2 OF
        Setup.FIELDNO("Check Wrong Indent") : EXIT(CodingCheck::Indent);
        Setup.FIELDNO("Check Wrong IF THEN Use") : EXIT(CodingCheck::"IF THEN");
        Setup.FIELDNO("Check Wrong Line Break") : EXIT(CodingCheck::"Line Break");
        Setup.FIELDNO("Check Missing Spaces") : EXIT(CodingCheck::"Missing Spaces");
        Setup.FIELDNO("Check Missing ;") : EXIT(CodingCheck::"Missing ;");
        Setup.FIELDNO("Check Unnecessary BEGIN END") : EXIT(CodingCheck::"BEGIN END");
        Setup.FIELDNO("Check = TRUE") : EXIT(CodingCheck::"= TRUE");
        Setup.FIELDNO("Check = FALSE") : EXIT(CodingCheck::"= FALSE");
        Setup.FIELDNO("Check Table Name in SETRANGE") : EXIT(CodingCheck::"Tablename SETRANGE");
        Setup.FIELDNO("Check Redundant Table Name") : EXIT(CodingCheck::"Redundant Tablename");
        Setup.FIELDNO("Check Empty Lines") : EXIT(CodingCheck::"Empty Lines");
        Setup.FIELDNO("Check Redundant Spaces") : EXIT(CodingCheck::"Redundant Spaces");
        Setup.FIELDNO("Check Redundant ()") : EXIT(CodingCheck::"Redundant ()");
        Setup.FIELDNO("Check FIND(-)") : EXIT(CodingCheck::FIND);
        Setup.FIELDNO("Check Double Variable Names") : EXIT(CodingCheck::"Double Var. Name");
        Setup.FIELDNO("Check Unnecessary Properties T") : EXIT(CodingCheck::Properties);
        Setup.FIELDNO("Check TODO Comment") : EXIT(CodingCheck::TODO);
        Setup.FIELDNO("Check Text in Code") : EXIT(CodingCheck::Text);
        Setup.FIELDNO("Check Wrong SETCURRENTKEY") : EXIT(CodingCheck::SetCurrentKey);
        Setup.FIELDNO("Check Broken Lines") : EXIT(CodingCheck::"Broken Lines");
        Setup.FIELDNO("Check Missing <> in CALCDATE") : EXIT(CodingCheck::CALCDATE);
        Setup.FIELDNO("Check MARK") : EXIT(CodingCheck::MARK);
        Setup.FIELDNO("Check PAGE.RUN(Integer)") : EXIT(CodingCheck::"RUN Integer");
        Setup.FIELDNO("Check Code in OnLookup") : EXIT(CodingCheck::OnLookup);
        Setup.FIELDNO("Check Comments with Brackets") : EXIT(CodingCheck::Brackets);
        Setup.FIELDNO("Check IS SERVICETIER") : EXIT(CodingCheck::"Is Servicetier");
        Setup.FIELDNO("Check TextConst") : EXIT(CodingCheck::TextConst);
      END;
    END;

    LOCAL PROCEDURE LayoutCheckNo@7(FieldNo2@1000 : Integer) : Integer;
    VAR
      Setup@1001 : Record 11102035;
    BEGIN
      CASE FieldNo2 OF
        Setup.FIELDNO("Check Missing Image") : EXIT(LayoutCheck::Image);
        Setup.FIELDNO("Check Double Access Keys") : EXIT(LayoutCheck::"Double Access Keys");
        Setup.FIELDNO("Check Double Shortcut Keys") : EXIT(LayoutCheck::"Shortcut Keys");
        Setup.FIELDNO("Check Lowercase Shortcut Keys") : EXIT(LayoutCheck::"Lowercase Shortcut Keys");
        Setup.FIELDNO("Check Unnecessary Properties L") : EXIT(LayoutCheck::Properties);
        Setup.FIELDNO("Check Usage Not Exis. Keys") : EXIT(LayoutCheck::"Check Keys");
        Setup.FIELDNO("Check Empty Action") : EXIT(LayoutCheck::"Empty Action");
      END;
    END;

    LOCAL PROCEDURE DataCheckNo@8(FieldNo2@1000 : Integer) : Integer;
    VAR
      Setup@1001 : Record 11102035;
    BEGIN
      CASE FieldNo2 OF
        Setup.FIELDNO("Check Key Fields Int. or Code") : EXIT(DataCheck::"Key Field is Code");
        Setup.FIELDNO("Check NotBlank on Key Fields") : EXIT(DataCheck::NotBlank);
        Setup.FIELDNO("Check Testfield on Key Fields") : EXIT(DataCheck::Testfield);
        Setup.FIELDNO("Check Flowfields Not Editable") : EXIT(DataCheck::Flowfield);
        Setup.FIELDNO("Check Option Strings") : EXIT(DataCheck::"Options Strings");
        Setup.FIELDNO("Check Pr. Key in Relation") : EXIT(DataCheck::"Key in Relation");
        Setup.FIELDNO("Check Field Types of Relations") : EXIT(DataCheck::"Type in Relation");
        Setup.FIELDNO("Check Missing Relations") : EXIT(DataCheck::"Missing Relations");
        Setup.FIELDNO("Check Assignments") : EXIT(DataCheck::Assignments);
        Setup.FIELDNO("Check Delete Relating Table") : EXIT(DataCheck::"Delete Relating Table");
        Setup.FIELDNO("Check Constants in Relations") : EXIT(DataCheck::"Const in Relation");
        Setup.FIELDNO("Check Transferfields") : EXIT(DataCheck::Transferfields);
        Setup.FIELDNO("Check Lookup Page") : EXIT(DataCheck::"Lookup Page");
        Setup.FIELDNO("Check Data Caption Fields") : EXIT(DataCheck::"Data Caption Fields");
        Setup.FIELDNO("Check AltSearchField") : EXIT(DataCheck::AltSearchField);
      END;
    END;

    LOCAL PROCEDURE NamingCheckNo@9(FieldNo2@1000 : Integer) : Integer;
    VAR
      Setup@1001 : Record 11102035;
    BEGIN
      CASE FieldNo2 OF
        Setup.FIELDNO("Check tmp in Name Temp Rec.") : EXIT(NamingCheck::Temp);
        Setup.FIELDNO("Check Variable Names") : EXIT(NamingCheck::Variable);
        Setup.FIELDNO("Check Object Names") : EXIT(NamingCheck::Object);
        Setup.FIELDNO("Check Field Names") : EXIT(NamingCheck::Field);
        Setup.FIELDNO("Check Reserved Names") : EXIT(NamingCheck::Reserved);
        Setup.FIELDNO("Check Function Names") : EXIT(NamingCheck::"Function");
        Setup.FIELDNO("Check Double Captions") : EXIT(NamingCheck::"Double Captions");
      END;
    END;

    LOCAL PROCEDURE TransportCheckNo@92(FieldNo2@1000 : Integer) : Integer;
    VAR
      Setup@1001 : Record 11102035;
    BEGIN
      CASE FieldNo2 OF
        Setup.FIELDNO("Check Project Tag Present") : EXIT(TransportCheck::"Project Tag");
        Setup.FIELDNO("Check Objects in License") : EXIT(TransportCheck::"Object in License");
        Setup.FIELDNO("Check Indirect Permissions") : EXIT(TransportCheck::"Indirect Permission");
      END;
    END;

    LOCAL PROCEDURE CaptionCheckNo@10(FieldNo2@1000 : Integer) : Integer;
    VAR
      Setup@1001 : Record 11102035;
    BEGIN
      CASE FieldNo2 OF
        Setup.FIELDNO("Check Missing Captions") : EXIT(CaptionCheck::"Missing Captions");
      END;
    END;

    LOCAL PROCEDURE AutocorrectGroup@11(FieldNo2@1000 : Integer) : Integer;
    VAR
      Setup@1001 : Record 11102035;
    BEGIN
      CASE FieldNo2 OF

        Setup.FIELDNO("Check Missing ;"),
        Setup.FIELDNO("Check Missing Spaces"),
        Setup.FIELDNO("Check Redundant ()"),
        Setup.FIELDNO("Check Redundant Spaces"),
        Setup.FIELDNO("Check = TRUE"),
        Setup.FIELDNO("Check Table Name in SETRANGE"),
        Setup.FIELDNO("Check Redundant Table Name"),
        Setup.FIELDNO("Check Empty Lines"),
        Setup.FIELDNO("Space after Comma") :
          EXIT(1);

        Setup.FIELDNO("Check Wrong IF THEN Use"),
        Setup.FIELDNO("Check Wrong Line Break") :
          EXIT(2);

        Setup.FIELDNO("Check Unnecessary BEGIN END") :
          EXIT(3);

        Setup.FIELDNO("Check Wrong Indent") :
          EXIT(4);

      END;
    END;

    PROCEDURE AnalyseAndSaveObject@12(VAR Object@1000 : Record 2000000001);
    VAR
      TmpCALHistoryLine@1001 : TEMPORARY Record 11102053;
      TmpCheckGuidelinesComment@1002 : TEMPORARY Record 11102081;
    BEGIN
      GetCode(Object, TmpCALHistoryLine);

      AnalyseObject(Object, TmpCALHistoryLine, TmpCheckGuidelinesComment);

      SaveComments(Object, TmpCheckGuidelinesComment);
    END;

    PROCEDURE AnalyseObject@13(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR Comment@1002 : Record 11102081);
    VAR
      VariableBuffer@1003 : TEMPORARY Record 11102062;
    BEGIN
      CheckObjectNameAndCaption(CALHistoryLine, Comment, NOT (Object.Type IN [Object.Type::Codeunit, Object.Type::MenuSuite]));
      CheckObjectProperties(Object, CALHistoryLine, Comment);
      GetGlobals(Object, CALHistoryLine, VariableBuffer, Comment);
      AnalyseFunctions(Object, CALHistoryLine, VariableBuffer, Comment);

      CASE Object.Type OF

        Object.Type::Table :
          CheckTableOptions(Object, CALHistoryLine, Comment, VariableBuffer);

        Object.Type::Report :
          AnalysePageControls(CALHistoryLine, Comment, 5);

        Object.Type::Page :
          AnalysePageControls(CALHistoryLine, Comment, 3);

      END;

      IF Object.Type <> Object.Type::MenuSuite THEN
        AnalyseTransportChecks(Object, CALHistoryLine, Comment);
    END;

    LOCAL PROCEDURE CheckObjectNameAndCaption@14(VAR CALHistoryLine@1000 : Record 11102053;VAR Comment@1001 : Record 11102081;CheckCaption@1002 : Boolean);
    VAR
      TmpLanguage@1003 : TEMPORARY Record 11102056;
      Mgt@1004 : Codeunit 11102035;
      ENUCaption@1005 : Text;
      ObjectName@1006 : Text;
      i@1007 : Integer;
      PropertySection@1008 : Integer;
      CaptionPresent@1009 : Boolean;
      ctAddCaption@1010 : TextConst 'DEU=Add caption to object;ENU=Add caption to object;ESP=Add caption to object;FRA=Add caption to object;NLD=Caption toevoegen;DEA=Add caption to object';
      ctNameIsReserved@1011 : TextConst 'DEU=''%1'' is a reserved command;ENU=''%1'' is a reserved command;ESP=''%1'' is a reserved command;FRA=''%1'' is a reserved command;NLD=''%1'' is een gereserveerd commando;DEA=''%1'' is a reserved command';
      ctRemoveFirstSpace@1012 : TextConst 'DEU=Remove first space from object name;ENU=Remove first space from object name;ESP=Remove first space from object name;FRA=Remove first space from object name;NLD=Verwijder eerste spatie van objectnaam;DEA=Remove first space from object name';
      ctRemoveSpace@1013 : TextConst 'DEU=Remove space from name at position %1;ENU=Remove space from name at position %1;ESP=Remove space from name at position %1;FRA=Remove space from name at position %1;NLD=Verwijder spatie uit naam op positie %1;DEA=Remove space from name at position %1';
      ctRemoveTrailingSpace@1014 : TextConst 'DEU=Remove trailing space from object name;ENU=Remove trailing space from object name;ESP=Remove trailing space from object name;FRA=Remove trailing space from object name;NLD=Verwijder laatste spatie van objectnaam;DEA=Remove trailing space from object name';
      ctStartCapital@1015 : TextConst 'DEU=Start object name with a capital;ENU=Start object name with a capital;ESP=Start object name with a capital;FRA=Start object name with a capital;NLD=Begin objectnaam met een hoofdletter;DEA=Start object name with a capital';
    BEGIN
      IF CALHistoryLine.FINDFIRST THEN BEGIN
        ObjectName := CALHistoryLine.Code;
        FOR i := 1 TO 3 DO
          IF STRPOS(ObjectName, ' ') > 0 THEN
            ObjectName := COPYSTR(ObjectName, STRPOS(ObjectName, ' ') + 1);
      END;

      IF ObjectName <> '' THEN BEGIN

        IF ObjectName[1] = ' ' THEN
          AddNamingComment(Comment, NamingCheck::Object, ctRemoveFirstSpace, 1, 'SPACE');

        IF ObjectName[STRLEN(ObjectName)] = ' ' THEN
          AddNamingComment(Comment, NamingCheck::Object, ctRemoveTrailingSpace, 1, 'LASTSPACE');

        IF FORMAT(ObjectName[1]) <> UPPERCASE(FORMAT(ObjectName[1])) THEN
          AddNamingComment(Comment, NamingCheck::Object, ctStartCapital, 1, 'CAPITAL');

        IF STRPOS(ObjectName, '  ') > 0 THEN
          AddNamingComment(Comment, NamingCheck::Object, STRSUBSTNO(ctRemoveSpace, STRPOS(ObjectName, '  ')), 1, 'DOUBLESPACE');

        IF Mgt.IsReservedKeyword(ObjectName) THEN
          AddNamingComment(Comment, NamingCheck::Reserved, STRSUBSTNO(ctNameIsReserved, ObjectName), 1, '');

      END;

      IF CheckCaption THEN BEGIN
        IF SetRangeOnSection(CALHistoryLine, 'PROPERTIES') THEN BEGIN
          PropertySection := CALHistoryLine."Line No.";
          CALHistoryLine.SETRANGE("Sub Line No.", 1);
          CALHistoryLine.SETFILTER(Code, '%1', '    CaptionML=*');
          IF CALHistoryLine.FINDFIRST THEN BEGIN
            CALHistoryLine.SETRANGE(Code);
            ParseCaption(CALHistoryLine, 'CaptionML', Comment, ENUCaption, 'OBJECT', TmpLanguage);
            CaptionPresent := TRUE;
          END;
        END;

        IF NOT CaptionPresent THEN BEGIN
          IF PropertySection = 0 THEN
            PropertySection := 1;
          AddCaptionComment(Comment, CaptionCheck::"Missing Captions", ctAddCaption, PropertySection - 1, 'OBJECT');
        END;

      END;
    END;

    LOCAL PROCEDURE CheckObjectProperties@15(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR Comment@1002 : Record 11102081);
    VAR
      PropertyName@1003 : Text;
      PropertyValue@1004 : Text;
      PageNo@1005 : Integer;
      SectionCALLineNo@1006 : Integer;
      DataCaptionFieldsPresent@1007 : Boolean;
      ctAddDataCaptionFields@1008 : TextConst 'DEU=Add data caption fields;ENU=Add data caption fields;ESP=Add data caption fields;FRA=Add data caption fields;NLD=Datacaptionvelden toevoegen;DEA=Add data caption fields';
      ctRemoveProperty@1009 : TextConst 'DEU=Remove property: ''%1'' is default for ''%2'';ENU=Remove property: ''%1'' is default for ''%2'';ESP=Remove property: ''%1'' is default for ''%2'';FRA=Remove property: ''%1'' is default for ''%2'';NLD=Verwijder property: ''%1'' is de standaardwaarde voor ''%2'';DEA=Remove property: ''%1'' is default for ''%2''';
    BEGIN
      SectionCALLineNo := 1;
      IF SetRangeOnSection(CALHistoryLine, 'PROPERTIES') THEN BEGIN
        CALHistoryLine.SETRANGE("Sub Line No.", 1);
        IF CALHistoryLine.FINDSET THEN BEGIN
          SectionCALLineNo := CALHistoryLine."Line No.";
          REPEAT
            IF STRLEN(CALHistoryLine.Code) > 5 THEN
              IF CALHistoryLine.Code[5] <> ' ' THEN BEGIN
                GetPropertyName(CALHistoryLine.Code, PropertyName);
                GetPropertyValue(CALHistoryLine, PropertyValue);
                IF DefaultProperty(FORMAT(Object.Type), FORMAT(Object.Type), PropertyName) = PropertyValue THEN
                  IF Object.Type = Object.Type::Table THEN
                    AddCodingComment(
                      Comment, CodingCheck::Properties,
                      STRSUBSTNO(ctRemoveProperty, PropertyValue, PropertyName), CALHistoryLine."Line No.", 0, 0, '')
                  ELSE
                    AddLayoutComment(
                      Comment, LayoutCheck::Properties,
                      STRSUBSTNO(ctRemoveProperty, PropertyValue, PropertyName), CALHistoryLine."Line No.", '');

                CASE PropertyName OF
                  'LookupPageID' :
                    BEGIN
                      PropertyValue := COPYSTR(PropertyValue, 5);
                      IF EVALUATE(PageNo, PropertyValue) THEN
                        CheckPageProperties(PageNo, Object.ID, TRUE, Comment, CALHistoryLine."Line No.");
                    END;

                  'DrillDownPageID' :
                    BEGIN
                      PropertyValue := COPYSTR(PropertyValue, 5);
                      IF EVALUATE(PageNo, PropertyValue) THEN
                        CheckPageProperties(PageNo, Object.ID, FALSE, Comment, CALHistoryLine."Line No.");
                    END;

                  'DataCaptionFields' :
                    DataCaptionFieldsPresent := TRUE;

                END;
              END;
          UNTIL CALHistoryLine.NEXT = 0;

        END;
      END;

      IF Object.Type = Object.Type::Table THEN
        IF NOT DataCaptionFieldsPresent THEN
          AddDataComment(Comment, DataCheck::"Data Caption Fields", ctAddDataCaptionFields, SectionCALLineNo, '');
    END;

    LOCAL PROCEDURE CheckPageProperties@90(PageNo@1000 : Integer;SourceTableNo@1001 : Integer;Lookup@1002 : Boolean;VAR Comment@1003 : Record 11102081;CALLineNo@1004 : Integer);
    VAR
      CALHistoryObject@1005 : Record 11102052;
      CALHistoryLine@1006 : Record 11102053;
      Object@1007 : Record 2000000001;
      PageType@1008 : Text;
      SourceTableText@1009 : Text;
      SourceTableInteger@1010 : Integer;
      ctWrongPageType@1011 : TextConst 'DEU=Not a list page;ENU=Not a list page;ESP=Not a list page;FRA=Not a list page;NLD=Geen lijstpagina;DEA=Not a list page';
      ctWrongSourceTable@1012 : TextConst 'DEU=Wrong source table;ENU=Wrong source table;ESP=Wrong source table;FRA=Wrong source table;NLD=Verkeerde source-tabel;DEA=Wrong source table';
    BEGIN
      IF CALHistoryObject.TryGoToLastRecord(Object.Type::Page, PageNo) THEN BEGIN
        CALHistoryLine.SETRANGE("Entry No.", CALHistoryObject."Entry No.");
        CALHistoryLine.SETRANGE("Sub Line No.", 1);
        CALHistoryLine.SETFILTER(Code, '%1', '    SourceTable=*');
        IF CALHistoryLine.FINDFIRST THEN BEGIN
          GetPropertyValue(CALHistoryLine, SourceTableText);
          SourceTableText := COPYSTR(SourceTableText, 6);
          IF EVALUATE(SourceTableInteger, SourceTableText) THEN
            IF SourceTableNo <> SourceTableInteger THEN
              AddDataComment(Comment, DataCheck::"Lookup Page", ctWrongSourceTable, CALLineNo, FORMAT(Lookup) + '-SOURCETABLE');
        END;
        PageType := 'Card';
        CALHistoryLine.SETFILTER(Code, '%1', '    PageType=*');
        IF CALHistoryLine.FINDFIRST THEN
          GetPropertyValue(CALHistoryLine, PageType);
        IF NOT (PageType IN ['List', 'ListPlus', 'Worksheet']) THEN
          AddDataComment(Comment, DataCheck::"Lookup Page", ctWrongPageType, CALLineNo, FORMAT(Lookup) + '-PAGETYPE');

      END;
    END;

    PROCEDURE AnalyseTransportChecks@16(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR Comment@1002 : Record 11102081);
    VAR
      ProjectType@1003 : Record 11102097;
      TmpPermissionRange@1004 : TEMPORARY Record 2000000044;
    BEGIN
      CheckProjectTagsPresent(Object, CALHistoryLine, Comment);

      IF GetBestProjectType(Object, ProjectType) THEN
        IF GetPermissionRange(ProjectType, TmpPermissionRange) THEN BEGIN
          CheckObjectInLicense(Object, TmpPermissionRange, Comment);
          CheckIndirectPermissions(CALHistoryLine, TmpPermissionRange, Comment);
        END;
    END;

    LOCAL PROCEDURE CheckProjectTagsPresent@94(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR Comment@1002 : Record 11102081);
    VAR
      FirstLineNo@1003 : Integer;
      LastLineNo@1004 : Integer;
      StopLoop@1005 : Boolean;
      ctNoProjectTag@1006 : TextConst 'DEU=Project tag ''%1'' not present;ENU=Project tag ''%1'' not present;ESP=Project tag ''%1'' not present;FRA=Project tag ''%1'' not present;NLD=Projectkenmerk ''%1'' niet aanwezig;DEA=Project tag ''%1'' not present';
    BEGIN
      TmpProjectObject.SETCURRENTKEY("Object Type", "Object No.");
      TmpProjectObject.SETRANGE("Object Type", Object.Type);
      TmpProjectObject.SETRANGE("Object No.", Object.ID);
      IF TmpProjectObject.ISEMPTY THEN
        EXIT;

      CALHistoryLine.RESET;
      CALHistoryLine.SETRANGE("Sub Line No.", 1);
      CALHistoryLine.SETRANGE("Entry No.", 0);
      IF NOT CALHistoryLine.FINDLAST THEN
        EXIT;

      CALHistoryLine.NEXT(-4);

      LastLineNo := CALHistoryLine."Line No.";

      REPEAT
        IF CALHistoryLine.Code = '    BEGIN' THEN BEGIN
          StopLoop := TRUE;
          FirstLineNo := CALHistoryLine."Line No.";
        END ELSE
          StopLoop := CALHistoryLine.NEXT(-1) = 0;
      UNTIL StopLoop;

      IF TmpProjectObject.FINDSET THEN
        REPEAT
          CALHistoryLine.SETRANGE("Line No.", FirstLineNo, LastLineNo);
          CALHistoryLine.SETFILTER(Code, '''@*' + TmpProjectObject."Project No." + '*''');
          IF CALHistoryLine.ISEMPTY THEN
            AddTransportComment(
              Comment, TransportCheck::"Project Tag",
              STRSUBSTNO(ctNoProjectTag, TmpProjectObject."Project No."), LastLineNo, 0, 0, TmpProjectObject."Project No.");
        UNTIL TmpProjectObject.NEXT = 0;
    END;

    LOCAL PROCEDURE CheckObjectInLicense@131(VAR Object@1000 : Record 2000000001;VAR TmpPermissionRange@1001 : TEMPORARY Record 2000000044;VAR Comment@1002 : Record 11102081) : Boolean;
    VAR
      ctObjectNotInLicense@1003 : TextConst 'DEU=Object not in customer license;ENU=Object not in customer license;ESP=Object not in customer license;FRA=Object not in customer license;NLD=Object niet in klantlicentie;DEA=Object not in customer license';
    BEGIN
      TmpPermissionRange.SETRANGE("Object Type", Object.Type);
      TmpPermissionRange.SETFILTER(From, '<=%1', Object.ID);
      TmpPermissionRange.SETFILTER("To", '>=%1', Object.ID);
      IF TmpPermissionRange.FINDFIRST THEN
        IF TmpPermissionRange."Execute Permission" = TmpPermissionRange."Execute Permission"::Yes THEN
          EXIT;

      AddTransportComment(Comment, TransportCheck::"Object in License", ctObjectNotInLicense, 1, 0, 0, '');
    END;

    LOCAL PROCEDURE CheckIndirectPermissions@132(VAR CALHistoryLine@1000 : Record 11102053;VAR TmpPermissionRange@1001 : TEMPORARY Record 2000000044;VAR Comment@1002 : Record 11102081);
    VAR
      Permissions@1003 : Text;
      TableNoString@1004 : Text;
      SplitPos@1005 : Integer;
      TableNo@1006 : Integer;
      PermissionValid@1007 : Boolean;
      StopLoop@1008 : Boolean;
      ctPermissionNotPresent@1009 : TextConst 'DEU=Permission not in customer license;ENU=Permission not in customer license;ESP=Permission not in customer license;FRA=Permission not in customer license;NLD=Rechten niet aanwezig in klantlicentie;DEA=Permission not in customer license';
    BEGIN
      CALHistoryLine.RESET;
      CALHistoryLine.SETRANGE("Sub Line No.", 1);
      CALHistoryLine.SETFILTER(Code, '%1', '    Permissions=*');
      IF CALHistoryLine.FINDFIRST THEN
        REPEAT
          CALHistoryLine.SETRANGE(Code);
          TableNoString := COPYSTR(CALHistoryLine.Code, 27);
          TableNoString := DELCHR(TableNoString, '=', ' ,;}');
          SplitPos := STRPOS(TableNoString, '=');

          IF SplitPos > 0 THEN BEGIN
            Permissions := COPYSTR(TableNoString, SplitPos + 1);
            TableNoString := COPYSTR(TableNoString, 1, SplitPos - 1);

            IF EVALUATE(TableNo, TableNoString) THEN BEGIN
              PermissionValid := TRUE;
              WITH TmpPermissionRange DO BEGIN
                SETRANGE("Object Type", "Object Type"::TableData);
                SETFILTER(From, '<=%1', TableNo);
                SETFILTER("To", '>=%1', TableNo);

                IF NOT FINDFIRST THEN
                  PermissionValid := FALSE;

                IF STRPOS(Permissions, 'r') > 0 THEN
                  IF "Read Permission" = "Read Permission"::" " THEN
                    PermissionValid := FALSE;
                IF STRPOS(Permissions, 'i') > 0 THEN
                  IF "Insert Permission" = "Insert Permission"::" " THEN
                    PermissionValid := FALSE;
                IF STRPOS(Permissions, 'm') > 0 THEN
                  IF "Modify Permission" = "Modify Permission"::" " THEN
                    PermissionValid := FALSE;
                IF STRPOS(Permissions, 'd') > 0 THEN
                  IF "Delete Permission" = "Delete Permission"::" " THEN
                    PermissionValid := FALSE;
                IF NOT PermissionValid THEN
                  AddTransportComment(
                    Comment, TransportCheck::"Indirect Permission", ctPermissionNotPresent, CALHistoryLine."Line No.", 0, 0, '');

              END;
            END;
          END;

          StopLoop := CALHistoryLine.NEXT = 0;

          IF COPYSTR(CALHistoryLine.Code, 17, 9) <> 'TableData' THEN
            StopLoop := TRUE;

        UNTIL StopLoop;

      CALHistoryLine.SETRANGE("Sub Line No.");
    END;

    LOCAL PROCEDURE GetBestProjectType@96(VAR Object@1000 : Record 2000000001;VAR ProjectType@1001 : Record 11102097) : Boolean;
    VAR
      Setup@1002 : Record 11102035;
      Project@1003 : Record 11102036;
    BEGIN
      TmpProjectObject.SETCURRENTKEY("Object Type", "Object No.");
      TmpProjectObject.SETRANGE("Object Type", Object.Type);
      TmpProjectObject.SETRANGE("Object No.", Object.ID);
      IF TmpProjectObject.FINDSET THEN
        REPEAT
          IF Project.GET(TmpProjectObject."Project No.") THEN
            IF ProjectType.GET(Project."Project Type Code") THEN
              EXIT(TRUE);
        UNTIL TmpProjectObject.NEXT = 0;

      Setup.CustomGet;
      EXIT(ProjectType.GET(Setup."Default Project Type"));
    END;

    LOCAL PROCEDURE GetGlobals@17(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR VariableBuffer@1002 : TEMPORARY Record 11102062;VAR Comment@1003 : Record 11102081);
    VAR
      StopLoop@1004 : Boolean;
    BEGIN
      IF SetRangeOnSection(CALHistoryLine, 'CODE') THEN BEGIN
        CALHistoryLine.SETRANGE("Sub Line No.", 1);
        IF CALHistoryLine.FINDSET THEN
          IF CALHistoryLine.Code = '    VAR' THEN BEGIN

            CALHistoryLine.SETFILTER("Line No.", '>%1', CALHistoryLine."Line No.");
            IF CALHistoryLine.FINDSET THEN
              REPEAT
                AnalyseVariableLine(Object, CALHistoryLine, VariableBuffer, Comment, 3, FALSE, 'GLOBALS');
                StopLoop := CALHistoryLine.NEXT = 0;
                IF NOT StopLoop THEN
                  IF STRLEN(CALHistoryLine.Code) > 5 THEN
                    StopLoop := CALHistoryLine.Code[5] <> ' ';
              UNTIL StopLoop;

          END;
      END;
      CALHistoryLine.RESET;
    END;

    LOCAL PROCEDURE AnalyseFunctions@18(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR VariableBuffer@1002 : TEMPORARY Record 11102062;VAR Comment@1003 : Record 11102081);
    VAR
      TmpLanguage@1004 : TEMPORARY Record 11102056;
      Object2@1005 : Record 2000000001;
      RunObject@1006 : Record 2000000001;
      Mgt@1007 : Codeunit 11102035;
      ControlId@1008 : Text;
      ControlId2@1009 : Text;
      CurrSection@1010 : Text;
      FunctionName2@1011 : Text;
      NextDataItemVarName@1012 : Text;
      PropertyName@1013 : Text;
      PropertyValue@1014 : Text;
      ReturnCaption@1015 : Text;
      SubFormView@1016 : Text;
      FunctionIdentifier@1017 : Code[250];
      Identifier@1018 : Code[100];
      IdentifierArray@1019 : ARRAY [10] OF Code[100];
      NextDataItemTable@1020 : Integer;
      RecordNo@1021 : Integer;
      SourceTableNo@1022 : Integer;
      SpacePos@1023 : Integer;
      FunctionType@1024 : ' ,Function,Trigger';
      ctRemoveSpace@1025 : TextConst 'DEU=Remove space from function name;ENU=Remove space from function name;ESP=Remove space from function name;FRA=Remove space from function name;NLD=Verwijder spatie uit functienaam;DEA=Remove space from function name';
    BEGIN
      IF Object.Type = Object.Type::Table THEN
        RecordNo := Object.ID;

      CALHistoryLine.RESET;
      CALHistoryLine.SETRANGE("Sub Line No.", 1);
      IF CALHistoryLine.FINDSET THEN
        REPEAT
          FunctionType := FunctionType::" ";

          IF STRLEN(CALHistoryLine.Code) > 3 THEN BEGIN
            IF CALHistoryLine.Code[3] <> ' ' THEN
              IF CALHistoryLine.Code[3] <> '{' THEN BEGIN
                CurrSection := DELCHR(CALHistoryLine.Code, '<>');
                Identifier := DELCHR(DELSTR(CurrSection, 20));
                IdentifierArray[1] := Identifier;
                ControlId := '';
              END;
            IF DELCHR(CALHistoryLine.Code, '<>') = 'ActionList=ACTIONS' THEN BEGIN
              CurrSection := 'ACTIONS';
              Identifier := '';
              IdentifierArray[1] := '';
              ControlId := '';
            END;
            IF CALHistoryLine.Code = '          CONTROLS' THEN
              CurrSection := 'CONTROLS';
            IF CurrSection = 'CONTROLS' THEN
              IF CALHistoryLine.Code = '          }' THEN
                CurrSection := '';
          END;

          ControlId2 := DELCHR(CALHistoryLine.Code);
          IF ControlId2[1] = '{' THEN BEGIN

            NextDataItemTable := 0;
            NextDataItemVarName := '';
            IdentifierArray[2] := '';
            RunObject.ID := 0;
            SubFormView := '';

            ControlId2 := COPYSTR(ControlId2, 2);
            IF STRPOS(ControlId2, ';') > 0 THEN
              ControlId := DELSTR(ControlId2, STRPOS(ControlId2, ';'));
          END;

          GetPropertyName(CALHistoryLine.Code, PropertyName);
          IF PropertyName <> '' THEN BEGIN

            GetPropertyValue(CALHistoryLine, PropertyValue);

            CASE PropertyName OF
              'DataItemTable' :
                IF EVALUATE(NextDataItemTable, COPYSTR(PropertyValue, 6)) THEN
                  IF Object2.GET(Object2.Type::Table, '', NextDataItemTable) THEN BEGIN
                    RecordNo := NextDataItemTable;
                    NextDataItemVarName := Object2.Name;
                    IdentifierArray[2] := Object2.Name;
                    Identifier := IdentifierArray[1] + '-' + IdentifierArray[2];
                  END;

              'DataItemVarName' :
                BEGIN
                  IdentifierArray[2] := NextDataItemVarName;
                  Identifier := IdentifierArray[1] + '-' + IdentifierArray[2];
                END;

              'DataItemTableView' :
                AnalyseTableView(Comment, CALHistoryLine."Line No.", Identifier, PropertyValue, NextDataItemTable, FALSE);

              'PagePartID' :
                IF SubFormView <> '' THEN
                  IF EVALUATE(RunObject.ID, COPYSTR(PropertyValue, 5)) THEN BEGIN
                    SourceTableNo := GetSourceTableOfObject(RunObject.Type::Page, RunObject.ID);
                    IF SourceTableNo <> 0 THEN
                      AnalyseTableView(Comment, CALHistoryLine."Line No.", Identifier, SubFormView, SourceTableNo, FALSE);
                  END;

              'RunFormView', 'SubFormView' :
                BEGIN
                  SubFormView := PropertyValue;
                  IF RunObject.ID <> 0 THEN BEGIN
                    SourceTableNo := GetSourceTableOfObject(RunObject.Type, RunObject.ID);
                    IF SourceTableNo <> 0 THEN
                      AnalyseTableView(Comment, CALHistoryLine."Line No.", Identifier, PropertyValue, SourceTableNo, FALSE);
                  END;
                END;

              'RunObject' :
                BEGIN
                  SpacePos := STRPOS(PropertyValue, ' ');
                  IF SpacePos > 0 THEN
                    IF EVALUATE(RunObject.Type, DELSTR(PropertyValue, SpacePos)) THEN
                      IF EVALUATE(RunObject.ID, COPYSTR(PropertyValue, SpacePos + 1)) THEN
                        IF NOT RunObject.FIND('=') THEN
                          RunObject.ID := 0;
                END;

              'SourceTable' :
                IF EVALUATE(RecordNo, COPYSTR(PropertyValue, 6)) THEN
                  ;

              'TableNo' :
                IF EVALUATE(RecordNo, PropertyValue, 6) THEN
                  ;

            END;

          END;

          IF COPYSTR(CALHistoryLine.Code, 7, 1) = '}' THEN BEGIN
            NextDataItemTable := 0;
            NextDataItemVarName := '';
          END;

          IF DELSTR(CALHistoryLine.Code, 15) = '    PROCEDURE ' THEN BEGIN
            FunctionType := FunctionType::"Function";
            FunctionName2 := COPYSTR(CALHistoryLine.Code, 15);
            FunctionIdentifier := COPYSTR(CALHistoryLine.Code, 16);
            IF STRPOS(FunctionIdentifier, '(') > 0 THEN
              FunctionIdentifier := DELSTR(FunctionIdentifier, STRPOS(FunctionIdentifier, '('));
            IF STRPOS(FunctionIdentifier, '@') > 0 THEN
              FunctionIdentifier := COPYSTR(FunctionIdentifier, STRPOS(FunctionIdentifier, '@') + 1);
          END;

          IF DELSTR(CALHistoryLine.Code, 21) = '    LOCAL PROCEDURE ' THEN BEGIN
            FunctionType := FunctionType::"Function";
            FunctionName2 := COPYSTR(CALHistoryLine.Code, 21);
            FunctionIdentifier := COPYSTR(CALHistoryLine.Code, 22);
            IF STRPOS(FunctionIdentifier, '(') > 0 THEN
              FunctionIdentifier := DELSTR(FunctionIdentifier, STRPOS(FunctionIdentifier, '('));
            IF STRPOS(FunctionIdentifier, '@') > 0 THEN
              FunctionIdentifier := COPYSTR(FunctionIdentifier, STRPOS(FunctionIdentifier, '@') + 1);
          END;

          IF DELSTR(CALHistoryLine.Code, 11) = '    EVENT ' THEN BEGIN
            FunctionType := FunctionType::"Function";
            FunctionIdentifier := COPYSTR(CALHistoryLine.Code, 12);
            IF STRPOS(FunctionIdentifier, '(') > 0 THEN
              FunctionIdentifier := DELSTR(FunctionIdentifier, STRPOS(FunctionIdentifier, '('));
            IF STRPOS(FunctionIdentifier, '@') > 0 THEN
              FunctionIdentifier := COPYSTR(FunctionIdentifier, STRPOS(FunctionIdentifier, '@') + 1);
          END;

          IF STRLEN(CALHistoryLine.Code) > 5 THEN BEGIN
            IF COPYSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 5) = '=BEGIN' THEN BEGIN
              FunctionType := FunctionType::Trigger;
              FunctionIdentifier := DELSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 5);
              WHILE STRPOS(FunctionIdentifier, ';') > 0 DO
                FunctionIdentifier := COPYSTR(FunctionIdentifier, STRPOS(FunctionIdentifier, ';') + 1);
              FunctionIdentifier := DELCHR(FunctionIdentifier);
              IF ControlId <> '' THEN
                FunctionIdentifier := ControlId + '-' + FunctionIdentifier;
            END;

            IF COPYSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 3) = '=VAR' THEN BEGIN
              FunctionType := FunctionType::Trigger;
              FunctionIdentifier := DELSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 3);
              WHILE STRPOS(FunctionIdentifier, ';') > 0 DO
                FunctionIdentifier := COPYSTR(FunctionIdentifier, STRPOS(FunctionIdentifier, ';') + 1);
              FunctionIdentifier := DELCHR(FunctionIdentifier);
              IF ControlId <> '' THEN
                FunctionIdentifier := ControlId + '-' + FunctionIdentifier;
            END;

          END;

          IF FunctionType <> FunctionType::" " THEN BEGIN

            IF FunctionName2 <> '' THEN
              IF STRPOS(FunctionName2, '@') > 0 THEN BEGIN
                FunctionName2 := COPYSTR(FunctionName2, 1, STRPOS(FunctionName2, '@') - 1);
                IF STRPOS(FunctionName2, ' ') > 0 THEN
                  AddNamingComment(
                    Comment, NamingCheck::"Function", ctRemoveSpace,
                    CALHistoryLine."Line No.", Identifier + '-' + FunctionIdentifier);
              END;

            AnalyseFunction(
              Object, CALHistoryLine, VariableBuffer, Comment, FunctionType,
              Mgt.AddQuotes(NextDataItemVarName), RecordNo, Identifier + '-' + FunctionIdentifier);

          END;

          IF NOT (CurrSection IN ['FIELDS', 'PROPERTIES']) THEN
            IF STRPOS(CALHistoryLine.Code, 'CaptionML=') > 0 THEN
              ParseCaption(CALHistoryLine, 'CaptionML', Comment, ReturnCaption, Identifier + '-' + ControlId, TmpLanguage);

          CALHistoryLine.SETRANGE("Sub Line No.", 1);

        UNTIL CALHistoryLine.NEXT = 0;

      CALHistoryLine.RESET;
    END;

    LOCAL PROCEDURE AnalyseFunction@19(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR VariableBuffer@1002 : TEMPORARY Record 11102062;VAR Comment@1003 : Record 11102081;FunctionType@1004 : ' ,Function,Trigger';RecName@1005 : Text;RecordNo@1006 : Integer;Identifier@1007 : Code[100]);
    VAR
      Mgt@1008 : Codeunit 11102035;
      FunctionName2@1009 : Text;
      FirstCharacter@1010 : Integer;
      Position@1011 : Integer;
      ctNameIsReserved@1012 : TextConst 'DEU=''%1'' is a reserved command;ENU=''%1'' is a reserved command;ESP=''%1'' is a reserved command;FRA=''%1'' is a reserved command;NLD=''%1'' is een gereserveerd commando;DEA=''%1'' is a reserved command';
    BEGIN
      CALHistoryLine.RESET;
      CALHistoryLine.SETRANGE("Sub Line No.", 1);

      CASE FunctionType OF
        FunctionType::"Function" :
          BEGIN
            IF CALHistoryLine.Code[5] = 'L' THEN BEGIN
              Position := 21;
              NextValue(CALHistoryLine.Code, Position, '@', '"', '"', FunctionName2);
            END;
            IF CALHistoryLine.Code[5] = 'P' THEN BEGIN
              Position := 15;
              NextValue(CALHistoryLine.Code, Position, '@', '"', '"', FunctionName2);
              IF STRPOS(FunctionName2, '(') > 0 THEN
                FunctionName2 := DELSTR(FunctionName2, STRPOS(FunctionName2, '('));
            END;
            IF FunctionName2 <> '' THEN
              IF Mgt.IsReservedKeyword(FunctionName2) THEN
                AddNamingComment(
                  Comment, NamingCheck::Reserved, STRSUBSTNO(ctNameIsReserved, FunctionName2),
                  CALHistoryLine."Line No.", '');

            AddVariablesFromParameters(Object, CALHistoryLine, VariableBuffer, Comment, Identifier);
            FirstCharacter := 5;
            CALHistoryLine.NEXT;
          END;

        FunctionType::Trigger :
          BEGIN
            FunctionName2 := DELCHR(CALHistoryLine.Code, '<>');
            IF STRPOS(FunctionName2, '=') > 0 THEN
              FunctionName2 := COPYSTR(FunctionName2, 1, STRPOS(FunctionName2, '=') - 1);
            WHILE STRPOS(FunctionName2, ';') > 0 DO
              FunctionName2 := COPYSTR(FunctionName2, STRPOS(FunctionName2, ';') + 1);
            IF COPYSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 2) = 'VAR' THEN
              FirstCharacter := STRLEN(CALHistoryLine.Code) - 2
            ELSE
              FirstCharacter := STRLEN(CALHistoryLine.Code) - 4;
          END;
      END;

      FunctionName := FunctionName2;

      GetLocalVariables(Object, Comment, CALHistoryLine, VariableBuffer, Identifier);

      IF CheckCodeOption[CodingCheck::"Double Var. Name"] THEN
        CheckDoubleVariableNames(Comment, VariableBuffer, Identifier);

      AnalyseCode(CALHistoryLine, Comment, VariableBuffer, FirstCharacter + 2, RecName, RecordNo, Identifier);

      VariableBuffer.SETFILTER(Scope, '%1|%2|%3',
        VariableBuffer.Scope::"Local", VariableBuffer.Scope::Parameter, VariableBuffer.Scope::"Return Value");
      VariableBuffer.DELETEALL;
      VariableBuffer.SETRANGE(Scope);

      FunctionName := '';
    END;

    PROCEDURE AnalyseCode@20(VAR CALHistoryLine@1000 : Record 11102053;VAR Comment@1001 : Record 11102081;VAR VariableBuffer@1002 : TEMPORARY Record 11102062;StartIndent@1003 : Integer;RecName@1004 : Text;RecordNo@1005 : Integer;ParIdentifier@1006 : Code[100]);
    VAR
      CodeLine@1007 : Text;
      IndentRecName@1008 : ARRAY [500] OF Text[100];
      PreviousCodeLine@1009 : Text;
      RecName2@1010 : Text;
      TempCodeLine@1011 : ARRAY [500] OF Text[1024];
      Identifier@1012 : Code[100];
      LastCharacterPreviousLine@1013 : Char;
      AllowedMaxIndent@1014 : Integer;
      AllowedMinIndent@1015 : Integer;
      CurrentIndent@1016 : Integer;
      CurrentIndentCounter@1017 : Integer;
      EmptyLineCounter@1018 : Integer;
      ExpectedIndent@1019 : Integer;
      FirstOpeningLine@1020 : Integer;
      i@1021 : Integer;
      Indent@1022 : ARRAY [500] OF Integer;
      IndentCALLineNo@1023 : ARRAY [500] OF Integer;
      IndentCauseCounter@1024 : Integer;
      IndentExpectedIndent@1025 : ARRAY [500] OF Integer;
      IndentLineCounter@1026 : ARRAY [500] OF Integer;
      j@1027 : Integer;
      LastBegin@1028 : Integer;
      LineBreakStartAt@1029 : Integer;
      PreviousBeginEndLineNo@1030 : Integer;
      PreviousCALLineNo@1031 : Integer;
      PreviousIndent@1032 : Integer;
      PreviousLineBreakStartAt@1033 : Integer;
      StartCALLineNo@1034 : Integer;
      TotalLineLength@1035 : Integer;
      GoBack@1036 : ' ,Begin,If,While';
      IndentIsBegin@1037 : ARRAY [500] OF ' ,Begin,If,If Begin,While';
      PreviousGoBack@1038 : ' ,Begin,If,While';
      PreviousIndentIsBegin@1039 : ' ,Begin,If,If Begin,While';
      CanBeGlued@1040 : Boolean;
      IndentOpenEnd@1041 : ARRAY [500] OF Boolean;
      PreviousGoBackWasIf@1042 : Boolean;
      PreviousOpenEnd@1043 : Boolean;
      RemoveBeginEnd@1044 : Boolean;
      SkipCheck@1045 : Boolean;
      StartedWithIf@1046 : Boolean;
      StopLoop@1047 : Boolean;
      StopLoop2@1048 : Boolean;
      WrongThenUse@1049 : Boolean;
      ctAddSemicolon@1050 : TextConst 'DEU="Add a '';''";ENU="Add a '';''";ESP="Add a '';''";FRA="Add a '';''";NLD="Voeg '';'' toe";DEA="Add a '';''"';
      ctKeepTogether@1051 : TextConst 'DEU=Keep ''%1 and ''%2'' together;ENU=Keep ''%1 and ''%2'' together;ESP=Keep ''%1 and ''%2'' together;FRA=Keep ''%1 and ''%2'' together;NLD=Hou ''%1'' en ''%2'' bij elkaar;DEA=Keep ''%1 and ''%2'' together';
      ctLineDoesNotHaveToBeBroken@1052 : TextConst 'DEU=Line does not have to be broken;ENU=Line does not have to be broken;ESP=Line does not have to be broken;FRA=Line does not have to be broken;NLD=Regel hoeft niet te worden afgebroken;DEA=Line does not have to be broken';
      ctRemoveBegin@1053 : TextConst 'DEU=Remove ''BEGIN'';ENU=Remove ''BEGIN'';ESP=Remove ''BEGIN'';FRA=Remove ''BEGIN'';NLD=Verwijder ''BEGIN'';DEA=Remove ''BEGIN''';
      ctRemoveCommand@1054 : TextConst 'DEU=Remove ''ISSERVICETIER'';ENU=Remove ''ISSERVICETIER'';ESP=Remove ''ISSERVICETIER'';FRA=Remove ''ISSERVICETIER'';NLD=Verwijder ''ISSERVICETIER'';DEA=Remove ''ISSERVICETIER''';
      ctRemoveEnd@1055 : TextConst 'DEU=Remove ''END'';ENU=Remove ''END'';ESP=Remove ''END'';FRA=Remove ''END'';NLD=Verwijder ''END'';DEA=Remove ''END''';
      ctRemoveLine@1056 : TextConst 'DEU=Remove empty line;ENU=Remove empty line;ESP=Remove empty line;FRA=Remove empty line;NLD=Verwijder lege regel;DEA=Remove empty line';
      ctReplaceFindMin@1057 : TextConst 'DEU=Replace FIND(''-'') with ''FINDFIRST'', ''FINDSET'' or ''ISEMPTY'';ENU=Replace FIND(''-'') with ''FINDFIRST'', ''FINDSET'' or ''ISEMPTY'';ESP=Replace FIND(''-'') with ''FINDFIRST'', ''FINDSET'' or ''ISEMPTY'';FRA=Replace FIND(''-'') with ''FINDFIRST'', ''FINDSET'' or ''ISEMPTY'';NLD=Vervang FIND(''-'') met ''FINDFIRST'', ''FINDSET'' of ''ISEMPTY'';DEA=Replace FIND(''-'') with ''FINDFIRST'', ''FINDSET'' or ''ISEMPTY''';
      ctReplaceFindPlus@1058 : TextConst 'DEU=Replace FIND(''+'') with ''FINDLAST'';ENU=Replace FIND(''+'') with ''FINDLAST'';ESP=Replace FIND(''+'') with ''FINDLAST'';FRA=Replace FIND(''+'') with ''FINDLAST'';NLD=Vervang FIND(''+'') met ''FINDLAST'';DEA=Replace FIND(''+'') with ''FINDLAST''';
      ctStartAtNewLine@1059 : TextConst 'DEU=''%1'' must start at new line;ENU=''%1'' must start at new line;ESP=''%1'' must start at new line;FRA=''%1'' must start at new line;NLD=''%1'' moet beginnen op nieuwe regel;DEA=''%1'' must start at new line';
      ctToDo@1060 : TextConst 'DEU=// TODO found in code;ENU=// TODO found in code;ESP=// TODO found in code;FRA=// TODO found in code;NLD=// TODO gevonden in code;DEA=// TODO found in code';
      ctWrongIndentAdd@1061 : TextConst 'DEU=Wrong indent: Add %1 space(s);ENU=Wrong indent: Add %1 space(s);ESP=Wrong indent: Add %1 space(s);FRA=Wrong indent: Add %1 space(s);NLD=Verkeerd inspringen: Voeg %1 spatie(s) toe;DEA=Wrong indent: Add %1 space(s)';
      ctWrongIndentAddAtLeast@1062 : TextConst 'DEU=Wrong indent: Add at least %1 space(s);ENU=Wrong indent: Add at least %1 space(s);ESP=Wrong indent: Add at least %1 space(s);FRA=Wrong indent: Add at least %1 space(s);NLD=Verkeerd inspringen: Voeg tenminste %1 spatie(s) toe;DEA=Wrong indent: Add at least %1 space(s)';
      ctWrongIndentRemove@1063 : TextConst 'DEU=Wrong indent: Remove %1 space(s);ENU=Wrong indent: Remove %1 space(s);ESP=Wrong indent: Remove %1 space(s);FRA=Wrong indent: Remove %1 space(s);NLD=Verkeerd inspringen: Verwijder %1 spatie(s);DEA=Wrong indent: Remove %1 space(s)';
      ctWrongIndentRemoveAtLeast@1064 : TextConst 'DEU=Wrong indent: Remove at least %1 space(s);ENU=Wrong indent: Remove at least %1 space(s);ESP=Wrong indent: Remove at least %1 space(s);FRA=Wrong indent: Remove at least %1 space(s);NLD=Verkeerd inspringen: Verwijder tenminste %1 spatie(s);DEA=Wrong indent: Remove at least %1 space(s)';
    BEGIN
      EmptyLineCounter := 1;
      StartCALLineNo := CALHistoryLine."Line No.";

      REPEAT
        StopLoop := CALHistoryLine.NEXT = 0;
        IF NOT StopLoop THEN BEGIN
          StopLoop := COPYSTR(CALHistoryLine.Code, StartIndent - 2, 3) = 'END';

          IF NOT StopLoop THEN BEGIN
            CALHistoryLine.SETRANGE("Line No.", CALHistoryLine."Line No.");
            CodeLine := CALHistoryLine.Code;
            WHILE CALHistoryLine.NEXT <> 0 DO
              CodeLine += CALHistoryLine.Code;
            CALHistoryLine.SETRANGE("Line No.");

            Identifier := FORMAT(ParIdentifier + '-' + FORMAT(CALHistoryLine."Line No." - StartCALLineNo));
            WrongThenUse := FALSE;

            IF CodeLine = '' THEN
              EmptyLineCounter += 1
            ELSE
              EmptyLineCounter := 0;
            IF EmptyLineCounter > 1 THEN
              AddCodingComment(Comment, CodingCheck::"Empty Lines", ctRemoveLine, CALHistoryLine."Line No.", 0, 0, Identifier);

            IndentCauseCounter += 1;
            CurrentIndentCounter := IndentCauseCounter;

            TempCodeLine[IndentCauseCounter] := CodeLine;

            IF STRPOS(LOWERCASE(CodeLine), '// ' + 'todo') > 0 THEN
              AddCodingComment(Comment, CodingCheck::TODO, ctToDo, CALHistoryLine."Line No.", 0, 0, '');

            IF STRPOS(LOWERCASE(CodeLine), '//' + 'todo') > 0 THEN
              AddCodingComment(Comment, CodingCheck::TODO, ctToDo, CALHistoryLine."Line No.", 0, 0, '');

            IF STRPOS(DELCHR(CodeLine), '//') = 1 THEN
              CodeLine := '';

            RecName2 := RecName;
            FOR i := 1 TO IndentCauseCounter - 1 DO
              IF IndentRecName[i] <> '' THEN
                RecName2 := IndentRecName[i];

            IF CheckCodeOption[CodingCheck::SetCurrentKey] THEN
              IF STRPOS(CodeLine, 'SETCURRENTKEY') > 0 THEN
                AnalyseSetCurrentKey(Comment, CALHistoryLine, Identifier, VariableBuffer, RecordNo, RecName2);

            IF CheckCodeOption[CodingCheck::CALCDATE] THEN
              IF STRPOS(CodeLine, 'CALCDATE') > 0 THEN
                AnalyseCalcDate(Comment, CALHistoryLine, Identifier);

            IF CheckCodeOption[CodingCheck::MARK] THEN
              IF STRPOS(CodeLine, 'MARK') > 0 THEN
                AnalyseMark(Comment, CALHistoryLine, Identifier);

            IF CheckDataOption[DataCheck::"Missing Relations"] OR CheckDataOption[DataCheck::Assignments] THEN
              IF STRPOS(CodeLine, ':=') > 0 THEN
                AnalyseAssignment(Comment, CALHistoryLine, Identifier, VariableBuffer, RecordNo, RecName2);

            IF CheckCodeOption[CodingCheck::"RUN Integer"] THEN
              AnalyseIntegerInRun(Comment, CALHistoryLine, Identifier);

            IF CheckDataOption[DataCheck::Transferfields] THEN
              IF STRPOS(CodeLine, 'TRANSFERFIELDS') > 0 THEN
                AnalyseTransferFields(Comment, CALHistoryLine, Identifier, VariableBuffer, RecName2, RecordNo);

            IF CheckCodeOption[CodingCheck::"Is Servicetier"] THEN
              IF STRPOS(CodeLine, 'IS' + 'SERVICETIER') > 0 THEN
                AddCodingComment(Comment, CodingCheck::"Is Servicetier", ctRemoveCommand, CALHistoryLine."Line No.", 0, 0, Identifier);

            GetLineProperties(
              CodeLine, Comment, Indent[IndentCauseCounter], IndentIsBegin[IndentCauseCounter], GoBack,
              IndentOpenEnd[IndentCauseCounter], IndentExpectedIndent[IndentCauseCounter], IndentRecName[IndentCauseCounter],
              LineBreakStartAt, CALHistoryLine."Line No.", RecName2, Identifier);

            Indent[IndentCauseCounter] -= StartIndent;
            IF Indent[IndentCauseCounter] < 0 THEN
              Indent[IndentCauseCounter] := 0;

            IF CheckCodeOption[CodingCheck::"Broken Lines"] THEN
              IF LineCanBeGlued(
                   CodeLine, CALHistoryLine."Line No.", FirstOpeningLine, TotalLineLength, StartIndent, CanBeGlued, StartedWithIf)
              THEN BEGIN
                AddCodingComment(
                  Comment, CodingCheck::"Broken Lines", ctLineDoesNotHaveToBeBroken,
                  FirstOpeningLine, PreviousCALLineNo, StartIndent, Identifier);
                FirstOpeningLine := 0;
              END;

            IF NOT IndentOpenEnd[IndentCauseCounter] THEN
              IF LastBegin > 0 THEN
                IndentLineCounter[LastBegin] += 1;
            IndentCALLineNo[IndentCauseCounter] := CALHistoryLine."Line No.";

            CurrentIndent := Indent[IndentCauseCounter];

            IF CheckCodeOption[CodingCheck::FIND] THEN
              IF STRPOS(CodeLine, 'FIND(''-'')') > 0 THEN
                AddCodingComment(Comment, CodingCheck::FIND, ctReplaceFindMin, CALHistoryLine."Line No.", 0, 0, Identifier);

            IF CheckCodeOption[CodingCheck::FIND] THEN
              IF STRPOS(CodeLine, 'FIND(''+'')') > 0 THEN
                AddCodingComment(Comment, CodingCheck::FIND, ctReplaceFindPlus, CALHistoryLine."Line No.", 0, 0, Identifier);

            SkipCheck := CodeLine = '';

            IF NOT IndentOpenEnd[IndentCauseCounter] AND
               (GoBack = GoBack::" ")
            THEN
              IF IndentCauseCounter > 2 THEN
                SkipCheck :=
                  (NOT IndentOpenEnd[IndentCauseCounter - 1]) AND
                  (Indent[IndentCauseCounter - 1] = Indent[IndentCauseCounter]);

            IF SkipCheck THEN
              IndentCauseCounter -= 1
            ELSE BEGIN

              CASE GoBack OF
                GoBack::"If" :
                  IF STRPOS(CodeLine, 'THEN') > 0 THEN
                    IF STRPOS(DELCHR(CodeLine), 'THEN') <> 1 THEN BEGIN
                      IF STRPOS(DELCHR(CodeLine), 'ELSE') <> 1 THEN BEGIN
                        WrongThenUse := TRUE;
                        AddCodingComment(
                          Comment, CodingCheck::"IF THEN", STRSUBSTNO(ctStartAtNewLine, 'THEN'),
                          CALHistoryLine."Line No.", 1, 0, Identifier);
                      END;
                      GoToPreviousIf(IndentCauseCounter, IndentIsBegin);

                      IF IndentCauseCounter >= 0 THEN
                        Indent[CurrentIndentCounter] := Indent[IndentCauseCounter];
                      IndentCauseCounter := CurrentIndentCounter;
                    END;

                GoBack::"Begin" :
                  BEGIN
                    IF PreviousOpenEnd THEN
                      IF PreviousIndentIsBegin = PreviousIndentIsBegin::" " THEN
                        IF STRPOS(PreviousCodeLine, 'BEGIN') = 0 THEN BEGIN
                          AddCodingComment(Comment, CodingCheck::"Missing ;", ctAddSemicolon, PreviousCALLineNo, 1, 0, Identifier);
                          IF LastBegin > 0 THEN
                            IndentLineCounter[LastBegin] += 1;
                        END;

                    GoToPreviousBegin(IndentCauseCounter, IndentIsBegin);
                    IF IndentCauseCounter >= 0 THEN BEGIN

                      IF NOT IndentOpenEnd[CurrentIndentCounter] THEN
                        IF LastBegin > 0 THEN
                          IndentLineCounter[LastBegin] -= 1;

                      IF PreviousOpenEnd THEN
                        IF LastBegin > 0 THEN
                          IndentLineCounter[LastBegin] += 1;

                      IF IndentLineCounter[IndentCauseCounter] < 2 THEN BEGIN
                        RemoveBeginEnd := TRUE;

                        IF PreviousGoBackWasIf THEN
                          IF DELCHR(CodeLine, '<>') <> 'END;' THEN
                            RemoveBeginEnd := FALSE
                          ELSE
                            IF NextLineStartWithElse(CALHistoryLine) THEN
                              RemoveBeginEnd := FALSE;

                        IF STRPOS(PreviousCodeLine, 'BEGIN') > 0 THEN
                          RemoveBeginEnd := FALSE;

                        IF STRPOS(PreviousCodeLine, 'THEN') > 0 THEN
                          RemoveBeginEnd := FALSE;

                        IF IndentCALLineNo[IndentCauseCounter] = CALHistoryLine."Line No." THEN
                          RemoveBeginEnd := FALSE;

                        IF RemoveBeginEnd THEN
                          IF IndentCALLineNo[IndentCauseCounter] > PreviousBeginEndLineNo THEN BEGIN
                            AddCodingComment(
                              Comment, CodingCheck::"BEGIN END", ctRemoveBegin,
                              IndentCALLineNo[IndentCauseCounter], 1, 0,
                              FORMAT(ParIdentifier + '-' + FORMAT(IndentCALLineNo[IndentCauseCounter] - StartCALLineNo) + '-BEGIN'));
                            AddCodingComment(
                              Comment, CodingCheck::"BEGIN END", ctRemoveEnd, CALHistoryLine."Line No.", 2, 0, Identifier + '-END');

                            PreviousBeginEndLineNo := IndentCALLineNo[IndentCauseCounter];
                          END;
                      END;
                    END;
                    IndentCauseCounter := CurrentIndentCounter;
                    GoToPreviousBegin(LastBegin, IndentIsBegin);
                    IF NOT IndentOpenEnd[CurrentIndentCounter] THEN
                      IF LastBegin > 0 THEN
                        IndentLineCounter[LastBegin] += 1;

                  END;
              END;

              IF IndentIsBegin[IndentCauseCounter] IN
                   [IndentIsBegin[IndentCauseCounter]::"Begin", IndentIsBegin[IndentCauseCounter]::"If Begin"]
              THEN BEGIN
                LastBegin := IndentCauseCounter;
                IF STRPOS(CodeLine, 'BEGIN') = STRLEN(CodeLine) - 4 THEN
                  IndentLineCounter[IndentCauseCounter] := 0
                ELSE
                  IndentLineCounter[IndentCauseCounter] := 99;
              END;

              IF (IndentIsBegin[IndentCauseCounter] IN
                   [IndentIsBegin[IndentCauseCounter]::"Begin", IndentIsBegin[IndentCauseCounter]::"If Begin"]) AND
                 ((PreviousGoBack IN [PreviousGoBack::"If", PreviousGoBack::"While"]) OR
                  (PreviousIndentIsBegin IN [PreviousIndentIsBegin::"If", PreviousIndentIsBegin::"While"]))
              THEN
                IF STRPOS(DELCHR(CodeLine), 'BEGIN') = 1 THEN BEGIN
                  IF STRPOS(PreviousCodeLine, 'THEN') = STRLEN(PreviousCodeLine) - 3 THEN
                    AddCodingComment(
                      Comment, CodingCheck::"IF THEN",
                      STRSUBSTNO(ctKeepTogether, 'THEN', 'BEGIN'), CALHistoryLine."Line No.", 2, 0, Identifier);
                  IF STRPOS(PreviousCodeLine, 'DO') = STRLEN(PreviousCodeLine) - 1 THEN
                    AddCodingComment(
                      Comment, CodingCheck::"IF THEN",
                      STRSUBSTNO(ctKeepTogether, 'DO', 'BEGIN'), CALHistoryLine."Line No.", 2, 0, Identifier);
                  IF STRPOS(PreviousCodeLine, 'ELSE') = STRLEN(PreviousCodeLine) - 3 THEN
                    AddCodingComment(
                      Comment, CodingCheck::"IF THEN",
                      STRSUBSTNO(ctKeepTogether, 'ELSE', 'BEGIN'), CALHistoryLine."Line No.", 2, 0, Identifier);
                END;

              IF DELCHR(CodeLine) = 'ELSE' THEN
                IF DELCHR(PreviousCodeLine) = 'END' THEN
                  IF PreviousGoBackWasIf THEN
                    AddCodingComment(
                      Comment, CodingCheck::"IF THEN",
                      STRSUBSTNO(ctKeepTogether, 'END', 'ELSE'), CALHistoryLine."Line No.", 2, 0, Identifier);

              ExpectedIndent := -0;
              IF PreviousCodeLine <> '' THEN
                LastCharacterPreviousLine := PreviousCodeLine[STRLEN(PreviousCodeLine)];

              IF LastCharacterPreviousLine = ':' THEN
                ExpectedIndent := GetIndentPreviousBegin(IndentCauseCounter, IndentIsBegin, Indent) + 4
              ELSE
                CASE GoBack OF

                  GoBack::" " :
                    IF IndentCauseCounter > 1 THEN
                      IF IndentOpenEnd[IndentCauseCounter - 1] THEN
                        ExpectedIndent := Indent[IndentCauseCounter - 1] + IndentExpectedIndent[IndentCauseCounter - 1]
                      ELSE
                        ExpectedIndent := Indent[IndentCauseCounter - 1];

                  GoBack::"Begin" :
                    BEGIN
                      StopLoop2 := FALSE;
                      i := IndentCauseCounter - 1;
                      WHILE (i > 0) AND NOT StopLoop2 DO
                        IF IndentIsBegin[i] IN [IndentIsBegin[i]::"Begin", IndentIsBegin[i]::"If Begin"] THEN BEGIN
                          StopLoop2 := TRUE;
                          ExpectedIndent := Indent[i];
                        END ELSE
                          i -= 1;
                    END;

                  GoBack::"If" :
                    BEGIN
                      StopLoop2 := FALSE;
                      i := IndentCauseCounter - 1;
                      WHILE (i > 0) AND NOT StopLoop2 DO
                        CASE IndentIsBegin[i] OF
                          IndentIsBegin[i]::" ", IndentIsBegin[i]::"While" :
                            i -= 1;

                          IndentIsBegin[i]::"Begin", IndentIsBegin[i]::"If Begin" :
                            BEGIN
                              StopLoop2 := TRUE;
                              ExpectedIndent := Indent[i] + 2;
                            END;

                          IndentIsBegin[i]::"If" :
                            BEGIN
                              StopLoop2 := TRUE;
                              ExpectedIndent := Indent[i];
                            END;
                        END;
                    END;

                  GoBack::"While" :
                    BEGIN
                      StopLoop2 := FALSE;
                      i := IndentCauseCounter - 1;
                      WHILE (i > 0) AND NOT StopLoop2 DO
                        CASE IndentIsBegin[i] OF
                          IndentIsBegin[i]::" ", IndentIsBegin[i]::"If" :
                            i -= 1;

                          IndentIsBegin[i]::"Begin", IndentIsBegin[i]::"If Begin" :
                            BEGIN
                              StopLoop2 := TRUE;
                              ExpectedIndent := Indent[i] + 2;
                            END;

                          IndentIsBegin[i]::"While" :
                            BEGIN
                              StopLoop2 := TRUE;
                              ExpectedIndent := Indent[i];
                            END;
                        END;

                    END;

                END;

              PreviousGoBackWasIf := FALSE;

              IF GoBack <> GoBack::" " THEN BEGIN
                CASE GoBack OF

                  GoBack::"Begin" :
                    GoToPreviousBegin(IndentCauseCounter, IndentIsBegin);

                  GoBack::"If" :
                    GoToPreviousIf(IndentCauseCounter, IndentIsBegin);

                  GoBack::"While" :
                    GoToPreviousWhile(IndentCauseCounter, IndentIsBegin);

                END;

                IF (GoBack IN [GoBack::"If", GoBack::"While"]) AND
                   (IndentIsBegin[IndentCauseCounter] IN
                     [IndentIsBegin[IndentCauseCounter]::"Begin", IndentIsBegin[IndentCauseCounter]::"If Begin"])
                THEN
                  IndentCauseCounter += 1
                ELSE
                  IF IndentCauseCounter = 0 THEN
                    IndentCauseCounter := 1;

                IF IndentIsBegin[IndentCauseCounter] IN
                     [IndentIsBegin[IndentCauseCounter]::"If",
                      IndentIsBegin[IndentCauseCounter]::"If Begin"]
                THEN
                  PreviousGoBackWasIf := TRUE;

                Indent[IndentCauseCounter] := Indent[CurrentIndentCounter];
                IndentIsBegin[IndentCauseCounter] := IndentIsBegin[CurrentIndentCounter];
                IndentOpenEnd[IndentCauseCounter] := IndentOpenEnd[CurrentIndentCounter];
                IndentExpectedIndent[IndentCauseCounter] := IndentExpectedIndent[CurrentIndentCounter];
                IndentLineCounter[IndentCauseCounter] := IndentLineCounter[CurrentIndentCounter];
                IndentCALLineNo[IndentCauseCounter] := IndentCALLineNo[CurrentIndentCounter];
                IndentRecName[IndentCauseCounter] := '';

                TempCodeLine[IndentCauseCounter] := TempCodeLine[CurrentIndentCounter];

                CurrentIndentCounter := IndentCauseCounter;

                IF (GoBack IN [GoBack::"If", GoBack::"While"]) AND
                   (IndentIsBegin[IndentCauseCounter] = IndentIsBegin[IndentCauseCounter]::" ") AND
                   (PreviousLineBreakStartAt <> 0)
                THEN
                  IndentIsBegin[IndentCauseCounter] := IndentIsBegin[IndentCauseCounter];

                IF IndentIsBegin[IndentCauseCounter] IN
                     [IndentIsBegin[IndentCauseCounter]::"Begin", IndentIsBegin[IndentCauseCounter]::"If Begin"]
                THEN
                  LastBegin := IndentCauseCounter;

              END;

              IF NOT IndentOpenEnd[CurrentIndentCounter] THEN BEGIN
                j := IndentCauseCounter;
                IF GoToStartOfBlock(IndentCauseCounter, IndentOpenEnd, IndentIsBegin) THEN
                  FOR i := IndentCauseCounter + 1 TO j DO
                    IF i > 0 THEN
                      IF IndentIsBegin[i] IN [IndentIsBegin[i]::"If", IndentIsBegin[i]::"If Begin"] THEN
                        PreviousGoBackWasIf := TRUE;
              END;

              IF (CurrentIndent <> ExpectedIndent) AND (LineBreakStartAt > 0) AND (PreviousLineBreakStartAt > 0) THEN BEGIN

                IF PreviousIndent < PreviousLineBreakStartAt - StartIndent THEN
                  PreviousIndent := PreviousLineBreakStartAt - StartIndent;

                AllowedMinIndent := PreviousLineBreakStartAt - StartIndent;
                AllowedMaxIndent := PreviousIndent + 2;

                IF CurrentIndent < AllowedMinIndent THEN
                  AddCodingComment(
                    Comment, CodingCheck::Indent,
                    STRSUBSTNO(ctWrongIndentAddAtLeast, AllowedMinIndent - CurrentIndent),
                    CALHistoryLine."Line No.", AllowedMinIndent - CurrentIndent, 0, Identifier)
                ELSE
                  IF CurrentIndent > AllowedMaxIndent THEN
                    AddCodingComment(
                      Comment, CodingCheck::Indent,
                      STRSUBSTNO(ctWrongIndentRemoveAtLeast, CurrentIndent - AllowedMaxIndent),
                      CALHistoryLine."Line No.", CurrentIndent - AllowedMaxIndent, 0, Identifier);

              END ELSE
                IF CurrentIndent <> ExpectedIndent THEN
                  IF CurrentIndent > ExpectedIndent THEN BEGIN
                    IF NOT WrongThenUse THEN
                      AddCodingComment(
                        Comment, CodingCheck::Indent,
                        STRSUBSTNO(ctWrongIndentRemove, CurrentIndent - ExpectedIndent),
                        CALHistoryLine."Line No.", CurrentIndent - ExpectedIndent, 0, Identifier);
                  END ELSE
                    AddCodingComment(
                      Comment, CodingCheck::Indent,
                      STRSUBSTNO(ctWrongIndentAdd, ExpectedIndent - CurrentIndent),
                      CALHistoryLine."Line No.", ExpectedIndent - CurrentIndent, 0, Identifier);

              IF NOT IndentOpenEnd[CurrentIndentCounter] THEN
                LineBreakStartAt := 0;

              PreviousIndent := Indent[CurrentIndentCounter];
              PreviousIndentIsBegin := IndentIsBegin[CurrentIndentCounter];
              PreviousLineBreakStartAt := LineBreakStartAt;
              PreviousGoBack := GoBack;
              PreviousCodeLine := CodeLine;
              PreviousOpenEnd :=
                IndentOpenEnd[CurrentIndentCounter] AND
                NOT (IndentIsBegin[CurrentIndentCounter] = IndentIsBegin[CurrentIndentCounter]::"Begin");
              PreviousCALLineNo := CALHistoryLine."Line No.";

            END;
          END;

        END;
      UNTIL StopLoop;

      IF PreviousOpenEnd THEN
        AddCodingComment(Comment, CodingCheck::"Missing ;", ctAddSemicolon, PreviousCALLineNo, 1, 0, Identifier);
    END;

    PROCEDURE GetLineProperties@21(CodeLine@1000 : Text;VAR Comment@1001 : Record 11102081;VAR StartAt@1002 : Integer;VAR IsBegin@1003 : ' ,Begin,If,If Begin,While';VAR GoBack@1004 : ' ,Begin,If,While';VAR OpenEnd@1005 : Boolean;VAR ExpectedIndent@1006 : Integer;VAR IndentRecName@1007 : Text;VAR LineBreakStartAt@1008 : Integer;CALLine@1009 : Integer;RecName@1010 : Text;Identifier@1011 : Code[100]);
    VAR
      Operator@1012 : Text;
      RestOfLine@1013 : Text;
      Statement@1014 : Text;
      TableStatementOpenTableName@1015 : Text;
      TableVarname@1016 : Text;
      Char@1017 : Char;
      BracketClosePos@1018 : ARRAY [20] OF Integer;
      BracketNoOfOperators@1019 : ARRAY [20] OF Integer;
      BracketOpenPos@1020 : ARRAY [20] OF Integer;
      BracketsOpen@1021 : Integer;
      BreakLinePos@1022 : Integer;
      BreakPos@1023 : ARRAY [100] OF Integer;
      i@1024 : Integer;
      j@1025 : Integer;
      LengthFirstStatement@1026 : Integer;
      LineType@1027 : Integer;
      NaturalBreak@1028 : ARRAY [100] OF Integer;
      NoOfBrackets@1029 : Integer;
      NoOfBreakPos@1030 : Integer;
      NoOfNaturalBreaks@1031 : Integer;
      NoOfOpenPos@1032 : Integer;
      Pos@1033 : Integer;
      PosPrevStatement@1034 : Integer;
      RemarkOpen@1035 : Integer;
      TextStartedAt@1036 : Integer;
      DLT@1037 : ' ,...,...;,BEGIN,IF ...,IF ... THEN,IF ... THEN BEGIN,THEN,THEN BEGIN,... THEN,... THEN BEGIN,CASE ... OF,CASE ...,IN CASE ...,IN CASE ... :,IN CASE ... : BEGIN,REPEAT,UNTIL ...,UNTIL ... ;,END;,END,END ELSE,END ELSE;,END ELSE BEGIN,ELSE,ELSE BEGIN,WHILE,WHILE ...,WHILE ... DO,WHILE ... DO BEGIN';
      MessageType@1038 : ' ,= True,= False,ELSE New Line';
      TableStatementOpen@1039 : ' ,Single,Multiple';
      BeginPresent@1040 : Boolean;
      BracketCommentAdded@1041 : Boolean;
      BracketParameter@1042 : ARRAY [20] OF Boolean;
      DelBrackets@1043 : Boolean;
      DelClose@1044 : Boolean;
      DelOpen@1045 : Boolean;
      DialogPresent@1046 : Boolean;
      EndOfLineExpected@1047 : Boolean;
      LineBreakStartCreated@1048 : Boolean;
      MessageAdded@1049 : ARRAY [10] OF Boolean;
      NextIsRecName@1050 : Boolean;
      StartParameters@1051 : Boolean;
      StatementReady@1052 : Boolean;
      TestFirstCommand@1053 : Boolean;
      TextOpen@1054 : Boolean;
      UseThisBreakPos@1055 : Boolean;
      VariableOpen@1056 : Boolean;
      ctAddSpace@1057 : TextConst 'DEU=Add space at position %1;ENU=Add space at position %1;ESP=Add space at position %1;FRA=Add space at position %1;NLD=Voeg spatie toe op positie %1;DEA=Add space at position %1';
      ctBreakLine@1058 : TextConst 'DEU=Break the line at position %1;ENU=Break the line at position %1;ESP=Break the line at position %1;FRA=Break the line at position %1;NLD=Breek de regel op positie %1;DEA=Break the line at position %1';
      ctIsFalse@1059 : TextConst 'DEU="Use NOT instead of ''= FALSE''";ENU="Use NOT instead of ''= FALSE''";ESP="Use NOT instead of ''= FALSE''";FRA="Use NOT instead of ''= FALSE''";NLD="Gebruik ''NOT'' in plaats van ''= FALSE''";DEA="Use NOT instead of ''= FALSE''"';
      ctIsTrue@1060 : TextConst 'DEU="Remove ''= TRUE''";ENU="Remove ''= TRUE''";ESP="Remove ''= TRUE''";FRA="Remove ''= TRUE''";NLD="Verwijder ''= TRUE''";DEA="Remove ''= TRUE''"';
      ctNewLineAfterElse@1061 : TextConst 'DEU=Start new line after ELSE;ENU=Start new line after ELSE;ESP=Start new line after ELSE;FRA=Start new line after ELSE;NLD=Begin nieuwe regel na ''ELSE'';DEA=Start new line after ELSE';
      ctRemoveBracketClose@1062 : TextConst 'DEU=Remove '')'' at position %1;ENU=Remove '')'' at position %1;ESP=Remove '')'' at position %1;FRA=Remove '')'' at position %1;NLD=Verwijder '')'' op positie %1;DEA=Remove '')'' at position %1';
      ctRemoveBracketOpen@1063 : TextConst 'DEU=Remove ''('' at position %1;ENU=Remove ''('' at position %1;ESP=Remove ''('' at position %1;FRA=Remove ''('' at position %1;NLD=Verwijder ''('' op positie %1;DEA=Remove ''('' at position %1';
      ctRemoveBrackets@1064 : TextConst 'DEU=Remove ''()'';ENU=Remove ''()'';ESP=Remove ''()'';FRA=Remove ''()'';NLD=Verwijder ''()'';DEA=Remove ''()''';
      ctRemoveSemicolon@1065 : TextConst 'DEU="Remove '';''";ENU="Remove '';''";ESP="Remove '';''";FRA="Remove '';''";NLD="Verwijder '';''";DEA="Remove '';''"';
      ctRemoveSpace@1066 : TextConst 'DEU=Remove space at position %1;ENU=Remove space at position %1;ESP=Remove space at position %1;FRA=Remove space at position %1;NLD=Verwijder spatie op positie %1;DEA=Remove space at position %1';
      ctRemoveTablename@1067 : TextConst 'DEU=Remove table name;ENU=Remove table name;ESP=Remove table name;FRA=Remove table name;NLD=Verwijder tabelnaam;DEA=Remove table name';
      ctStartAtNewLine@1068 : TextConst 'DEU=''%1'' must start at new line;ENU=''%1'' must start at new line;ESP=''%1'' must start at new line;FRA=''%1'' must start at new line;NLD=''%1'' moet beginnen op nieuwe regel;DEA=''%1'' must start at new line';
      ctStartNewLine@1069 : TextConst 'DEU=Start new line at position %1;ENU=Start new line at position %1;ESP=Start new line at position %1;FRA=Start new line at position %1;NLD=Begin nieuwe regel op position %1;DEA=Start new line at position %1';
      ctStartWithComma@1070 : TextConst 'DEU=Put comma at the previous line;ENU=Put comma at the previous line;ESP=Put comma at the previous line;FRA=Put comma at the previous line;NLD=Plaats comma op de vorige regel;DEA=Put comma at the previous line';
      ctUseATextConst@1071 : TextConst 'DEU=Replace text by text constant;ENU=Replace text by text constant;ESP=Replace text by text constant;FRA=Replace text by text constant;NLD=Vervang tekst door tekstconstante;DEA=Replace text by text constant';
    BEGIN
      IsBegin := IsBegin::" ";
      GoBack := GoBack::" ";
      OpenEnd := TRUE;
      ExpectedIndent := 0;
      IndentRecName := '';
      StartParameters := TRUE;

      IF RecName = '' THEN
        RecName := 'REC';

      Pos := STRPOS(CodeLine, '  //');
      WHILE Pos > 0 DO BEGIN
        CodeLine := DELSTR(CodeLine, Pos, 1);
        Pos := STRPOS(CodeLine, '  //');
      END;

      i := 1;
      WHILE (CodeLine[i] = ' ') AND (i <= STRLEN(CodeLine)) DO
        i += 1;

      StartAt := i;

      IF CodeLine[StartAt] = ',' THEN
        AddCodingComment(Comment, CodingCheck::"Line Break", ctStartWithComma, CALLine, StartAt, 1, Identifier);

      FOR i := i TO STRLEN(CodeLine) DO BEGIN

        Char := CodeLine[i];

        EndOfLineExpected := FALSE;

        CASE TRUE OF

          RemarkOpen > 0 :
            BEGIN
              IF Char = '{' THEN
                RemarkOpen += 1;
              IF Char = '}' THEN
                RemarkOpen -= 1;
            END;

          TextOpen :
            IF Char = '''' THEN BEGIN
              TextOpen := FALSE;
              IF DialogPresent AND (i - TextStartedAt > 1) THEN
                AddCodingComment(Comment, CodingCheck::Text, ctUseATextConst, CALLine, TextStartedAt, 0, Identifier);
            END;

          VariableOpen :
            BEGIN
              Statement += FORMAT(Char);
              IF Char = '"' THEN
                VariableOpen := FALSE;
            END;

          Char = '''' :
            BEGIN
              TextOpen := TRUE;
              TextStartedAt := i;
            END;

          Char = '"' :
            BEGIN
              Statement += FORMAT(Char);
              VariableOpen := TRUE;
            END;

          Char = '{' :
            BEGIN
              RemarkOpen += 1;
              AddBracketComment(Comment, CALLine, Identifier, BracketCommentAdded);
            END;

          Char = '}' :
            AddBracketComment(Comment, CALLine, Identifier, BracketCommentAdded);

          Char IN ['/', ';', ':', '.', ',', '(', ')', '[', ']', ' ', '=', '+', '-', '*', '/', '>', '<'] :
            IF (Char = '/') AND (CodeLine[i + 1] = '/') THEN
              i := 1024
            ELSE BEGIN

              Operator := FORMAT(Char);
              StatementReady := TRUE;

              IF (Operator IN ['+', '-', '/', '*', ':']) AND (CodeLine[i + 1] = '=') THEN BEGIN
                i += 1;
                Operator += FORMAT(CodeLine[i]);
              END;

              IF (Operator IN ['<', '>']) AND (CodeLine[i + 1] IN ['>', '=']) THEN BEGIN
                i += 1;
                Operator += FORMAT(CodeLine[i]);
              END;

              IF (Operator = ':') AND (CodeLine[i + 1] = ':') THEN BEGIN
                i += 1;
                Operator += FORMAT(CodeLine[i]);
              END;

              IF (Operator = '(') AND (CodeLine[i + 1] = ')') THEN BEGIN
                i += 1;
                Operator += FORMAT(CodeLine[i]);
                AddCodingComment(Comment, CodingCheck::"Redundant ()", ctRemoveBrackets, CALLine, i - 1, 0, Identifier);
              END;

              IF (Operator = ' ') AND (CodeLine[i - 1] = ' ') THEN
                AddCodingComment(Comment, CodingCheck::"Redundant Spaces", STRSUBSTNO(ctRemoveSpace, i), CALLine, i, 0, Identifier);

              IF (Operator IN [')', ',']) AND (CodeLine[i - 1] = ' ') AND (CodeLine[i - 2] <> ' ') AND (i > StartAt) THEN
                AddCodingComment(
                  Comment, CodingCheck::"Redundant Spaces", STRSUBSTNO(ctRemoveSpace, i - 1), CALLine, i - 1, 0, Identifier);

              IF (Operator = '(') AND (CodeLine[i + 1] = ' ') AND (CodeLine[i + 2] <> ' ') THEN
                AddCodingComment(
                  Comment, CodingCheck::"Redundant Spaces", STRSUBSTNO(ctRemoveSpace, i + 1), CALLine, i + 1, 0, Identifier);

              IF (Operator = '::') AND (CodeLine[i + 1] = ' ') AND (CodeLine[i + 2] <> ' ') THEN
                AddCodingComment(
                  Comment, CodingCheck::"Redundant Spaces", STRSUBSTNO(ctRemoveSpace, i + 1), CALLine, i + 1, 0, Identifier);

              IF (Operator = '::') AND (CodeLine[i - 2] = ' ') AND (CodeLine[i - 3] <> ' ') THEN
                AddCodingComment(
                  Comment, CodingCheck::"Redundant Spaces", STRSUBSTNO(ctRemoveSpace, i - 2), CALLine, i - 2, 0, Identifier);

              IF (Operator = '.') AND (CodeLine[i + 1] = ' ') THEN
                AddCodingComment(
                  Comment, CodingCheck::"Redundant Spaces", STRSUBSTNO(ctRemoveSpace, i + 1),
                  CALLine, i + 1, 0, Identifier);

              IF NOT (Operator IN ['(', ')']) THEN
                StartParameters := FALSE;

            END;

          ELSE BEGIN
            Statement += FORMAT(Char);
            IF i = STRLEN(CodeLine) THEN
              StatementReady := TRUE;
          END;

        END;
        IF StatementReady THEN BEGIN

          IF NOT (Statement IN ['', ' ']) THEN
            CASE Statement OF

              'NOT', 'AND', 'OR', 'XOR' :
                BEGIN
                  StartParameters := FALSE;

                  FOR j := NoOfBrackets DOWNTO 1 DO
                    IF BracketClosePos[j] = 0 THEN
                      BracketNoOfOperators[j] += 1;

                END;

              'BEGIN' :
                BEGIN
                  BeginPresent := TRUE;
                  IF Operator = ';' THEN
                    AddCodingComment(Comment, CodingCheck::"Missing ;", ctRemoveSemicolon, CALLine, 2, 0, Identifier);

                  CASE LineType OF
                    DLT::" ", DLT::"..." :
                      LineType := DLT::"BEGIN";

                    DLT::"ELSE" :
                      LineType := DLT::"ELSE BEGIN";

                    DLT::"END ELSE" :
                      LineType := DLT::"END ELSE BEGIN";

                    DLT::"IF ... THEN" :
                      LineType := DLT::"IF ... THEN BEGIN";

                    DLT::"THEN" :
                      LineType := DLT::"THEN BEGIN";

                    DLT::"WHILE ... DO" :
                      LineType := DLT::"WHILE ... DO BEGIN";

                    DLT::"IN CASE ... :" :
                      BEGIN
                        LineType := DLT::"IN CASE ... : BEGIN";
                        AddCodingComment(
                          Comment, CodingCheck::"Line Break", STRSUBSTNO(ctStartAtNewLine, 'BEGIN'),
                          CALLine, STRPOS(CodeLine, 'BEGIN'), 0, Identifier);
                      END;

                    DLT::"... THEN" :
                      LineType := DLT::"... THEN BEGIN";

                  END;

                  EndOfLineExpected := TRUE;
                  StartParameters := FALSE;

                END;

              'CALCFIELDS', 'CALCSUMS', 'SETCURRENTKEY' :
                BEGIN
                  TableStatementOpen := TableStatementOpen::Multiple;
                  IF LineType = DLT::" " THEN
                    LineType := DLT::"...";
                  StartParameters := TRUE;
                END;

              'CASE' :
                BEGIN
                  LineType := DLT::"CASE ...";
                  StartParameters := FALSE;
                END;

              'DO' :
                BEGIN
                  IF LineType = DLT::"..." THEN
                    AddCodingComment(Comment, CodingCheck::"IF THEN", STRSUBSTNO(ctStartAtNewLine, 'DO'), CALLine, 3, 0, Identifier);

                  CASE LineType OF
                    DLT::" ", DLT::"...":
                      BEGIN
                        LineType := DLT::"THEN";
                        GoBack := GoBack::"While";
                      END;

                    DLT::"IF ..." :
                      LineType := DLT::"IF ... THEN";

                    DLT::"WHILE ..." :
                      LineType := DLT::"WHILE ... DO";

                  END;

                  IsBegin := IsBegin::"While";

                  EndOfLineExpected := TRUE;
                  StartParameters := FALSE;

                  NoOfNaturalBreaks += 1;
                  IF i = STRLEN(CodeLine) THEN
                    NaturalBreak[NoOfNaturalBreaks] := i - 1
                  ELSE
                    NaturalBreak[NoOfNaturalBreaks] := i - 2;

                END;

              'ELSE' :
                BEGIN

                  CASE LineType OF
                    DLT::" " :
                      LineType := DLT::"ELSE";

                    DLT::"END" :
                      LineType := DLT::"END ELSE";

                    ELSE
                      TestFirstCommand := TRUE;
                  END;

                  IF GoBack = GoBack::" " THEN
                    GoBack := GoBack::"If";

                  StartParameters := FALSE;

                  NoOfNaturalBreaks += 1;
                  IF i = STRLEN(CodeLine) THEN
                    NaturalBreak[NoOfNaturalBreaks] := i - 3
                  ELSE
                    NaturalBreak[NoOfNaturalBreaks] := i - 4;

                END;

              'END' :
                BEGIN
                  LineType := DLT::"END";
                  GoBack := GoBack::"Begin";

                  TestFirstCommand := TRUE;
                  EndOfLineExpected := TRUE;

                  StartParameters := FALSE;

                END;

              'FALSE' :
                BEGIN
                  IF STRPOS(CodeLine, ' = FALSE') > 0 THEN
                    IF NOT MessageAdded[MessageType::"= False"] THEN BEGIN
                      AddCodingComment(Comment, CodingCheck::"= FALSE", ctIsFalse, CALLine, 0, 0, Identifier);
                      MessageAdded[MessageType::"= False"] := TRUE;
                    END;
                  IF LineType = DLT::" " THEN
                    LineType := DLT::"...";
                  StartParameters := FALSE;
                END;

              'FOR', 'WHILE' :
                BEGIN
                  LengthFirstStatement := STRLEN(Statement);
                  IF LineType = DLT::" " THEN
                    LineType := DLT::"WHILE ...";

                  TestFirstCommand := TRUE;
                  StartParameters := FALSE;

                  NoOfNaturalBreaks += 1;
                  NaturalBreak[NoOfNaturalBreaks] := i;

                END;

              'IF' :
                BEGIN
                  LengthFirstStatement := 2;
                  LineType := DLT::"IF ...";
                  IsBegin := IsBegin::"If";
                  TestFirstCommand := TRUE;
                  StartParameters := FALSE;

                  NoOfNaturalBreaks += 1;
                  NaturalBreak[NoOfNaturalBreaks] := i;

                END;

              'IN' :
                BEGIN
                  BracketsOpen += 1;
                  StartParameters := FALSE;

                  FOR j := NoOfBrackets DOWNTO 1 DO
                    IF BracketClosePos[j] = 0 THEN
                      BracketNoOfOperators[j] += 1;

                END;

              'OF' :
                BEGIN
                  CASE LineType OF
                    DLT::"CASE ..." :
                      LineType := DLT::"CASE ... OF";

                  END;

                  EndOfLineExpected := TRUE;
                  StartParameters := FALSE;
                END;

              'REPEAT' :
                BEGIN
                  CASE LineType OF
                    DLT::"IF ... THEN" :
                      LineType := DLT::"IF ... THEN BEGIN";
                    DLT::"WHILE ... DO" :
                      LineType := DLT::"WHILE ... DO BEGIN";
                    ELSE
                      LineType := DLT::"REPEAT";
                  END;

                  TestFirstCommand := TRUE;
                  EndOfLineExpected := TRUE;
                  StartParameters := FALSE;
                END;

              'SETRANGE', 'SETFILTER', 'GETFILTER', 'GETRANGEMIN', 'GETRANGEMAX', 'COPYFILTER',
              'FIELDNO', 'FIELDNAME', 'FIELDCAPTION',
              'VALIDATE', 'MODIFYALL', 'TESTFIELD', 'FIELDERROR', 'FIELDACTIVE', 'RELATION' :
                BEGIN
                  TableStatementOpen := TableStatementOpen::Single;
                  TableStatementOpenTableName := TableVarname;
                  IF LineType = DLT::" " THEN
                    LineType := DLT::"...";
                  StartParameters := TRUE;
                END;

              'THEN' :
                BEGIN

                  EndOfLineExpected := TRUE;

                  CASE LineType OF
                    DLT::" " :
                      BEGIN
                        GoBack := GoBack::"If";
                        LineType := DLT::"THEN";
                      END;

                    DLT::"..." :
                      BEGIN
                        LineType := DLT::"... THEN";
                        GoBack := GoBack::"If";
                      END;

                    DLT::"IF ..." :
                      LineType := DLT::"IF ... THEN";

                  END;

                  IsBegin := IsBegin::"If";
                  StartParameters := FALSE;

                  NoOfNaturalBreaks += 1;
                  IF i = STRLEN(CodeLine) THEN
                    NaturalBreak[NoOfNaturalBreaks] := i - 3
                  ELSE
                    NaturalBreak[NoOfNaturalBreaks] := i - 4;

                END;

              'TRUE' :
                BEGIN
                  IF STRPOS(CodeLine, ' = TRUE') > 0 THEN
                    IF NOT MessageAdded[MessageType::"= True"] THEN BEGIN
                      AddCodingComment(Comment, CodingCheck::"= TRUE", ctIsTrue, CALLine, 0, 0, Identifier);
                      MessageAdded[MessageType::"= True"] := TRUE;
                    END;
                  IF LineType = DLT::" " THEN
                    LineType := DLT::"...";
                  StartParameters := FALSE;
                END;

              'UNTIL' :
                BEGIN
                  LineType := DLT::"UNTIL ...";
                  GoBack := GoBack::"Begin";
                  TestFirstCommand := TRUE;
                  StartParameters := FALSE;

                  NoOfNaturalBreaks += 1;
                  NaturalBreak[NoOfNaturalBreaks] := i;

                END;

              'WITH' :
                BEGIN
                  LineType := DLT::"WHILE ...";
                  NextIsRecName := TRUE;
                  TestFirstCommand := TRUE;
                  StartParameters := FALSE;
                END;

              ELSE BEGIN
                CASE LineType OF

                  DLT::"ELSE", DLT::"ELSE BEGIN" :
                    IF NOT MessageAdded[MessageType::"ELSE New Line"] THEN BEGIN
                      AddCodingComment(Comment, CodingCheck::"IF THEN", ctNewLineAfterElse, CALLine, 4, PosPrevStatement, Identifier);
                      MessageAdded[MessageType::"ELSE New Line"] := TRUE;
                    END;

                  DLT::" " :
                    LineType := DLT::"...";

                END;

                IF Statement = RecName THEN
                  IF Operator = '.' THEN
                    IF NOT (COPYSTR(CodeLine, i + 1, 6) IN ['IMPORT', 'EXPORT', 'HASVAL']) THEN
                      AddCodingComment(Comment, CodingCheck::"Redundant Tablename", ctRemoveTablename, CALLine, i, 0, Identifier);

                IF NextIsRecName THEN BEGIN
                  IndentRecName := Statement;
                  NextIsRecName := FALSE;
                END;

                StartParameters := TRUE;

              END;

            END;

          IF Statement IN ['CONFIRM', 'ERROR', 'MESSAGE', 'STRMENU'] THEN
            DialogPresent := TRUE;

          PosPrevStatement := i;

          IF NOT (Operator IN ['', ' ']) THEN BEGIN

            IF Operator IN ['(', '['] THEN BEGIN
              BracketsOpen += 1;
              AddBreakPos(NoOfBreakPos, NoOfOpenPos, BreakPos, i + 1);
            END;

            IF Operator IN [')', ']'] THEN BEGIN
              NoOfBreakPos -= 1;
              NoOfOpenPos -= 1;
              BracketsOpen -= 1;
              TableStatementOpen := TableStatementOpen::" ";
            END;

            IF Operator = ';' THEN BEGIN

              CASE LineType OF

                DLT::" " :
                  LineType := DLT::"...;";

                DLT::"..." :
                  LineType := DLT::"...;";

                DLT::"END" :
                  LineType := DLT::"END;";

                DLT::"IF ... THEN" :
                  LineType := DLT::"...;";

                DLT::"WHILE ..." :
                  LineType := DLT::"...;";

                DLT::"UNTIL ..." :
                  LineType := DLT::"UNTIL ... ;";

              END;

              IF NOT BeginPresent THEN BEGIN
                BracketsOpen := -99;
                EndOfLineExpected := TRUE;
                OpenEnd := FALSE;
                IF LineBreakStartCreated THEN
                  LineBreakStartAt := 0;
              END;

              NoOfNaturalBreaks += 1;
              NaturalBreak[NoOfNaturalBreaks] := i;

            END;

            IF Operator IN ['=', '<', '>', '+', '*', '/'] THEN BEGIN

              IF NOT (CodeLine[i - 1] IN [' ', '(']) THEN
                AddCodingComment(
                  Comment, CodingCheck::"Missing Spaces", STRSUBSTNO(ctAddSpace, i - StartAt), CALLine, i, 0, Identifier);

              IF (CodeLine[i + 1] <> ' ') AND (STRLEN(CodeLine) >= i + 1) THEN
                AddCodingComment(
                  Comment, CodingCheck::"Missing Spaces", STRSUBSTNO(ctAddSpace, i + 1 - StartAt),
                  CALLine, i + 1, 0, Identifier);

              FOR j := NoOfBrackets DOWNTO 1 DO
                IF BracketClosePos[j] = 0 THEN
                  BracketNoOfOperators[j] += 1;

            END;

            IF Operator = '-' THEN
              FOR j := NoOfBrackets DOWNTO 1 DO
                IF BracketClosePos[j] = 0 THEN
                  BracketNoOfOperators[j] += 1;

            IF Operator IN ['<=', '>=', '<>'] THEN BEGIN
              IF CodeLine[i - 2] <> ' ' THEN
                AddCodingComment(
                  Comment, CodingCheck::"Missing Spaces", STRSUBSTNO(ctAddSpace, i - 2 - StartAt),
                  CALLine, i - 1, 0, Identifier);

              IF (CodeLine[i + 1] <> ' ') AND (STRLEN(CodeLine) >= i + 1) THEN
                AddCodingComment(
                  Comment, CodingCheck::"Missing Spaces", STRSUBSTNO(ctAddSpace, i + 1 - StartAt),
                  CALLine, i + 1, 0, Identifier);

              FOR j := NoOfBrackets DOWNTO 1 DO
                IF BracketClosePos[j] = 0 THEN
                  BracketNoOfOperators[j] += 1;

            END;

            IF Operator IN [':=', '+=', '-=', '/=', '*='] THEN BEGIN

              LineBreakStartAt := StartAt + 2;
              LineBreakStartCreated := TRUE;

              AddBreakPos(NoOfBreakPos, NoOfOpenPos, BreakPos, i + 1);

              IF CodeLine[i - 2] <> ' ' THEN
                AddCodingComment(
                  Comment, CodingCheck::"Missing Spaces", STRSUBSTNO(ctAddSpace, i - 2 - StartAt),
                  CALLine, i - 1, 0, Identifier);

              IF (CodeLine[i + 1] <> ' ') AND (STRLEN(CodeLine) >= i + 1) THEN
                AddCodingComment(
                  Comment, CodingCheck::"Missing Spaces", STRSUBSTNO(ctAddSpace, i + 1 - StartAt),
                  CALLine, i + 1, 0, Identifier);

              TableStatementOpen := TableStatementOpen::" ";
              StartParameters := FALSE;

              NoOfNaturalBreaks += 1;
              NaturalBreak[NoOfNaturalBreaks] := i + 1;

            END;

            IF Operator = ':' THEN
              LineType := DLT::"IN CASE ... :";

            IF Operator = ',' THEN
              IF TableStatementOpen = TableStatementOpen::Single THEN
                TableStatementOpen := TableStatementOpen::" ";

            IF Operator = '.' THEN
              IF TableStatementOpen <> TableStatementOpen::" " THEN BEGIN
                IF TableStatementOpenTableName IN ['', Statement] THEN
                  AddCodingComment(Comment, CodingCheck::"Tablename SETRANGE", ctRemoveTablename, CALLine, i, 0, Identifier);
              END ELSE
                TableVarname := Statement;

          END;

          IF Operator = '(' THEN BEGIN
            NoOfBrackets += 1;
            BracketOpenPos[NoOfBrackets] := i;
            BracketParameter[NoOfBrackets] := StartParameters;

          END;

          IF Operator = ')' THEN
            FOR j := NoOfBrackets DOWNTO 1 DO
              IF BracketClosePos[j] = 0 THEN BEGIN
                BracketClosePos[j] := i;
                j := 0;
              END;

          IF Operator = ',' THEN
            CASE CommaSpaceCheck OF

              CommaSpaceCheck::Mandatory :
                IF (i < STRLEN(DELCHR(CodeLine, '>'))) AND (CodeLine[i + 1] <> ' ') THEN
                  AddComment(Comment, CheckType::"Comma Space", 1, STRSUBSTNO(ctAddSpace, i + 1), CALLine, i + 1, 0, Identifier);

              CommaSpaceCheck::Prohibited :
                IF (i < STRLEN(DELCHR(CodeLine, '>'))) AND (CodeLine[i + 1] = ' ') THEN
                  IF COPYSTR(CodeLine, i + 2, 2) <> '//' THEN
                    AddComment(Comment, CheckType::"Comma Space", 1, STRSUBSTNO(ctRemoveSpace, i + 1), CALLine, i + 1, 1, Identifier);

            END;

          IF TestFirstCommand THEN BEGIN

            IF DELCHR(DELSTR(CodeLine, i - STRLEN(Statement)), '=') <> '' THEN
              AddCodingComment(
                Comment, CodingCheck::"IF THEN", STRSUBSTNO(ctStartAtNewLine, Statement),
                CALLine, 4, i - STRLEN(Statement), Identifier);

            TestFirstCommand := FALSE;
          END;

          Statement := '';
          Operator := '';
          StatementReady := FALSE;

          IF EndOfLineExpected THEN BEGIN
            BreakLinePos := i + 1;
            RestOfLine := COPYSTR(CodeLine, i + 1);
            WHILE (STRPOS(RestOfLine, 'ELSE') = 1) OR
                  (STRPOS(RestOfLine, 'BEGIN') = 1) OR
                  (STRPOS(RestOfLine, ' ') = 1) OR
                  (STRPOS(RestOfLine, ';') = 1) OR
                  (STRPOS(RestOfLine, '//') = 1)
            DO BEGIN
              IF STRPOS(RestOfLine, 'ELSE') = 1 THEN BEGIN
                BreakLinePos += 4;
                RestOfLine := COPYSTR(RestOfLine, 5);
              END;
              IF STRPOS(RestOfLine, 'BEGIN') = 1 THEN BEGIN
                BreakLinePos += 5;
                RestOfLine := COPYSTR(RestOfLine, 6);
              END;
              IF STRPOS(RestOfLine, ' ') = 1 THEN BEGIN
                BreakLinePos += 1;
                RestOfLine := COPYSTR(RestOfLine, 2);
              END;
              IF STRPOS(RestOfLine, ';') = 1 THEN BEGIN
                BreakLinePos += 1;
                RestOfLine := COPYSTR(RestOfLine, 2);
              END;
              IF STRPOS(RestOfLine, '//') = 1 THEN
                RestOfLine := '';

              IF STRPOS(RestOfLine, 'IF') = 1 THEN
                RestOfLine := '';

            END;

            IF RestOfLine <> '' THEN
              AddCodingComment(
                Comment, CodingCheck::"Line Break", STRSUBSTNO(ctStartNewLine, BreakLinePos), CALLine, BreakLinePos, 0, Identifier);
          END;

        END;

      END;

      FOR i := 1 TO NoOfBrackets DO
        IF (BracketOpenPos[i] <> 0) AND (BracketClosePos[i] <> 0) THEN
          IF (BracketClosePos[i] > BracketOpenPos[i]) AND
             ((BracketClosePos[i] - BracketOpenPos[i]) > 1)
          THEN BEGIN
            DelBrackets := NOT BracketParameter[i] AND (BracketNoOfOperators[i] = 0);
            IF NOT DelBrackets THEN BEGIN
              DelOpen := FALSE;
              DelClose := FALSE;
              FOR j := 1 TO NoOfNaturalBreaks DO BEGIN

                IF NaturalBreak[j] <= BracketOpenPos[i] THEN
                  DelOpen := DELCHR(COPYSTR(CodeLine, NaturalBreak[j], BracketOpenPos[i] - NaturalBreak[j]), '<>') = '';

                IF NaturalBreak[j] >= BracketClosePos[i] THEN
                  DelClose := DELCHR(COPYSTR(CodeLine, BracketClosePos[i] + 1, NaturalBreak[j] - BracketClosePos[i] - 1), '<>') = '';

              END;
              DelBrackets := DelOpen AND DelClose;

            END;
            IF DelBrackets THEN BEGIN
              AddCodingComment(
                Comment, CodingCheck::"Redundant ()",
                STRSUBSTNO(ctRemoveBracketOpen, BracketOpenPos[i]), CALLine, BracketOpenPos[i], 0, Identifier);
              AddCodingComment(
                Comment, CodingCheck::"Redundant ()",
                STRSUBSTNO(ctRemoveBracketClose, BracketClosePos[i]), CALLine, BracketClosePos[i], 0, Identifier);

            END;
          END;

      IF (NoOfBreakPos > 1) AND OpenEnd THEN BEGIN
        i := 1;
        WHILE (i <= NoOfBreakPos) AND NOT UseThisBreakPos DO BEGIN
          IF i = 1 THEN
            UseThisBreakPos := STRLEN(DELCHR(DELSTR(CodeLine, BreakPos[i]))) > 3
          ELSE
            UseThisBreakPos := (BreakPos[i] - BreakPos[i - 1] > 3) AND (COPYSTR(CodeLine, BreakPos[i] + 1) <> '');

          IF UseThisBreakPos THEN
            AddCodingComment(
              Comment, CodingCheck::"Line Break", STRSUBSTNO(ctBreakLine, BreakPos[i]),
              CALLine, BreakPos[i], 0, Identifier);
          i += 1;
        END;
      END;
      DLT := LineType;

      IF LineType IN [
           DLT::"BEGIN", DLT::"WHILE ... DO BEGIN",
           DLT::"CASE ... OF", DLT::"REPEAT", DLT::"END ELSE BEGIN", DLT::"ELSE BEGIN",
           DLT::"IN CASE ... : BEGIN"]
      THEN BEGIN
        IsBegin := IsBegin::"Begin";
        ExpectedIndent := 2;
        LineBreakStartAt := 0;
      END;

      IF LineType IN [DLT::"IF ... THEN BEGIN", DLT::"THEN BEGIN", DLT::"... THEN BEGIN"] THEN BEGIN
        IsBegin := IsBegin::"If Begin";
        ExpectedIndent := 2;
        LineBreakStartAt := 0;
      END;

      IF LineType IN [DLT::"IF ... THEN", DLT::"THEN", DLT::"ELSE", DLT::"END ELSE", DLT::"WHILE ... DO", DLT::"... THEN"] THEN BEGIN
        ExpectedIndent := 2;
        LineBreakStartAt := 0;
      END;

      IF LineType = DLT::"IN CASE ... :" THEN
        ExpectedIndent := 2;

      IF LineType = DLT::"IF ..." THEN BEGIN
        ExpectedIndent := LengthFirstStatement + 1;
        LineBreakStartAt := StartAt + LengthFirstStatement + 1;
      END;

      IF LineType = DLT::"UNTIL ..." THEN BEGIN
        ExpectedIndent := 6;
        LineBreakStartAt := StartAt + 6;
      END;

      IF LineType = DLT::"WHILE ..." THEN BEGIN
        IsBegin := IsBegin::"While";
        ExpectedIndent := LengthFirstStatement + 1;
        LineBreakStartAt := StartAt + LengthFirstStatement + 1;
      END;

      IF (LineType = DLT::"...") AND (LineBreakStartAt = 0) THEN
        LineBreakStartAt := StartAt;
    END;

    LOCAL PROCEDURE LineCanBeGlued@22(VAR CodeLine@1000 : Text;VAR CALLineNo@1001 : Integer;VAR LineStartedAt@1002 : Integer;VAR TotalLineLength@1003 : Integer;VAR StartIndent@1004 : Integer;VAR CanBeGlued@1005 : Boolean;VAR StartedWithIf@1006 : Boolean) : Boolean;
    BEGIN
      IF ClosingLine(CodeLine) THEN BEGIN

        IF LineStartedAt = 0 THEN
          EXIT;

        IF IsOpeningLine(CodeLine) AND (CALLineNo - LineStartedAt > 1) THEN
          IF CanBeGlued AND (TotalLineLength < 130) THEN
            EXIT(TRUE);

        IF IsOpeningLine(CodeLine) THEN
          IF NOT StartedWithIf THEN
            CanBeGlued := FALSE;

        IF CodeLine <> '' THEN
          IF CodeLine[STRLEN(CodeLine)] = ':' THEN
            CanBeGlued := FALSE;

        TotalLineLength += STRLEN(DELCHR(CodeLine, '<>')) + 1;
        IF (TotalLineLength < 130) AND CanBeGlued THEN
          EXIT(TRUE);

        LineStartedAt := 0;

      END ELSE BEGIN

        IF LineStartedAt = 0 THEN BEGIN
          LineStartedAt := CALLineNo;
          TotalLineLength := STRLEN(CodeLine) - StartIndent;
          CanBeGlued := TRUE;
          StartedWithIf := DELSTR(DELCHR(CodeLine, '<>'), 3) = 'IF';
        END ELSE
          TotalLineLength += STRLEN(DELCHR(CodeLine, '<>')) + 1;

        IF CanBeClosingLine(CodeLine) THEN
          CanBeGlued := FALSE;

      END;
    END;

    LOCAL PROCEDURE ClosingLine@23(CodeLine@1000 : Text) : Boolean;
    VAR
      Length@1001 : Integer;
    BEGIN
      CodeLine := DELCHR(CodeLine, '<>');
      IF CodeLine = '' THEN
        EXIT(TRUE);

      IF STRPOS(CodeLine, '//') > 0 THEN
        EXIT(TRUE);

      Length := STRLEN(CodeLine);

      IF CodeLine[Length] IN [';', ':', '{'] THEN
        EXIT(TRUE);

      IF Length > 1 THEN
        IF COPYSTR(CodeLine, Length - 1) IN ['DO', 'OF'] THEN
          EXIT(TRUE);

      IF Length > 2 THEN
        IF COPYSTR(CodeLine, Length - 2) IN ['END'] THEN
          EXIT(TRUE);

      IF Length > 3 THEN
        IF COPYSTR(CodeLine, Length - 3) IN ['THEN', 'ELSE'] THEN
          EXIT(TRUE);

      IF Length > 4 THEN
        IF COPYSTR(CodeLine, Length - 4) IN ['BEGIN'] THEN
          EXIT(TRUE);

      IF Length > 5 THEN
        IF COPYSTR(CodeLine, Length - 5) IN ['REPEAT'] THEN
          EXIT(TRUE);
    END;

    LOCAL PROCEDURE CanBeClosingLine@24(CodeLine@1000 : Text) : Boolean;
    VAR
      Length@1001 : Integer;
    BEGIN
      Length := STRLEN(CodeLine);

      IF Length > 1 THEN
        IF COPYSTR(CodeLine, Length - 1) IN ['OR'] THEN
          EXIT(TRUE);

      IF Length > 2 THEN
        IF COPYSTR(CodeLine, Length - 2) IN ['AND'] THEN
          EXIT(TRUE);
    END;

    LOCAL PROCEDURE IsOpeningLine@25(CodeLine@1000 : Text) : Boolean;
    BEGIN
      CodeLine := DELCHR(CodeLine, '<>');
      IF CodeLine = '' THEN
        EXIT(TRUE);

      IF STRPOS(CodeLine, '//') > 0 THEN
        EXIT(TRUE);

      IF COPYSTR(CodeLine, 1, 2) IN ['DO', 'OF'] THEN
        EXIT(TRUE);

      IF COPYSTR(CodeLine, 1, 3) IN ['END'] THEN
        EXIT(TRUE);

      IF COPYSTR(CodeLine, 1, 4) IN ['THEN', 'ELSE'] THEN
        EXIT(TRUE);

      IF COPYSTR(CodeLine, 1, 5) IN ['BEGIN', 'UNTIL'] THEN
        EXIT(TRUE);

      IF COPYSTR(CodeLine, 1, 6) IN ['REPEAT'] THEN
        EXIT(TRUE);
    END;

    LOCAL PROCEDURE AddBreakPos@26(VAR NoOfBreakPos@1000 : Integer;VAR NoOfOpenPos@1001 : Integer;VAR BreakPos@1002 : ARRAY [100] OF Integer;CurrentBreakPos@1003 : Integer);
    BEGIN
      NoOfOpenPos += 1;

      CASE TRUE OF
        NoOfBreakPos < 0 :
          NoOfBreakPos += 1;

        NoOfBreakPos = 0 :
          BEGIN
            NoOfBreakPos := 1;
            BreakPos[1] := CurrentBreakPos;
          END;

        ELSE
          IF CurrentBreakPos > BreakPos[NoOfBreakPos] + 1 THEN BEGIN
            NoOfBreakPos += 1;
            BreakPos[NoOfBreakPos] := CurrentBreakPos;
          END;

      END;
    END;

    PROCEDURE GoToStartOfBlock@27(VAR IndentCauseCounter@1000 : Integer;VAR IndentOpenEnd@1001 : ARRAY [500] OF Boolean;VAR IndentIsBegin@1002 : ARRAY [500] OF ' ,Begin,If,If begin,While') WendBack : Boolean;
    VAR
      StopLoop@1003 : Boolean;
    BEGIN
      IF IndentCauseCounter = 1 THEN BEGIN
        IndentCauseCounter := 0;
        EXIT;
      END;

      WHILE (IndentCauseCounter > 1) AND NOT StopLoop DO
        IF IndentOpenEnd[IndentCauseCounter - 1] AND
           NOT (IndentIsBegin[IndentCauseCounter - 1] IN
             [IndentIsBegin[IndentCauseCounter]::"Begin", IndentIsBegin[IndentCauseCounter]::"If begin"])
        THEN BEGIN
          IndentCauseCounter -= 1;
          WendBack := TRUE;
        END ELSE
          StopLoop := TRUE;

      IF WendBack THEN
        IndentCauseCounter -= 1;
    END;

    PROCEDURE GoToPreviousBegin@28(VAR IndentCauseCounter@1000 : Integer;VAR IndentIsBegin@1001 : ARRAY [500] OF ' ,Begin,If,If begin,While');
    VAR
      StopLoop@1002 : Boolean;
    BEGIN
      WHILE (IndentCauseCounter > 1) AND NOT StopLoop DO BEGIN
        IndentCauseCounter -= 1;
        IF IndentIsBegin[IndentCauseCounter] IN
             [IndentIsBegin[IndentCauseCounter]::"Begin", IndentIsBegin[IndentCauseCounter]::"If begin"]
        THEN
          StopLoop := TRUE;
      END;
    END;

    PROCEDURE GoToPreviousIf@29(VAR IndentCauseCounter@1000 : Integer;VAR IndentIsBegin@1001 : ARRAY [500] OF ' ,Begin,If,If begin,While');
    VAR
      StopLoop@1002 : Boolean;
    BEGIN
      WHILE (IndentCauseCounter > 1) AND NOT StopLoop DO BEGIN
        IndentCauseCounter -= 1;
        IF IndentIsBegin[IndentCauseCounter] IN
             [IndentIsBegin[IndentCauseCounter]::"Begin",
              IndentIsBegin[IndentCauseCounter]::"If",
              IndentIsBegin[IndentCauseCounter]::"If begin"]
        THEN
          StopLoop := TRUE;
      END;
    END;

    PROCEDURE GoToPreviousWhile@30(VAR IndentCauseCounter@1000 : Integer;VAR IndentIsBegin@1001 : ARRAY [500] OF ' ,Begin,If,If begin,While');
    VAR
      StopLoop@1002 : Boolean;
    BEGIN
      WHILE (IndentCauseCounter > 1) AND NOT StopLoop DO BEGIN
        IndentCauseCounter -= 1;
        IF IndentIsBegin[IndentCauseCounter] <> IndentIsBegin[IndentCauseCounter]::" " THEN
          StopLoop := TRUE;
      END;
    END;

    PROCEDURE GetIndentPreviousBegin@31(VAR IndentCauseCounter@1000 : Integer;VAR IndentIsBegin@1001 : ARRAY [500] OF ' ,Begin,If,If begin,While';VAR Indent@1002 : ARRAY [500] OF Integer) : Integer;
    VAR
      i@1003 : Integer;
    BEGIN
      i := IndentCauseCounter;
      WHILE i > 1 DO BEGIN
        i -= 1;
        IF IndentIsBegin[i] IN [IndentIsBegin[i]::"Begin", IndentIsBegin[i]::"If begin"] THEN
          EXIT(Indent[i]);
      END;
    END;

    LOCAL PROCEDURE CheckTableOptions@32(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR Comment@1002 : Record 11102081;VAR VariableBuffer@1003 : Record 11102062);
    VAR
      FieldBuffer@1004 : TEMPORARY Record 11102082;
      Mgt@1005 : Codeunit 11102035;
      KeyField@1006 : ARRAY [50] OF Text[250];
      TestKeyFieldName@1007 : Text;
      i@1008 : Integer;
      NoOfKeyFields@1009 : Integer;
      ctAddCaption@1010 : TextConst 'DEU=Add caption;ENU=Add caption;ESP=Add caption;FRA=Add caption;NLD=Voeg caption toe;DEA=Add caption';
      ctAddNotBlank@1011 : TextConst 'DEU=Add NotBlank property;ENU=Add NotBlank property;ESP=Add NotBlank property;FRA=Add NotBlank property;NLD=Voeg NotBlank eigenschap toe;DEA=Add NotBlank property';
      ctAddOptionCaption@1012 : TextConst 'DEU=Add option caption;ENU=Add option caption;ESP=Add option caption;FRA=Add option caption;NLD=Voeg optie caption toe;DEA=Add option caption';
      ctFieldNoName@1013 : TextConst 'DEU=Field has no name;ENU=Field has no name;ESP=Field has no name;FRA=Field has no name;NLD=Veld heeft geen naam;DEA=Field has no name';
      ctMakeNotEditable@1014 : TextConst 'DEU=Make not editable;ENU=Make not editable;ESP=Make not editable;FRA=Make not editable;NLD=Maak niet wijzigbaar;DEA=Make not editable';
      ctNameIsReserved@1015 : TextConst 'DEU=''%1'' is a reserved command;ENU=''%1'' is a reserved command;ESP=''%1'' is a reserved command;FRA=''%1'' is a reserved command;NLD=''%1'' is een gereserveerd commando;DEA=''%1'' is a reserved command';
      ctPrimaryKey@1016 : TextConst 'DEU=Try to avoid ''%1'' in primary key;ENU=Try to avoid ''%1'' in primary key;ESP=Try to avoid ''%1'' in primary key;FRA=Try to avoid ''%1'' in primary key;NLD=Probeer ''%1'' te vermijden in primaire sleutel;DEA=Try to avoid ''%1'' in primary key';
      ctRemoveFirstSpace@1017 : TextConst 'DEU=Remove first space from field name;ENU=Remove first space from field name;ESP=Remove first space from field name;FRA=Remove first space from field name;NLD=Verwijder eerste spatie van veldnaam;DEA=Remove first space from field name';
      ctRemoveSpace@1018 : TextConst 'DEU=Remove space from name at position %1;ENU=Remove space from name at position %1;ESP=Remove space from name at position %1;FRA=Remove space from name at position %1;NLD=Verwijder spatie uit naam op positie %1;DEA=Remove space from name at position %1';
      ctRemoveTrailingSpace@1019 : TextConst 'DEU=Remove trailing space from field name;ENU=Remove trailing space from field name;ESP=Remove trailing space from field name;FRA=Remove trailing space from field name;NLD=Verwijder laatste spatie van veldnaam;DEA=Remove trailing space from field name';
      ctStartWithCapital@1020 : TextConst 'DEU=Start field with a capital;ENU=Start field with a capital;ESP=Start field with a capital;FRA=Start field with a capital;NLD=Begin veld met hoofdletter;DEA=Start field with a capital';
    BEGIN
      ReadPrimaryKey(CALHistoryLine, NoOfKeyFields, KeyField);
      ReadFields(CALHistoryLine, Comment, FieldBuffer);

      IF FieldBuffer.FINDSET THEN
        REPEAT

          IF FieldBuffer.Name = '' THEN
            AddNamingComment(
              Comment, NamingCheck::Field, ctFieldNoName,
              FieldBuffer."C/AL Line No.", FieldBuffer.Identifier + '-EMPTY')
          ELSE BEGIN

            IF FieldBuffer.Name[1] = ' ' THEN
              AddNamingComment(Comment, NamingCheck::Field, ctRemoveFirstSpace, FieldBuffer."C/AL Line No.", 'SPACE');

            IF FieldBuffer.Name[STRLEN(FieldBuffer.Name)] = ' ' THEN
              AddNamingComment(Comment, NamingCheck::Field, ctRemoveTrailingSpace, FieldBuffer."C/AL Line No.", 'LASTSPACE');

            IF FORMAT(FieldBuffer.Name[1]) <> UPPERCASE(FORMAT(FieldBuffer.Name[1])) THEN
              AddNamingComment(
                Comment, NamingCheck::Field, ctStartWithCapital,
                FieldBuffer."C/AL Line No.", FieldBuffer.Identifier + '-CAPITAL');

            IF STRPOS(FieldBuffer.Name, '  ') > 0 THEN
              AddNamingComment(
                Comment, NamingCheck::Field, STRSUBSTNO(ctRemoveSpace, STRPOS(FieldBuffer.Name, '  ')),
                FieldBuffer."C/AL Line No.", FieldBuffer.Identifier + '-DOUBLESPACE');

            IF Mgt.IsReservedKeyword(FieldBuffer.Name) THEN
              AddNamingComment(
                Comment, NamingCheck::Reserved, STRSUBSTNO(ctNameIsReserved, FieldBuffer.Name),
                FieldBuffer."C/AL Line No.", '');

          END;
          IF NOT FieldBuffer."Has Caption" THEN
            AddCaptionComment(
              Comment, CaptionCheck::"Missing Captions", ctAddCaption,
              FieldBuffer."C/AL Line No.", FieldBuffer.Identifier + '-CAPTION');

          IF (FieldBuffer."Field Class" = FieldBuffer."Field Class"::FlowField) AND
             (FieldBuffer.Editable <> FieldBuffer.Editable::No)
          THEN
            AddDataComment(Comment, DataCheck::Flowfield, ctMakeNotEditable, FieldBuffer."C/AL Line No.", FieldBuffer.Identifier);

          IF (NoOfKeyFields = 1) AND
             (DELSTR(FieldBuffer."Field Type", 5) = 'Code') AND
             (FieldBuffer.Name = 'Code') AND
             (FieldBuffer.Name = KeyField[1])
          THEN BEGIN
            IF NOT FieldBuffer."Not Blank" THEN
              AddDataComment(Comment, DataCheck::NotBlank, ctAddNotBlank, FieldBuffer."C/AL Line No.", FieldBuffer.Identifier);
            TestKeyFieldName := FieldBuffer.Name;
          END;

          IF FieldBuffer."Field Type" = 'Option' THEN BEGIN
            IF NOT FieldBuffer."Has Option Caption" THEN
              AddCaptionComment(
                Comment, CaptionCheck::"Missing Captions", ctAddOptionCaption,
                FieldBuffer."Option String Line No.", FieldBuffer.Identifier + '-OPTION');
            IF (FieldBuffer."No. of Options" <> 0) AND (FieldBuffer."Option Caption Line No." <> 0) THEN BEGIN
              CALHistoryLine."Line No." := FieldBuffer."Option Caption Line No.";
              CALHistoryLine."Sub Line No." := 1;
              CALHistoryLine.FIND('=');
              IF CheckDataOption[DataCheck::"Options Strings"] THEN
                CompareNoOfOptions(
                  CALHistoryLine, Comment, FieldBuffer."No. of Options",
                  CheckType::Data, DataCheck::"Options Strings");
            END;
          END;

        UNTIL FieldBuffer.NEXT = 0;

      IF CheckDataOption[DataCheck::Testfield] THEN
        CheckTestFields(Comment, CALHistoryLine, FieldBuffer, TestKeyFieldName);

      IF CheckDataOption[DataCheck::"Delete Relating Table"] THEN
        CheckDeleteRelatingTables(Object, Comment, CALHistoryLine, VariableBuffer);

      FOR i := 1 TO NoOfKeyFields DO BEGIN
        FieldBuffer.SETCURRENTKEY(Name);
        FieldBuffer.SETRANGE(Name, KeyField[i]);
        IF FieldBuffer.FINDFIRST THEN
          IF (FieldBuffer."Field Type" <> 'Integer') AND
             (FieldBuffer."Field Type" <> 'Option') AND
             (DELSTR(FieldBuffer."Field Type", 5) <> 'Code')
          THEN
            AddDataComment(
              Comment, DataCheck::"Key Field is Code", STRSUBSTNO(ctPrimaryKey, FieldBuffer."Field Type"),
              FieldBuffer."C/AL Line No.", FieldBuffer.Identifier);
      END;
    END;

    LOCAL PROCEDURE ReadPrimaryKey@33(VAR CALHistoryLine@1000 : Record 11102053;VAR NoOfKeyFields@1001 : Integer;VAR KeyField@1002 : ARRAY [50] OF Text[250]);
    VAR
      CodeLine@1003 : Text;
      FieldName2@1004 : Text;
      Key@1005 : Text;
      Position@1006 : Integer;
    BEGIN
      IF SetRangeOnSection(CALHistoryLine, 'KEYS') THEN BEGIN
        CALHistoryLine.SETRANGE("Sub Line No.", 1);
        CALHistoryLine.SETFILTER(Code, '%1', '    {*');
        IF CALHistoryLine.FINDSET THEN BEGIN
          CodeLine := CALHistoryLine.Code;
          IF CodeLine[STRLEN(CodeLine)] <> '}' THEN BEGIN
            CALHistoryLine.RESET;
            CALHistoryLine.SETRANGE("Entry No.", CALHistoryLine."Entry No.");
            CALHistoryLine.SETRANGE("Line No.", CALHistoryLine."Line No.");
            CALHistoryLine.SETFILTER("Sub Line No.", '>%1', CALHistoryLine."Sub Line No.");
            IF CALHistoryLine.FINDSET THEN
              REPEAT
                CodeLine += CALHistoryLine.Code;
              UNTIL CALHistoryLine.NEXT = 0;
          END;

          Position := 7;
          NextValue(CodeLine, Position, ';', '[', ']', Key);
          NextValue(CodeLine, Position, ';', '[', ']', Key);
          IF Key[STRLEN(Key)] = '}' THEN BEGIN
            Key := DELSTR(Key, STRLEN(Key));
            Key := DELCHR(Key, '<>');
          END;

          Position := 1;
          NoOfKeyFields := 0;
          WHILE NextValue(Key, Position, ',', '"', '"', FieldName2) DO BEGIN
            NoOfKeyFields += 1;
            KeyField[NoOfKeyFields] := FieldName2;
          END;
        END;
      END;
    END;

    LOCAL PROCEDURE ReadFields@34(VAR CALHistoryLine@1000 : Record 11102053;VAR Comment@1001 : Record 11102081;VAR FieldBuffer@1002 : TEMPORARY Record 11102082);
    VAR
      TmpLanguage@1003 : TEMPORARY Record 11102056;
      TmpTranslationToolLine@1004 : TEMPORARY Record 11102068;
      Mgt@1005 : Codeunit 11102035;
      CalcFormula@1006 : Text;
      CodeLine@1007 : Text;
      FieldIdString@1008 : Text;
      FieldName2@1009 : Text;
      Options2@1010 : ARRAY [100] OF Text[120];
      PropertyName@1011 : Text;
      PropertyValue@1012 : Text;
      TableRelation@1013 : Text;
      Identifier@1014 : Code[100];
      FieldCounter@1015 : Integer;
      i@1016 : Integer;
      Position@1017 : Integer;
      TableRelationLineNo@1018 : Integer;
      AltSearchFieldPresent@1019 : Boolean;
      ctMoveCode@1020 : TextConst 'DEU=Move code from OnLookup trigger to page;ENU=Move code from OnLookup trigger to page;ESP=Move code from OnLookup trigger to page;FRA=Move code from OnLookup trigger to page;NLD=Verplaats de code van de OnLookup trigger naar page;DEA=Move code from OnLookup trigger to page';
      ctNameMustEndWithNos@1021 : TextConst 'DEU=Field name must end with ''Nos.'' or ''No. Series'';ENU=Field name must end with ''Nos.'' or ''No. Series'';ESP=Field name must end with ''Nos.'' or ''No. Series'';FRA=Field name must end with ''Nos.'' or ''No. Series'';NLD=Veldnaam moet op ''Nos.'' of ''No. Series'' eindigen;DEA=Field name must end with ''Nos.'' or ''No. Series''';
      ctRemoveProperty@1022 : TextConst 'DEU=Remove property: ''%1'' is default for ''%2'';ENU=Remove property: ''%1'' is default for ''%2'';ESP=Remove property: ''%1'' is default for ''%2'';FRA=Remove property: ''%1'' is default for ''%2'';NLD=Verwijder property: ''%1'' is de standaardwaarde voor ''%2'';DEA=Remove property: ''%1'' is default for ''%2''';
      ctRemoveSpace@1023 : TextConst 'DEU=Remove space from option string;ENU=Remove space from option string;ESP=Remove space from option string;FRA=Remove space from option string;NLD=Spatie verwijderen uit optiestring;DEA=Remove space from option string';
      ctSpecifyAnAltSearchField@1024 : TextConst 'DEU=Specify an AltSearchField;ENU=Specify an AltSearchField;ESP=Specify an AltSearchField;FRA=Specify an AltSearchField;NLD=AltSearchField opgeven;DEA=Specify an AltSearchField';
      ValidName@1025 : Boolean;
    BEGIN
      CALHistoryLine.RESET;

      IF SetRangeOnSection(CALHistoryLine, 'FIELDS') THEN BEGIN
        CALHistoryLine.SETRANGE("Sub Line No.");
        IF CALHistoryLine.FINDSET THEN
          REPEAT
            IF CALHistoryLine."Sub Line No." = 1 THEN BEGIN

              IF DELSTR(CALHistoryLine.Code, 6) = '    {' THEN BEGIN
                FieldCounter += 1;
                Position := 7;
                NextValue(CALHistoryLine.Code, Position, ';', '[', ']', FieldIdString);
                Identifier := 'FIELD' + FieldIdString;
                NextValue(CALHistoryLine.Code, Position, ';', '[', ']', FieldName2);
                NextValue(CALHistoryLine.Code, Position, ';', '[', ']', FieldName2);
                FieldBuffer.INIT;
                EVALUATE(FieldBuffer.Id, FieldIdString);
                FieldName2 := DELCHR(FieldName2, '<>', '[]');
                FieldBuffer.Name := FieldName2;

                NextValue(CALHistoryLine.Code, Position, ';', '[', ']', FieldName2);
                FieldBuffer."Field Type" := DELCHR(FieldName2, '>', ' }');

                FieldBuffer."C/AL Line No." := CALHistoryLine."Line No.";
                AltSearchFieldPresent := FALSE;

              END;

              IF CALHistoryLine.Code[52] <> ' ' THEN BEGIN
                CodeLine := COPYSTR(CALHistoryLine.Code, 52);

                GetPropertyName(CodeLine, PropertyName);
                GetPropertyValue(CALHistoryLine, PropertyValue);

                IF PropertyName <> '' THEN
                  IF DefaultProperty('Table', 'Field', PropertyName) = PropertyValue THEN
                    AddCodingComment(Comment, CodingCheck::Properties,
                      STRSUBSTNO(
                        ctRemoveProperty, PropertyValue, PropertyName),CALHistoryLine."Line No.", 0, 0, '');

                CASE PropertyName OF

                  'NotBlank' :
                    FieldBuffer."Not Blank" := TRUE;

                  'AutoIncrement' :
                    FieldBuffer."Auto Increment" := TRUE;

                  'CaptionML' :
                    BEGIN
                      ParseCaption(CALHistoryLine, 'CaptionML', Comment, FieldBuffer.Caption, Identifier + '-CAPTION', TmpLanguage);
                      CheckUniqueCaptions(CALHistoryLine, Comment, TmpLanguage, TmpTranslationToolLine);
                      FieldBuffer."Has Caption" := TRUE;
                    END;

                  'OptionString' :
                    BEGIN
                      FieldBuffer."No. of Options" := Mgt.Split(GetCompletePropertyValue(CALHistoryLine, PropertyValue), ',', Options2);
                      FieldBuffer."Option String Line No." := CALHistoryLine."Line No.";

                      FOR i := 1 TO FieldBuffer."No. of Options" DO
                        IF (Options2[i] <> '') AND (Options2[i] <> ' ') THEN
                          IF FORMAT(Options2[i])[1] = ' ' THEN BEGIN
                            AddDataComment(Comment, DataCheck::"Options Strings", ctRemoveSpace, CALHistoryLine."Line No.", Identifier + '-SPACE');
                            i := FieldBuffer."No. of Options" + 1;
                          END;

                    END;

                  'OptionCaptionML' :
                    BEGIN
                      FieldBuffer."Option Caption Line No." := CALHistoryLine."Line No.";
                      ParseCaption(
                        CALHistoryLine, 'OptionCaptionML', Comment, PropertyValue, Identifier + '-OPTIONCAPTION', TmpLanguage);
                      FieldBuffer."Has Option Caption" := TRUE;
                    END;

                  'FieldClass' :
                    IF EVALUATE(FieldBuffer."Field Class", PropertyValue) THEN
                      ;

                  'Editable' :
                    IF EVALUATE(FieldBuffer.Editable, PropertyValue) THEN
                      ;

                  'TableRelation' :
                    BEGIN
                      TableRelation := GetCompletePropertyValue(CALHistoryLine, PropertyValue);
                      TableRelationLineNo := CALHistoryLine."Line No.";
                    END;

                  'ValidateTableRelation' :
                    IF EVALUATE(FieldBuffer."Validate Table Relation", PropertyValue) THEN
                      ;

                  'CalcFormula' :
                    BEGIN
                      CalcFormula := GetCompletePropertyValue(CALHistoryLine, PropertyValue);
                      AnalyseCalcFormula(
                        CalcFormula, CALHistoryLine."Line No.", Comment, FieldBuffer."Field Type", FORMAT(FieldBuffer.Id));
                      FieldBuffer."CalcFormula Present" := TRUE;
                    END;

                  'OnLookup' :
                    AddCodingComment(
                      Comment, CodingCheck::OnLookup, ctMoveCode, CALHistoryLine."Line No.", 0, 0, FORMAT(FieldBuffer.Id));

                  'AltSearchField' :
                    AltSearchFieldPresent := TRUE;

                END;
              END;
            END;

            IF STRLEN(CALHistoryLine.Code) > 5 THEN
              IF (COPYSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 3) = '=VAR') OR
                 (COPYSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 5) = '=BEGIN')
              THEN
                SkipCodeSection(CALHistoryLine);

            IF CALHistoryLine.Code <> '' THEN
              IF CALHistoryLine.Code[STRLEN(CALHistoryLine.Code)] = '}' THEN BEGIN
                FieldBuffer.INSERT;

                IF TableRelation <> '' THEN BEGIN

                  IF TableRelation = '"No. Series"' THEN BEGIN
                    ValidName := FALSE;
                    IF STRLEN(FieldBuffer.Name) > 4 THEN
                      IF COPYSTR(FieldBuffer.Name, STRLEN(FieldBuffer.Name) - 4) = ' Nos.' THEN
                        ValidName := TRUE;

                    IF STRLEN(FieldBuffer.Name) > 9 THEN
                      IF COPYSTR(FieldBuffer.Name, STRLEN(FieldBuffer.Name) - 9) = 'No. Series' THEN
                        ValidName := TRUE;

                    IF NOT ValidName THEN
                      AddNamingComment(Comment, NamingCheck::Field, ctNameMustEndWithNos, FieldBuffer."C/AL Line No.", Identifier);
                  END;

                  IF FieldBuffer."Validate Table Relation" THEN
                    AnalyseTableRelation(TableRelation, TableRelationLineNo, Comment, FieldBuffer.Name, FieldBuffer."Field Type", FORMAT(FieldBuffer.Id))
                  ELSE
                    AnalyseTableRelation(TableRelation, TableRelationLineNo, Comment, FieldBuffer.Name, '', FORMAT(FieldBuffer.Id));
                  TableRelation := '';
                END;

                IF (FieldBuffer.Name = 'No.') AND (FieldCounter = 1) AND
                   NOT AltSearchFieldPresent AND (DELSTR(FieldBuffer."Field Type", 5) = 'Code')
                THEN
                  AddDataComment(Comment, DataCheck::Flowfield, ctSpecifyAnAltSearchField, FieldBuffer."C/AL Line No.", FieldBuffer.Identifier);;

              END;

          UNTIL CALHistoryLine.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE GetCompletePropertyValue@35(VAR CALHistoryLine@1000 : Record 11102053;Expression@1001 : Text) : Text;
    VAR
      OriginalCALHistoryLine@1002 : Record 11102053;
      AddString@1003 : Text;
      StopLoop@1004 : Boolean;
    BEGIN
      IF NOT (CALHistoryLine.Code[STRLEN(CALHistoryLine.Code)] IN ['}', ';']) THEN BEGIN
        OriginalCALHistoryLine := CALHistoryLine;
        WHILE NOT StopLoop DO BEGIN
          StopLoop := CALHistoryLine.NEXT = 0;
          IF NOT StopLoop THEN BEGIN
            IF CALHistoryLine."Sub Line No." = 1 THEN
              AddString := ' ' + DELCHR(CALHistoryLine.Code, '<')
            ELSE
              AddString := CALHistoryLine.Code;
            Expression += AddString;
            StopLoop := AddString[STRLEN(AddString)] IN ['}', ';'];
          END;
        END;
        CALHistoryLine := OriginalCALHistoryLine;
      END;

      EXIT(Expression);
    END;

    LOCAL PROCEDURE AnalyseTableRelation@36(Expression@1000 : Text;LineNo@1001 : Integer;VAR Comment@1002 : Record 11102081;FieldName2@1003 : Text;FieldType@1004 : Text;Identifier@1005 : Code[100]);
    VAR
      AllObj@1006 : Record 2000000038;
      Fld2@1007 : Record 2000000041;
      TmpCheckField@1008 : TEMPORARY Record 2000000041;
      Mgt@1009 : Codeunit 11102035;
      RecRef@1010 : RecordRef;
      FldRef@1011 : FieldRef;
      KeyRef@1012 : KeyRef;
      FieldString@1013 : Text;
      FieldTypeName@1014 : Text;
      Filter1@1015 : Text;
      Filter2@1016 : Text;
      Filter3@1017 : Text;
      NextString@1018 : Text;
      TableString@1019 : Text;
      CheckFieldLength@1020 : Integer;
      FieldLength@1021 : Integer;
      LongestField@1022 : Integer;
      NoOfFields@1023 : Integer;
      Position@1024 : Integer;
      RelatedFieldNo@1025 : Integer;
      GetNext@1026 : Boolean;
      GetNext2@1027 : Boolean;
      GetNextFilter2@1028 : Boolean;
      WarningAdded@1029 : Boolean;
      ctFieldNameNotTable@1030 : TextConst 'DEU=Add %1 to the field name;ENU=Add %1 to the field name;ESP=Add %1 to the field name;FRA=Add %1 to the field name;NLD=Voeg %1 toe aan de veldnaam;DEA=Add %1 to the field name';
      ctRelatedFieldOtherType@1031 : TextConst 'DEU=The related field in table ''%1'' is ''%2'';ENU=The related field in table ''%1'' is ''%2'';ESP=The related field in table ''%1'' is ''%2'';FRA=The related field in table ''%1'' is ''%2'';NLD=Het gererateerde veld in ''%1'' is ''%2'';DEA=The related field in table ''%1'' is ''%2''';
      ctRelatedFieldSmaller@1032 : TextConst 'DEU=The longest related field has a length of ''%1'';ENU=The longest related field has a length of ''%1'';ESP=The longest related field has a length of ''%1'';FRA=The longest related field has a length of ''%1'';NLD=Het grootste gerelateerde veld heeft een lengte van ''%1'';DEA=The longest related field has a length of ''%1''';
      ctRemovePrimaryKey@1033 : TextConst 'DEU=Remove Primary Key Field ''%1'' from TableRelation;ENU=Remove Primary Key Field ''%1'' from TableRelation;ESP=Remove Primary Key Field ''%1'' from TableRelation;FRA=Remove Primary Key Field ''%1'' from TableRelation;NLD=Verwijder sleutelveld ''%1'' uit tabelrelatie;DEA=Remove Primary Key Field ''%1'' from TableRelation';
      ctTableNotFound@1034 : TextConst 'DEU=Table ''%1'' not found;ENU=Table ''%1'' not found;ESP=Table ''%1'' not found;FRA=Table ''%1'' not found;NLD=Tabel ''%1'' niet gevonden;DEA=Table ''%1'' not found';
    BEGIN
      Expression := LOWERCASE(Expression);
      Position := 1;

      GetNext := Expression <> '';
      WHILE GetNext DO BEGIN

        NextString := '';

        IF Expression[Position] = ' ' THEN
          Position += 1;

        NextValueTill(Expression, Position, '"', ' .;}', TableString);

        IF TableString = 'else' THEN
          NextValueTill(Expression, Position, '"', ' .;}', TableString);

        IF TableString = 'if' THEN BEGIN

          GetNextFilter2 := TRUE;
          WHILE GetNextFilter2 DO BEGIN

            Position += 1;
            GetNextFilter(Expression, Position, Filter1, Filter2, Filter3);

            NextString := '';
            GetNextFilter2 := Expression[Position] = ',';
            Position += 1;
          END;
          Position += 1;
          NextValueTill(Expression, Position, '"', ' .;}', TableString);
        END;

        FieldString := '';
        IF Expression[Position - 1] = '.' THEN
          NextValueTill(Expression, Position, '"', ' ;}', FieldString);

        IF GetTableByName(AllObj, TableString, TRUE) THEN BEGIN

          RecRef.OPEN(AllObj."Object ID");
          KeyRef := RecRef.KEYINDEX(1);
          FldRef := KeyRef.FIELDINDEX(1);
          RelatedFieldNo := FldRef.NUMBER;
          RecRef.CLOSE;

          IF FieldString <> '' THEN BEGIN
            Fld2.SETRANGE(TableNo, AllObj."Object ID");
            Fld2.SETFILTER(FieldName, Mgt.CreateFieldFilter(FieldString, TRUE));
            IF Fld2.FINDFIRST THEN BEGIN
              IF RelatedFieldNo = Fld2."No." THEN
                AddDataComment(
                  Comment, DataCheck::"Key in Relation", STRSUBSTNO(ctRemovePrimaryKey, Fld2.FieldName), LineNo, Identifier);
              RelatedFieldNo := Fld2."No.";
            END;
          END;

          IF Fld2.GET(AllObj."Object ID", RelatedFieldNo) THEN
            IF NOT TmpCheckField.GET(AllObj."Object ID", RelatedFieldNo) THEN BEGIN
              TmpCheckField := Fld2;
              TmpCheckField.INSERT;
              IF LongestField < Fld2.Len THEN
                LongestField := Fld2.Len;
              NoOfFields += 1;
            END;

        END ELSE
          AddDataComment(Comment, DataCheck::"Key in Relation", STRSUBSTNO(ctTableNotFound, TableString), LineNo, Identifier);

        GetNext2 := COPYSTR(Expression, Position, 5) = 'where';
        IF GetNext2 THEN BEGIN
          Position += 1;
          NextValueTill(Expression, Position, '"', ' ', FieldString);

          WHILE GetNext2 DO BEGIN

            Position += 1;
            GetNextFilter(Expression, Position, Filter1, Filter2, Filter3);
            IF Filter2 IN ['const', 'filter'] THEN
              CheckFilterOnField(LineNo, Comment, AllObj."Object ID", Filter1, Filter3);

            GetNext2 := Expression[Position] = ',';
            Position += 1;
          END;
        END;

        GetNext := Position < STRLEN(Expression);

      END;

      IF (FieldName2 <> '') AND (TmpCheckField.COUNT = 1) THEN
        IF FieldName2 = TmpCheckField.TableName THEN
          IF TmpCheckField.FieldName IN ['Code', 'No.', 'Entry No.'] THEN
            AddNamingComment(
              Comment, NamingCheck::Field,
              STRSUBSTNO(ctFieldNameNotTable, TmpCheckField.FieldName), LineNo, Identifier);

      IF FieldType <> '' THEN BEGIN
        SplitFieldType(FieldType, FieldTypeName, FieldLength);
        IF TmpCheckField.FINDSET THEN
          REPEAT
            CheckFieldLength := FieldLength;
            IF TmpCheckField.Type IN [TmpCheckField.Type::Code, TmpCheckField.Type::Text] THEN
              CheckFieldLength := TmpCheckField.Len;

            IF (FORMAT(TmpCheckField.Type) <> FieldTypeName) OR
               (CheckFieldLength > FieldLength) OR
               ((CheckFieldLength <> FieldLength) AND (NoOfFields = 1))
            THEN BEGIN
              IF AllObj.GET(AllObj."Object Type"::Table, TmpCheckField.TableNo) THEN
                ;
              AddDataComment(
                Comment, DataCheck::"Type in Relation",
                STRSUBSTNO(ctRelatedFieldOtherType, AllObj."Object Name", TmpCheckField."Type Name"), LineNo, Identifier);
              WarningAdded := TRUE;
            END;
          UNTIL TmpCheckField.NEXT = 0;

        IF NOT WarningAdded AND NOT (FieldLength IN [0, LongestField]) THEN
          IF LongestField <> 0 THEN
            AddDataComment(
              Comment, DataCheck::"Type in Relation",
              STRSUBSTNO(ctRelatedFieldSmaller, LongestField), LineNo, Identifier);

      END;
    END;

    LOCAL PROCEDURE CheckFilterOnField@123(LineNo@1000 : Integer;VAR Comment@1001 : Record 11102081;VAR TableNo@1002 : Integer;VAR FieldName2@1003 : Text;VAR Filter@1004 : Text);
    VAR
      Fld@1005 : Record 2000000041;
      Mgt@1006 : Codeunit 11102035;
      ctConstantInRelation@1007 : TextConst 'DEU=Do not use a string in a table relation;ENU=Do not use a string in a table relation;ESP=Do not use a string in a table relation;FRA=Do not use a string in a table relation;NLD=Er zit een string in de relatie;DEA=Do not use a string in a table relation';
    BEGIN
      IF Filter IN ['', '''''', '<>'''''] THEN
        EXIT;

      Fld.SETRANGE(TableNo, TableNo);
      Fld.SETFILTER(FieldName, Mgt.CreateFieldFilter(FieldName2, TRUE));
      IF Fld.FINDFIRST THEN
        IF Fld.Type IN [Fld.Type::Text, Fld.Type::Code] THEN
          AddDataComment(Comment, DataCheck::"Const in Relation", ctConstantInRelation, LineNo, '');
    END;

    LOCAL PROCEDURE AnalyseCalcFormula@37(VAR Expression@1000 : Text;LineNo@1001 : Integer;VAR Comment@1002 : Record 11102081;FieldType@1003 : Text;Identifier@1004 : Code[100]);
    VAR
      AllObj@1005 : Record 2000000038;
      Field@1006 : Record 2000000041;
      Mgt@1007 : Codeunit 11102035;
      ExectedFieldType@1008 : Text;
      FieldName2@1009 : Text;
      FieldString@1010 : Text;
      Filter1@1011 : Text;
      Filter2@1012 : Text;
      Filter3@1013 : Text;
      String@1014 : Text;
      TableName2@1015 : Text;
      Position@1016 : Integer;
      FieldPresent@1017 : Boolean;
      GetNext2@1018 : Boolean;
      ctOtherFieldType@1019 : TextConst 'DEU=Field type should be ''%1'';ENU=Field type should be ''%1'';ESP=Field type should be ''%1'';FRA=Field type should be ''%1'';NLD=Veld moet van het type ''%1'' zijn;DEA=Field type should be ''%1''';
      ctRelatedFieldOtherType@1020 : TextConst 'DEU=The related field in table ''%1'' is ''%2'';ENU=The related field in table ''%1'' is ''%2'';ESP=The related field in table ''%1'' is ''%2'';FRA=The related field in table ''%1'' is ''%2'';NLD=Het gererateerde veld in ''%1'' is ''%2'';DEA=The related field in table ''%1'' is ''%2''';
    BEGIN
      Position := 1;
      IF Expression[1] = '-' THEN
        Position := 2;

      NextValueTill(Expression, Position, 0, '(', String);

      CASE String OF
        'Sum', 'Average' :
          BEGIN
            FieldPresent := TRUE;
            ExectedFieldType := 'Decimal';
          END;

        'Exist' :
          ExectedFieldType := 'Boolean';

        'Count' :
          ExectedFieldType := 'Integer';

        'Min', 'Max', 'Lookup' :
          FieldPresent := TRUE;

      END;

      IF FieldPresent THEN BEGIN
        NextValueTill(Expression, Position, '"', '.', TableName2);
        NextValueTill(Expression, Position, '"', ' )', FieldName2);
      END ELSE
        NextValueTill(Expression, Position, '"', ' )', TableName2);

      IF GetTableByName(AllObj, TableName2, TRUE) THEN
        IF ExectedFieldType = '' THEN BEGIN
          Field.SETRANGE(TableNo, AllObj."Object ID");
          Field.SETFILTER(FieldName, Mgt.CreateFieldFilter(FieldName2, FALSE));
          IF Field.FINDFIRST THEN
            ExectedFieldType := Field."Type Name";
        END;

      GetNext2 := COPYSTR(Expression, Position, 5) = 'WHERE';
      IF GetNext2 THEN BEGIN
        Position += 1;
        NextValueTill(Expression, Position, '"', ' ', FieldString);

        WHILE GetNext2 DO BEGIN

          Position += 1;
          GetNextFilter(Expression, Position, Filter1, Filter2, Filter3);
          IF Filter2 IN ['CONST', 'FILTER'] THEN
            CheckFilterOnField(LineNo, Comment, AllObj."Object ID", Filter1, Filter3);
          GetNext2 := Expression[Position] = ',';
          Position += 1;
        END;
      END;

      IF ExectedFieldType <> '' THEN BEGIN
        ExectedFieldType := Mgt.Replace(ExectedFieldType, 'Oem', '');
        IF ExectedFieldType <> FieldType THEN
          IF AllObj."Object Name" = '' THEN
            AddDataComment(Comment, DataCheck::"Type in Relation", STRSUBSTNO(ctOtherFieldType, ExectedFieldType), LineNo, Identifier)
          ELSE
            AddDataComment(
              Comment, DataCheck::"Type in Relation",
              STRSUBSTNO(ctRelatedFieldOtherType, AllObj."Object Name", ExectedFieldType), LineNo, Identifier);
      END;
    END;

    LOCAL PROCEDURE NextValueTill@38(VAR TextLine@1000 : Text;VAR Position@1001 : Integer;OpenChar@1002 : Char;StopChars@1003 : Text;VAR ExitValue@1004 : Text) : Boolean;
    VAR
      Char@1005 : Char;
      Advanced@1006 : Boolean;
      FirstCharacter@1007 : Boolean;
      Stop@1008 : Boolean;
    BEGIN
      ExitValue := '';
      FirstCharacter := TRUE;

      IF Position > STRLEN(TextLine) THEN
        EXIT(FALSE);

      WHILE NOT Stop DO

        IF NextChar(TextLine, Position, Char) THEN BEGIN

          CASE TRUE OF

            Char = OpenChar :
              IF FirstCharacter THEN
                Advanced := TRUE
              ELSE
                IF Advanced THEN BEGIN
                  IF NextChar(TextLine, Position, Char) THEN
                    IF Char = OpenChar THEN
                      ExitValue += FORMAT(Char)
                    ELSE BEGIN
                      Advanced := FALSE;
                      Position -= 1;
                    END;
                END ELSE
                  ExitValue += FORMAT(Char);

            STRPOS(StopChars, FORMAT(Char)) > 0 :

              IF Advanced THEN
                ExitValue += FORMAT(Char)
              ELSE
                Stop := TRUE;

            ELSE
              ExitValue += FORMAT(Char);

          END;

          FirstCharacter := FALSE;

        END ELSE
          Stop := TRUE;

      ExitValue := DELCHR(ExitValue, '<>');
      EXIT(TRUE);
    END;

    LOCAL PROCEDURE GetNextFilter@39(VAR Expression@1000 : Text;VAR Position@1001 : Integer;VAR First@1002 : Text;VAR Compare@1003 : Text;VAR NextString@1004 : Text);
    BEGIN
      NextValue(Expression, Position, '=', '"', '"', First);
      NextValue(Expression, Position, '(', ')', ')', Compare);
      NextFilter(Expression, Position, ')', NextString);

      IF DELSTR(NextString, 8) = 'filter(' THEN BEGIN
        NextString := COPYSTR(NextString, 8);
        Position += 1;
      END;

      IF DELSTR(NextString, 12) = 'upperlimit(' THEN BEGIN
        NextString := COPYSTR(NextString, 12);
        Position += 1;
      END;
    END;

    LOCAL PROCEDURE NextFilter@130(VAR TextLine@1000 : Text;VAR Position@1001 : Integer;CloseChar@1002 : Char;VAR ExitValue@1003 : Text) : Boolean;
    VAR
      SplitCharacters@1004 : Text;
      StartCharacters@1005 : Text;
      Char@1006 : Char;
      StartCharacter@1007 : Char;
      Advanced@1008 : Boolean;
      FirstCharacter@1009 : Boolean;
      SetFirstCharacter@1010 : Boolean;
      Stop@1011 : Boolean;
    BEGIN
      ExitValue := '';
      FirstCharacter := TRUE;

      IF Position > STRLEN(TextLine) THEN
        EXIT(FALSE);

      SplitCharacters := '|&';
      StartCharacters := '''"';

      WHILE NOT Stop DO

        IF NextChar(TextLine, Position, Char) THEN BEGIN

          CASE TRUE OF

            Advanced :
              IF Char = StartCharacter THEN BEGIN
                IF NextChar(TextLine, Position, Char) THEN
                  IF Char = StartCharacter THEN
                    ExitValue += FORMAT(Char)
                  ELSE BEGIN
                    Advanced := FALSE;
                    Position -= 1;
                  END;
              END ELSE
                ExitValue += FORMAT(Char);

            STRPOS(StartCharacters, FORMAT(Char)) > 0 :
              IF FirstCharacter THEN BEGIN
                StartCharacter := Char;
                Advanced := TRUE;
              END ELSE
                ExitValue += FORMAT(Char);

            STRPOS(SplitCharacters, FORMAT(Char)) > 0 :
              BEGIN
                ExitValue += FORMAT(Char);
                SetFirstCharacter := TRUE;
              END;

            Char = CloseChar :
              Stop := TRUE;

            ELSE
              ExitValue += FORMAT(Char);
          END;

          IF SetFirstCharacter THEN BEGIN
            FirstCharacter := TRUE;
            SetFirstCharacter := FALSE;
          END ELSE
            FirstCharacter := FALSE;

        END ELSE
          Stop := TRUE;

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE SkipCodeSection@41(VAR CALHistoryLine@1000 : Record 11102053);
    VAR
      EndCode@1001 : Text;
      StopLoop@1002 : Boolean;
    BEGIN
      CASE TRUE OF
        COPYSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 3) = '=VAR' :
          BEGIN
            EndCode := PADSTR('', STRPOS(CALHistoryLine.Code, '=VAR')) + 'END;';
            REPEAT
              StopLoop := CALHistoryLine.NEXT = 0;
            UNTIL (CALHistoryLine.Code = EndCode) OR StopLoop;
          END;

        COPYSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 5) = '=BEGIN' :
          BEGIN
            EndCode := PADSTR('', STRPOS(CALHistoryLine.Code, '=BEGIN')) + 'END;';
            REPEAT
              StopLoop := CALHistoryLine.NEXT = 0;
            UNTIL (CALHistoryLine.Code = EndCode) OR StopLoop;
          END;

      END;
    END;

    LOCAL PROCEDURE ParseCaption@42(VAR CALHistoryLine@1000 : Record 11102053;PropertyName@1001 : Text;VAR Comment@1002 : Record 11102081;VAR ReturnCaption@1003 : Text;Identifier@1004 : Code[100];VAR TmpLanguage@1005 : TEMPORARY Record 11102056);
    VAR
      Caption@1006 : ARRAY [100] OF Text[1024];
      CALLineNo@1007 : Integer;
      CaptionCALLineNo@1008 : ARRAY [100] OF Integer;
      CaptionPos@1009 : Integer;
      i@1010 : Integer;
      NoOfCaptions2@1011 : Integer;
      BracketOpen@1012 : Boolean;
      StopLoop@1013 : Boolean;
      ctAddCaption@1014 : TextConst 'DEU=Add %1 caption;ENU=Add %1 caption;ESP=Add %1 caption;FRA=Add %1 caption;NLD=Voeg %1 caption toe;DEA=Add %1 caption';
      ctRemoveSpace@1015 : TextConst 'DEU=Remove space from caption;ENU=Remove space from caption;ESP=Remove space from caption;FRA=Remove space from caption;NLD=Verwijder spatie uit caption;DEA=Remove space from caption';
    BEGIN
      TmpLanguage.RESET;
      TmpLanguage.DELETEALL;

      CALHistoryLine.FILTERGROUP(10);
      CALHistoryLine.SETRANGE("Sub Line No.", 1);
      CALHistoryLine.FILTERGROUP(0);

      CALLineNo := CALHistoryLine."Line No.";

      CaptionPos := STRPOS(CALHistoryLine.Code, PropertyName + '=') + STRLEN(PropertyName);

      BracketOpen := CALHistoryLine.Code[CaptionPos + 1] = '[';

      IF BracketOpen THEN BEGIN
        CaptionPos += 1;
        NoOfCaptions2 += 1;
        Caption[NoOfCaptions2] := CALHistoryLine.Code;
        CaptionCALLineNo[NoOfCaptions2] := CALHistoryLine."Line No.";

        StopLoop := CALHistoryLine.NEXT = 0;
        WHILE NOT StopLoop DO BEGIN

          StopLoop :=
            (CALHistoryLine.Code[CaptionPos + 4] <> '=') OR
            (CALHistoryLine.Code[CaptionPos] <> ' ');

          IF NOT StopLoop THEN BEGIN
            NoOfCaptions2 += 1;
            Caption[NoOfCaptions2] := CALHistoryLine.Code;
            CaptionCALLineNo[NoOfCaptions2] := CALHistoryLine."Line No.";
            StopLoop := CALHistoryLine.NEXT = 0;
          END;
        END;
        IF StopLoop THEN
          CALHistoryLine.NEXT(-1);
      END ELSE BEGIN
        NoOfCaptions2 += 1;
        Caption[NoOfCaptions2] := CALHistoryLine.Code;
        CaptionCALLineNo[NoOfCaptions2] := CALHistoryLine."Line No.";
      END;

      FOR i := 1 TO NoOfCaptions2 DO BEGIN

        IF (STRPOS(Caption[i], ' "]') > 0) OR (STRPOS(Caption[i], ' ";') > 0) THEN
          IF STRPOS(Caption[i], '" "') = 0 THEN
            AddCaptionComment(Comment, CaptionCheck::"Missing Captions", ctRemoveSpace, CALLineNo, Identifier + '-RS');

        TmpLanguage.Code := COPYSTR(Caption[i], CaptionPos + 1, 3);
        TmpLanguage.Name := COPYSTR(Caption[i], CaptionPos + 5, MAXSTRLEN(TmpLanguage.Name));
        TmpLanguage."Assign Mode" := CaptionCALLineNo[i];
        TmpLanguage.INSERT;

        IF (TmpLanguage.Code = 'ENU') OR (ReturnCaption = '') THEN
          ReturnCaption := TmpLanguage.Name;

      END;

      FOR i := 1 TO NoOfMandLanguages DO
        IF NOT TmpLanguage.GET(MandLanguage[i]) THEN
          AddCaptionComment(
            Comment, CaptionCheck::"Missing Captions",
            STRSUBSTNO(ctAddCaption, MandLanguage[i]), CALLineNo, Identifier + '-' + MandLanguage[i]);

      ReturnCaption := DELCHR(ReturnCaption, '>', ' ;}]');
      ReturnCaption := DELCHR(ReturnCaption, '=', '&''"');

      CALHistoryLine.FILTERGROUP(10);
      CALHistoryLine.SETRANGE("Sub Line No.");
      CALHistoryLine.FILTERGROUP(0);
    END;

    LOCAL PROCEDURE CheckUniqueCaptions@108(VAR CALHistoryLine@1000 : Record 11102053;VAR Comment2@1001 : Record 11102081;VAR TmpLanguage@1002 : TEMPORARY Record 11102056;VAR TmpTranslationToolLine@1003 : TEMPORARY Record 11102068);
    VAR
      LastEntryNo@1004 : Integer;
      ctCaptionNotUnique@1005 : TextConst 'DEU=Caption is not unique;ENU=Caption is not unique;ESP=Caption is not unique;FRA=Caption is not unique;NLD=Caption is niet uniek;DEA=Caption is not unique';
    BEGIN
      WITH TmpTranslationToolLine DO BEGIN
        RESET;
        IF FINDLAST THEN
          LastEntryNo := "Entry No.";

        IF TmpLanguage.FINDSET THEN
          REPEAT
            SETRANGE("Translate File Line", TmpLanguage.Code);
            SETRANGE("Caption 1", TmpLanguage.Name);
            IF ISEMPTY THEN BEGIN
              LastEntryNo += 1;
              "Entry No." := LastEntryNo;
              "Translate File Line" := FORMAT(TmpLanguage.Code);
              "Caption 1" := TmpLanguage.Name;
              INSERT;
            END ELSE
              AddComment(
                Comment2, CheckType::Naming, NamingCheck::"Double Captions",
                ctCaptionNotUnique, CALHistoryLine."Line No.", 0, 0, '');

          UNTIL TmpLanguage.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE CompareNoOfOptions@48(VAR CALHistoryLine@1000 : Record 11102053;VAR Comment@1001 : Record 11102081;NoOfOptions@1002 : Integer;pCheckType@1003 : Integer;pCheckOption@1004 : Integer);
    VAR
      Buffer@1005 : TEMPORARY Record 11102068;
      Mgt@1006 : Codeunit 11102035;
      TranslationMgt@1007 : Codeunit 11102051;
      Code@1008 : Text;
      Options2@1009 : ARRAY [100] OF Text[120];
      i@1010 : Integer;
      NoOfOptions2@1011 : Integer;
      ctOptionsNotTheSame@1012 : TextConst 'DEU=No. of options not the same for ''%1'';ENU=No. of options not the same for ''%1'';ESP=No. of options not the same for ''%1'';FRA=No. of options not the same for ''%1'';NLD=Aantal opties zijn niet gelijk voor ''%1'';DEA=No. of options not the same for ''%1''';
      ctRemoveSpace@1013 : TextConst 'DEU=Remove space from option caption;ENU=Remove space from option caption;ESP=Remove space from option caption;FRA=Remove space from option caption;NLD=Spatie verwijderen uit optie-caption;DEA=Remove space from option caption';
    BEGIN
      Code := CALHistoryLine.Code;
      TranslationMgt.ParseCaption(Buffer, CALHistoryLine, Code, 'T1', '', 0);
      IF Buffer.FINDSET THEN
        REPEAT
          Buffer.VALIDATE("Translate File Line");
          IF Buffer."Language Id" > 1 THEN BEGIN
            NoOfOptions2 := Mgt.Split(Buffer.TotalCaption, ',', Options2);
            IF NoOfOptions <> NoOfOptions2 THEN
              AddComment(
                Comment, pCheckType, pCheckOption,
                STRSUBSTNO(ctOptionsNotTheSame, TranslationMgt.LanguageCodeOfId(Buffer."Language Id")),
                CALHistoryLine."Line No.", 0, 0, '');

            FOR i := 1 TO NoOfOptions DO
              IF (Options2[i] <> '') AND (Options2[i] <> ' ') THEN
                IF FORMAT(Options2[i])[1] = ' ' THEN BEGIN
                  AddDataComment(Comment, DataCheck::"Options Strings", ctRemoveSpace, CALHistoryLine."Line No.", '');
                  i := NoOfOptions + 1;
                END;
          END;

        UNTIL Buffer.NEXT = 0;
    END;

    LOCAL PROCEDURE AddVariablesFromParameters@49(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR VariableBuffer@1002 : TEMPORARY Record 11102062;VAR Comment@1003 : Record 11102081;Identifier@1004 : Code[100]);
    VAR
      CodeLine@1005 : Text;
      ParameterCode@1006 : Text;
      Char@1007 : Char;
      i@1008 : Integer;
      NoOfParameters@1009 : Integer;
      ParameterStart@1010 : ARRAY [100] OF Integer;
      Position@1011 : Integer;
      IsVar@1012 : Boolean;
      ParametersStart@1013 : Boolean;
      VariableOpen@1014 : Boolean;
    BEGIN
      CALHistoryLine.SETRANGE("Line No.", CALHistoryLine."Line No.");
      CALHistoryLine.SETRANGE("Sub Line No.");
      IF CALHistoryLine.FINDSET THEN
        REPEAT
          CodeLine += CALHistoryLine.Code;
        UNTIL CALHistoryLine.NEXT = 0;
      CALHistoryLine.SETRANGE("Line No.");
      CALHistoryLine.SETRANGE("Sub Line No.", 1);

      Position := 1;

      WHILE Position < STRLEN(CodeLine) DO BEGIN
        Char := CodeLine[Position];

        CASE TRUE OF

          VariableOpen :
            IF Char = '"' THEN
              VariableOpen := FALSE;

          NOT ParametersStart AND (Char = '(') :
            BEGIN
              ParametersStart := TRUE;
              NoOfParameters += 1;
              ParameterStart[NoOfParameters] := Position + 1;
            END;

          Char = '"' :
            VariableOpen := TRUE;

          Char = ';' :
            BEGIN
              NoOfParameters += 1;
              ParameterStart[NoOfParameters] := Position + 1;
            END;

          Char = ')' :
            CodeLine := DELSTR(CodeLine, Position + 1);

        END;
        Position += 1;

      END;

      FOR i := 1 TO NoOfParameters DO BEGIN
        IF i = NoOfParameters THEN
          ParameterCode := COPYSTR(CodeLine, ParameterStart[i])
        ELSE
          ParameterCode := COPYSTR(CodeLine, ParameterStart[i], ParameterStart[i + 1] - ParameterStart[i]);

        IsVar := DELSTR(ParameterCode, 5) = 'VAR ';
        IF IsVar THEN
          ParameterCode := COPYSTR(ParameterCode, 5);

        IF ParameterCode <> ')' THEN BEGIN
          IF STRLEN(ParameterCode) > 250 THEN
            CALHistoryLine.Code := DELSTR(ParameterCode, 251)
          ELSE
            CALHistoryLine.Code := ParameterCode;
          AnalyseVariableLine(Object, CALHistoryLine, VariableBuffer, Comment, 1, IsVar, Identifier);
        END;
      END;
    END;

    LOCAL PROCEDURE AnalyseVariableLine@50(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR VariableBuffer@1002 : TEMPORARY Record 11102062;VAR Comment@1003 : Record 11102081;Scope@1004 : 'Local,Parameter,Return Value,Global';IsVar@1005 : Boolean;Identifier@1006 : Code[100]);
    VAR
      Object2@1007 : Record 2000000001;
      Mgt@1008 : Codeunit 11102035;
      CodeLine@1009 : Text;
      CodeLine2@1010 : Text;
      IdString@1011 : Text;
      Name@1012 : Text;
      NameId@1013 : Text;
      ObjectNo@1014 : Text;
      ObjectNoString@1015 : Text;
      ObjectTypeString@1016 : Text;
      SubType@1017 : Text;
      Type@1018 : Text;
      Id@1019 : Integer;
      SplitPos@1020 : Integer;
      SplitPos2@1021 : Integer;
      Advanced@1022 : Boolean;
      IsTemporary2@1023 : Boolean;
      ctNameIsReserved@1024 : TextConst 'DEU=''%1'' is a reserved command;ENU=''%1'' is a reserved command;ESP=''%1'' is a reserved command;FRA=''%1'' is a reserved command;NLD=''%1'' is een gereserveerd commando;DEA=''%1'' is a reserved command';
      ctRemoveSpace@1025 : TextConst 'DEU=Remove space from variable name;ENU=Remove space from variable name;ESP=Remove space from variable name;FRA=Remove space from variable name;NLD=Verwijder spatie uit variabelenaam;DEA=Remove space from variable name';
      ctStartCapital@1026 : TextConst 'DEU=Start a variable name with a capital;ENU=Start a variable name with a capital;ESP=Start a variable name with a capital;FRA=Start a variable name with a capital;NLD=Begin variabelenaam met een hoofdletter;DEA=Start a variable name with a capital';
    BEGIN
      CodeLine := DELCHR(CALHistoryLine.Code, '<>');

      IF (CodeLine[1] IN ['''', ';']) OR (CodeLine = '') THEN
        EXIT;

      CodeLine := GetTotalLine(CALHistoryLine);
      CodeLine := DELCHR(CodeLine, '<>');

      Advanced := CodeLine[1] = '"';
      IF Advanced THEN BEGIN
        SplitPos := STRPOS(CodeLine, ' : ');
        IF STRPOS(CodeLine, '@') > SplitPos THEN BEGIN
          CodeLine2 := COPYSTR(CodeLine, STRPOS(CodeLine, '@'));
          SplitPos := STRPOS(CodeLine, '@') + STRPOS(CodeLine2, ' : ');
        END;
      END ELSE
        SplitPos := STRPOS(CodeLine, ' : ');

      IF SplitPos = 0 THEN
        EXIT;

      NameId := DELSTR(CodeLine, SplitPos);
      Type := COPYSTR(CodeLine, SplitPos + 3);

      IF DELSTR(Type, 8) = 'ARRAY [' THEN BEGIN
        SplitPos := STRPOS(Type, ' OF ');
        IF SplitPos > 0 THEN
          Type := COPYSTR(Type, STRPOS(Type, ' OF ') + 4);
      END;

      SplitPos := STRPOS(Type, ' ');
      IF SplitPos > 0 THEN
        ObjectTypeString := DELSTR(Type, SplitPos);

      IF ObjectTypeString = 'TEMPORARY' THEN BEGIN
        IsTemporary2 := TRUE;
        Type := COPYSTR(Type, SplitPos + 1);
        ObjectTypeString := '';
        SplitPos := STRPOS(Type, ' ');
        IF SplitPos > 0 THEN
          ObjectTypeString := DELSTR(Type, SplitPos);
      END;

      IF ObjectTypeString <> '' THEN BEGIN
        IF ObjectTypeString = 'Record' THEN
          Object2.Type := Object2.Type::Table
        ELSE
          IF EVALUATE(Object2.Type, ObjectTypeString) THEN
            ;
        IF Object2.Type <> Object2.Type::TableData THEN BEGIN
          ObjectNoString := COPYSTR(Type, STRLEN(ObjectTypeString) + 2);
          ObjectNoString := DELSTR(ObjectNoString, STRLEN(ObjectNoString));
          SplitPos := STRPOS(ObjectNoString, ' ');
          IF SplitPos > 0 THEN
            ObjectNoString := COPYSTR(ObjectNoString, 1, SplitPos);
          IF EVALUATE(ObjectNo, ObjectNoString) THEN
            SubType := FORMAT(ObjectNo);
        END;
      END;

      IF Advanced THEN BEGIN
        SplitPos2 := STRLEN(NameId) - 1;
        IF STRPOS(NameId, '@') = 0 THEN
          SplitPos2 := 0
        ELSE
          WHILE NameId[SplitPos2] <> '@' DO
            SplitPos2 -= 1;
      END ELSE
        SplitPos2 := STRPOS(NameId, '@');

      IF SplitPos2 > 0 THEN BEGIN
        Name := DELSTR(NameId, SplitPos2);
        IdString := COPYSTR(NameId, SplitPos2 + 1);
        EVALUATE(Id, IdString);
      END ELSE BEGIN
        Id := 1;
        Name := NameId;
      END;

      IF Advanced THEN
        Name := DELCHR(Name, '<>', '"');

      IF STRPOS(Name, ' ') > 0 THEN
        AddNamingComment(
          Comment, NamingCheck::Variable, ctRemoveSpace,
          CALHistoryLine."Line No.", Identifier + '-' + FORMAT(Id) + '-SPACE');

      IF Mgt.IsReservedKeyword(Name) THEN
        AddNamingComment(Comment, NamingCheck::Reserved, STRSUBSTNO(ctNameIsReserved, Name), CALHistoryLine."Line No.", '');

      IF NOT IsVar AND (DELSTR(Type, 7) = 'Record') THEN
        TestBufferIdentifier(CALHistoryLine, Comment, Name, IsTemporary2, Identifier + '-' + FORMAT(Id));

      IF NOT (Scope = Scope::Parameter) THEN
        IF STRLEN(Name) > 2 THEN
          IF (FORMAT(Name[1]) <> UPPERCASE(FORMAT(Name[1]))) AND
             (FORMAT(Name[2]) <> UPPERCASE(FORMAT(Name[2]))) AND
             (FORMAT(Name[3]) <> UPPERCASE(FORMAT(Name[3])))
          THEN
            AddNamingComment(
              Comment, NamingCheck::Variable, ctStartCapital,
              CALHistoryLine."Line No.", Identifier + '-' + FORMAT(Id) + '-CAPITAL');

      VariableBufferEntryNo += 1;
      VariableBuffer."Entry No." := VariableBufferEntryNo;
      VariableBuffer.Id := Id;
      VariableBuffer.Name := Name;
      VariableBuffer.Scope := Scope;
      VariableBuffer.Used := FALSE;

      IF DELSTR(Type, 7) = 'Record' THEN BEGIN
        VariableBuffer."Object Type" := VariableBuffer."Object Type"::Table;
        Type := COPYSTR(Type, 8);
        IF EVALUATE(VariableBuffer."Object No.", ObjectNoString) THEN
          ;
      END ELSE BEGIN
        VariableBuffer."Object Type" := 0;
        VariableBuffer."Object No." := 0;
      END;

      VariableBuffer."C/AL Line No." := CALHistoryLine."Line No.";

      IF DELSTR(Type, 10) = 'TextConst' THEN
        AnalyseTextConst(Object, CALHistoryLine, VariableBuffer, Comment, Identifier);

      VariableBuffer.INSERT;
    END;

    LOCAL PROCEDURE AnalyseTextConst@93(VAR Object@1000 : Record 2000000001;VAR CALHistoryLine@1001 : Record 11102053;VAR VariableBuffer@1002 : TEMPORARY Record 11102062;VAR Comment@1003 : Record 11102081;Identifier@1004 : Code[100]);
    VAR
      Buffer@1005 : TEMPORARY Record 11102068;
      TmpLine@1006 : ARRAY [2] OF TEMPORARY Record 11102068;
      TranslationMgt@1007 : Codeunit 11102051;
      TotalCaption@1008 : Text;
      CALLineNo@1009 : Integer;
      i@1010 : Integer;
      Id@1011 : Integer;
      AddExclamationComment@1012 : Boolean;
      AddParameterComment@1013 : Boolean;
      AddPeriodComment@1014 : Boolean;
      AddQuestionMarkComment@1015 : Boolean;
      PeriodAtEnd@1016 : Boolean;
      QuestionMarkAtEnd@1017 : Boolean;
      ctAddCaption@1018 : TextConst 'DEU=Add %1 caption;ENU=Add %1 caption;ESP=Add %1 caption;FRA=Add %1 caption;NLD=Voeg %1 caption toe;DEA=Add %1 caption';
      ctGap@1019 : TextConst 'DEU=There is a gap in the parameter numbers;ENU=There is a gap in the parameter numbers;ESP=There is a gap in the parameter numbers;FRA=There is a gap in the parameter numbers;NLD=Er mist een parameternummer;DEA=There is a gap in the parameter numbers';
      ctNoOfParameters@1020 : TextConst 'DEU=Inconsistent no. of parameters;ENU=Inconsistent no. of parameters;ESP=Inconsistent no. of parameters;FRA=Inconsistent no. of parameters;NLD=Inconsistent aantal parameters;DEA=Inconsistent no. of parameters';
      ctPeriod@1021 : TextConst 'DEU=Add or remove a period;ENU=Add or remove a period;ESP=Add or remove a period;FRA=Add or remove a period;NLD=Verwijder of voeg een punt toe;DEA=Add or remove a period';
      ctQuestionMark@1022 : TextConst 'DEU=Add or remove a question mark;ENU=Add or remove a question mark;ESP=Add or remove a question mark;FRA=Add or remove a question mark;NLD=Verwijder of voeg een vraagteken toe;DEA=Add or remove a question mark';
      ctRemoveExclamation@1023 : TextConst 'DEU=Replace exclamation mark with a period;ENU=Replace exclamation mark with a period;ESP=Replace exclamation mark with a period;FRA=Replace exclamation mark with a period;NLD=Vervang uitroepteken door een punt;DEA=Replace exclamation mark with a period';
    BEGIN
      CALLineNo := CALHistoryLine."Line No.";
      IF CALHistoryLine."Sub Line No." <> 1 THEN BEGIN
        CALHistoryLine."Sub Line No." := 1;
        CALHistoryLine.FIND('=');
      END;

      TranslationMgt.ParseTextConstants(Buffer, CALHistoryLine, CALHistoryLine.Code, '');
      TranslationMgt.FinalizeBuffer(Buffer, TmpLine, 0, 0);

      FOR i := 1 TO NoOfMandLanguages DO BEGIN
        TmpLine[1].SETRANGE("Language Id", MandLanguageId[i]);
        IF TmpLine[1].ISEMPTY THEN
          AddCaptionComment(
            Comment, CaptionCheck::"Missing Captions", STRSUBSTNO(ctAddCaption, MandLanguage[i]),
            CALLineNo, Identifier + '-' + FORMAT(Id) + '-CAPTION');
      END;

      TmpLine[1].SETFILTER("Language Id", '>1');
      IF TmpLine[1].FINDSET THEN BEGIN

        TotalCaption := TmpLine[1].TotalCaption;
        PeriodAtEnd := TotalCaption[STRLEN(TotalCaption)] = '.';
        QuestionMarkAtEnd := TotalCaption[STRLEN(TotalCaption)] = '?';
        VariableBuffer.Parameters := GetNoOfParameters(TotalCaption);

        IF STRLEN(DELCHR(VariableBuffer.Parameters, '>', '0')) <> STRLEN(DELCHR(VariableBuffer.Parameters, '=', '0')) THEN
          AddCodingComment(Comment, CodingCheck::TextConst, ctGap, CALLineNo, 0, 0, Identifier + '-GAP');

        REPEAT
          TotalCaption := TmpLine[1].TotalCaption;
          IF TotalCaption[STRLEN(TotalCaption)] = '.' <> PeriodAtEnd THEN
            AddPeriodComment := TRUE;

          IF TotalCaption[STRLEN(TotalCaption)] = '?' <> QuestionMarkAtEnd THEN
            AddQuestionMarkComment := TRUE;

          IF GetNoOfParameters(TotalCaption) <> VariableBuffer.Parameters THEN
            AddParameterComment := TRUE;

          IF STRPOS(TotalCaption, '!') > 0 THEN
            AddExclamationComment := TRUE;

        UNTIL TmpLine[1].NEXT = 0;

        IF AddPeriodComment AND (Object.Type <> Object.Type::Report) THEN
          AddCodingComment(Comment, CodingCheck::TextConst, ctPeriod, CALLineNo, 0, 0, Identifier + '-PERIOD');

        IF AddQuestionMarkComment THEN
          AddCodingComment(Comment, CodingCheck::TextConst, ctQuestionMark, CALLineNo, 0, 0, Identifier + '-QUESTION');

        IF AddParameterComment THEN
          AddCodingComment(Comment, CodingCheck::TextConst, ctNoOfParameters, CALLineNo, 0, 0, Identifier + '-PAR');

        IF AddExclamationComment THEN
          AddCodingComment(Comment, CodingCheck::TextConst, ctRemoveExclamation, CALLineNo, 0, 0, Identifier + '-EXCL');

      END;
    END;

    LOCAL PROCEDURE GetNoOfParameters@91(TotalCaption@1000 : Text) Parameters : Text;
    VAR
      ParameterNoText@1001 : Text;
      i@1002 : Integer;
      ParameterNo@1003 : Integer;
      ParameterOpen@1004 : Boolean;
    BEGIN
      Parameters := PADSTR('', 30, '0');

      FOR i := 1 TO STRLEN(TotalCaption) DO
        CASE TRUE OF

          NOT ParameterOpen AND (TotalCaption[i] = '%') :
            IF i < STRLEN(TotalCaption) THEN
              IF (TotalCaption[i + 1] >= '0') AND (TotalCaption[i + 1] <= '9') THEN
                ParameterOpen := TRUE;

          ParameterOpen :
            IF (TotalCaption[i] >= '0') AND (TotalCaption[i] <= '9') THEN
              ParameterNoText += FORMAT(TotalCaption[i])
            ELSE BEGIN
              IF EVALUATE(ParameterNo, ParameterNoText) THEN
                IF ParameterNo <= STRLEN(Parameters) THEN
                  Parameters[ParameterNo] := '1';

              ParameterNoText := '';
              ParameterOpen := FALSE;
              i -= 1;
            END;

        END;

      IF EVALUATE(ParameterNo, ParameterNoText) THEN
        IF ParameterNo <= STRLEN(Parameters) THEN
          Parameters[ParameterNo] := '1';
    END;

    LOCAL PROCEDURE TestBufferIdentifier@51(VAR CALHistoryLine@1000 : Record 11102053;VAR Comment@1001 : Record 11102081;Name@1002 : Text;IsTemporary2@1003 : Boolean;Identifier@1004 : Code[100]);
    VAR
      LowercaseName@1005 : Text;
      TempIdentifier@1006 : Text;
      i@1007 : Integer;
      NameLength@1008 : Integer;
      TempPos@1009 : Integer;
      NamingIsTemporary@1010 : Boolean;
      ctAddTmp@1011 : TextConst 'DEU=Add ''tmp'', ''temp'' or ''buffer'' to variable name;ENU=Add ''tmp'', ''temp'' or ''buffer'' to variable name;ESP=Add ''tmp'', ''temp'' or ''buffer'' to variable name;FRA=Add ''tmp'', ''temp'' or ''buffer'' to variable name;NLD=Voeg ''tmp'', ''temp'' of ''buffer'' toe aan variabelenaam;DEA=Add ''tmp'', ''temp'' or ''buffer'' to variable name';
      ctRemoveTmp@1012 : TextConst 'DEU=Remove ''%1'' from variable name;ENU=Remove ''%1'' from variable name;ESP=Remove ''%1'' from variable name;FRA=Remove ''%1'' from variable name;NLD=Verwijder ''%1'' van variabelenaam;DEA=Remove ''%1'' from variable name';
    BEGIN
      LowercaseName := LOWERCASE(Name);

      NameLength := STRLEN(Name);

      FOR i := 1 TO 4 DO
        IF NOT NamingIsTemporary THEN BEGIN
          TempPos := STRPOS(LowercaseName, BufferIdentifier[i]);
          IF (TempPos <> 0) AND
             (TempPos IN [1, 2, NameLength - STRLEN(BufferIdentifier[i]), NameLength - STRLEN(BufferIdentifier[i]) + 1])
          THEN BEGIN
            NamingIsTemporary := TRUE;
            TempIdentifier := COPYSTR(Name, TempPos, STRLEN(BufferIdentifier[i]));
            IF COPYSTR(LowercaseName, TempPos, 8) = 'template' THEN
              NamingIsTemporary := FALSE;
          END;
        END;
      IF IsTemporary2 AND NOT NamingIsTemporary THEN
        AddNamingComment(Comment, NamingCheck::Temp, ctAddTmp, CALHistoryLine."Line No.", Identifier);

      IF NOT IsTemporary2 AND NamingIsTemporary THEN
        AddNamingComment(Comment, NamingCheck::Temp, STRSUBSTNO(ctRemoveTmp, TempIdentifier), CALHistoryLine."Line No.", Identifier);
    END;

    LOCAL PROCEDURE AddCodingComment@52(VAR CheckGuidelinesComment@1000 : Record 11102081;pCheckOption@1001 : Integer;Comment@1002 : Text;CALLineNo@1003 : Integer;Parameter@1004 : Integer;Parameter2@1005 : Integer;Identifier@1006 : Code[100]);
    BEGIN
      IF CheckCodeOption[pCheckOption] THEN
        AddComment(CheckGuidelinesComment, CheckType::Coding, pCheckOption, Comment, CALLineNo, Parameter, Parameter2, Identifier);
    END;

    LOCAL PROCEDURE AddLayoutComment@53(VAR CheckGuidelinesComment@1000 : Record 11102081;pCheckOption@1001 : Integer;Comment@1002 : Text;CALLineNo@1003 : Integer;Identifier@1004 : Code[100]);
    BEGIN
      IF CheckLayoutOption[pCheckOption] THEN
        AddComment(CheckGuidelinesComment, CheckType::Layout, pCheckOption, Comment, CALLineNo, 0, 0, Identifier);
    END;

    LOCAL PROCEDURE AddDataComment@54(VAR CheckGuidelinesComment@1000 : Record 11102081;pCheckOption@1001 : Integer;Comment@1002 : Text;CALLineNo@1003 : Integer;Identifier@1004 : Code[100]);
    BEGIN
      IF CheckDataOption[pCheckOption] THEN
        AddComment(CheckGuidelinesComment, CheckType::Data, pCheckOption, Comment, CALLineNo, 0, 0, Identifier);
    END;

    LOCAL PROCEDURE AddNamingComment@55(VAR CheckGuidelinesComment@1000 : Record 11102081;pCheckOption@1001 : Integer;Comment@1002 : Text;CALLineNo@1003 : Integer;Identifier@1004 : Code[100]);
    BEGIN
      IF CheckNamingOption[pCheckOption] THEN
        AddComment(CheckGuidelinesComment, CheckType::Naming, pCheckOption, Comment, CALLineNo, 0, 0, Identifier);
    END;

    LOCAL PROCEDURE AddTransportComment@126(VAR CheckGuidelinesComment@1000 : Record 11102081;pCheckOption@1001 : Integer;Comment@1002 : Text[250];CALLineNo@1003 : Integer;Parameter@1004 : Integer;Parameter2@1005 : Integer;Identifier@1006 : Code[100]);
    BEGIN
      IF CheckTransportOption[pCheckOption] THEN
        AddComment(CheckGuidelinesComment, CheckType::Transport, pCheckOption, Comment, CALLineNo, Parameter, Parameter2, Identifier);
    END;

    LOCAL PROCEDURE AddCaptionComment@56(VAR CheckGuidelinesComment@1000 : Record 11102081;pCheckOption@1001 : Integer;Comment@1002 : Text;CALLineNo@1003 : Integer;Identifier@1004 : Code[100]);
    BEGIN
      IF CheckCaptionOption[pCheckOption] THEN
        AddComment(CheckGuidelinesComment, CheckType::Captions, pCheckOption, Comment, CALLineNo, 0, 0, Identifier);
    END;

    LOCAL PROCEDURE AddComment@57(VAR CheckGuidelinesComment@1000 : Record 11102081;pCheckType@1001 : Integer;pCheckOption@1002 : Integer;Comment@1003 : Text;CALLineNo@1004 : Integer;Parameter@1005 : Integer;Parameter2@1006 : Integer;Identifier@1007 : Code[100]);
    BEGIN
      CheckGuidelinesComment."Entry No." += 1;

      IF pCheckType = CheckType::"Comma Space" THEN
        CheckGuidelinesComment.Type := CheckGuidelinesComment.Type::Coding
      ELSE
        CheckGuidelinesComment.Type := pCheckType;

      CheckGuidelinesComment."Comment No." := CheckFieldNo[pCheckType, pCheckOption];
      CheckGuidelinesComment.Comment := Comment;
      CheckGuidelinesComment."C/AL Line No." := CALLineNo;
      CheckGuidelinesComment."Autocorrect Group" := AutocorrectGroup(CheckFieldNo[pCheckType, pCheckOption]);
      CheckGuidelinesComment."Autocorrect Parameter" := Parameter;
      CheckGuidelinesComment."Autocorrect Parameter 2" := Parameter2;
      CheckGuidelinesComment.Identifier := Identifier;
      CheckGuidelinesComment.Critical := IsCriticalCheck[pCheckType, pCheckOption];
      CheckGuidelinesComment."Function Name" := DELSTR(FunctionName, MAXSTRLEN(CheckGuidelinesComment."Function Name"));;
      CheckGuidelinesComment.INSERT;
    END;

    LOCAL PROCEDURE SaveComments@58(VAR Object@1000 : Record 2000000001;VAR TmpCheckGuidelinesComment@1001 : TEMPORARY Record 11102081);
    VAR
      CheckGuidelinesComment@1002 : Record 11102081;
      KnownComment@1003 : Record 11102081;
      TmpKeepKnownComment@1004 : TEMPORARY Record 11102081;
      EntryNo@1005 : Integer;
    BEGIN
      CheckGuidelinesComment.SETRANGE("Object Type", Object.Type);
      CheckGuidelinesComment.SETRANGE("Object No.", Object.ID);
      CheckGuidelinesComment.SETRANGE("Known Comment", FALSE);
      CheckGuidelinesComment.DELETEALL;

      CheckGuidelinesComment.RESET;

      KnownComment.SETRANGE("Object Type", Object.Type);
      KnownComment.SETRANGE("Object No.", Object.ID);
      KnownComment.SETRANGE("Known Comment", TRUE);
      IF KnownComment.FINDLAST THEN
        EntryNo := KnownComment."Entry No.";

      KnownComment.SETCURRENTKEY("Object Type", "Object No.", "Comment No.", Identifier);

      IF TmpCheckGuidelinesComment.FINDSET THEN
        REPEAT

          KnownComment.SETRANGE("Comment No.", TmpCheckGuidelinesComment."Comment No.");
          KnownComment.SETRANGE(Identifier, TmpCheckGuidelinesComment.Identifier);
          IF KnownComment.FINDFIRST THEN
            REPEAT
              KnownComment."C/AL Line No." := TmpCheckGuidelinesComment."C/AL Line No.";
              KnownComment.Comment := TmpCheckGuidelinesComment.Comment;
              KnownComment."Autocorrect Parameter" := TmpCheckGuidelinesComment."Autocorrect Parameter";
              KnownComment.MODIFY;

              IF NOT TmpKeepKnownComment.GET(KnownComment."Object Type", KnownComment."Object No.", KnownComment."Entry No.") THEN BEGIN
                TmpKeepKnownComment := KnownComment;
                TmpKeepKnownComment.INSERT;
              END;

            UNTIL KnownComment.NEXT = 0
          ELSE BEGIN
            EntryNo += 1;
            CheckGuidelinesComment := TmpCheckGuidelinesComment;
            CheckGuidelinesComment."Entry No." := EntryNo;
            CheckGuidelinesComment."Object Type" := Object.Type;
            CheckGuidelinesComment."Object No." := Object.ID;
            CheckGuidelinesComment.INSERT;
          END;
        UNTIL TmpCheckGuidelinesComment.NEXT = 0;

      KnownComment.SETRANGE(Type);
      KnownComment.SETRANGE(Comment);
      KnownComment.SETRANGE("C/AL Line No.");
      IF KnownComment.FINDSET THEN
        REPEAT
          IF NOT TmpKeepKnownComment.GET(KnownComment."Object Type", KnownComment."Object No.", KnownComment."Entry No.") THEN
            KnownComment.DELETE;
        UNTIL KnownComment.NEXT = 0;
    END;

    LOCAL PROCEDURE GetCode@59(VAR Object@1000 : Record 2000000001;VAR TmpCALHistoryLine@1001 : TEMPORARY Record 11102053);
    VAR
      CALHistoryObject@1002 : Record 11102052;
      CALHistoryLine@1003 : Record 11102053;
      SourceControl@1004 : Codeunit 11102050;
    BEGIN
      IF SourceControl.ObjectHeaderIsOutdated(Object, TRUE) THEN
        IF SourceControl.ExportObjectPermission(Object) THEN
          SourceControl.AddObject(Object, 0, TRUE, TRUE, 2, FALSE);

      IF CALHistoryObject.TryGoToLastRecord(Object.Type, Object.ID) THEN BEGIN
        CALHistoryLine.SETRANGE("Entry No.", CALHistoryObject."Entry No.");
        IF CALHistoryLine.FINDSET THEN
          REPEAT
            TmpCALHistoryLine := CALHistoryLine;
            TmpCALHistoryLine."Entry No." := 0;
            TmpCALHistoryLine.INSERT;
          UNTIL CALHistoryLine.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE GetTotalLine@60(VAR CALHistoryLine@1000 : Record 11102053) ExitValue : Text;
    VAR
      PrevSubLineFilter@1001 : Boolean;
    BEGIN
      CALHistoryLine.FILTERGROUP(10);
      CALHistoryLine.SETRANGE("Line No.", CALHistoryLine."Line No.");
      CALHistoryLine.FILTERGROUP(0);

      PrevSubLineFilter := CALHistoryLine.GETFILTER("Sub Line No.") <> '';

      CALHistoryLine.SETRANGE("Sub Line No.");
      REPEAT
        ExitValue += CALHistoryLine.Code;
      UNTIL CALHistoryLine.NEXT = 0;
      CALHistoryLine.FILTERGROUP(10);
      CALHistoryLine.SETRANGE("Line No.");
      CALHistoryLine.FILTERGROUP(0);
      IF PrevSubLineFilter THEN
        CALHistoryLine.SETRANGE("Sub Line No.", 1);
    END;

    LOCAL PROCEDURE SetRangeOnSection@61(VAR CALHistoryLine@1000 : Record 11102053;SectionName@1001 : Text) : Boolean;
    VAR
      SectionEnd@1002 : Integer;
      SectionStart@1003 : Integer;
    BEGIN
      CALHistoryLine.RESET;
      CALHistoryLine.SETRANGE("Sub Line No.", 1);
      CALHistoryLine.SETRANGE("Entry No.", 0);
      CALHistoryLine.SETRANGE(Code, '  ' + SectionName);
      IF CALHistoryLine.FINDFIRST THEN BEGIN
        SectionStart := CALHistoryLine."Line No." + 2;
        CALHistoryLine.SETFILTER("Line No.", '>%1', CALHistoryLine."Line No.");
        CALHistoryLine.SETRANGE("Sub Line No.", 1);
        CALHistoryLine.SETRANGE(Code, '  }');
        IF CALHistoryLine.FINDFIRST THEN
          SectionEnd := CALHistoryLine."Line No." - 1;
        IF (SectionStart <> 0) AND (SectionEnd <> 0) THEN BEGIN
          CALHistoryLine.RESET;
          CALHistoryLine.SETRANGE("Entry No.", 0);
          CALHistoryLine.SETRANGE("Line No.", SectionStart, SectionEnd);
          IF CALHistoryLine.FINDFIRST THEN
            ;
          EXIT(TRUE);
        END;
      END;
    END;

    LOCAL PROCEDURE NextValue@62(VAR TextLine@1000 : Text;VAR Position@1001 : Integer;Seperator@1002 : Char;OpenChar@1003 : Char;CloseChar@1004 : Char;VAR ExitValue@1005 : Text) : Boolean;
    VAR
      Char@1006 : Char;
      Advanced@1007 : Boolean;
      FirstCharacter@1008 : Boolean;
      RemoveSeperators@1009 : Boolean;
      Stop@1010 : Boolean;
    BEGIN
      ExitValue := '';
      FirstCharacter := TRUE;

      IF Position > STRLEN(TextLine) THEN
        EXIT(FALSE);

      WHILE NOT Stop DO

        IF NextChar(TextLine, Position, Char) THEN BEGIN

          CASE Char OF

            Seperator :
              IF Advanced THEN
                ExitValue += FORMAT(Char)
              ELSE
                Stop := TRUE;

            OpenChar :
              IF FirstCharacter THEN BEGIN
                Advanced := TRUE;
                RemoveSeperators := TRUE;
                ExitValue += FORMAT(Char);
              END ELSE
                IF OpenChar = CloseChar THEN BEGIN
                  IF Advanced THEN
                    IF NextChar(TextLine, Position, Char) THEN
                      IF Char = CloseChar THEN
                        ExitValue += FORMAT(Char)
                      ELSE BEGIN
                        Advanced := FALSE;
                        Position -= 1;
                      END;
                END ELSE
                  ExitValue += FORMAT(Char);

            CloseChar :
              BEGIN
                ExitValue += FORMAT(Char);
                IF Advanced THEN
                  IF NextChar(TextLine, Position, Char) THEN
                    IF Char <> CloseChar THEN BEGIN
                      Advanced := FALSE;
                      Position -= 1;
                    END;
              END;

            ELSE
              ExitValue += FORMAT(Char);
          END;

          FirstCharacter := FALSE;

        END ELSE
          Stop := TRUE;

      ExitValue := DELCHR(ExitValue, '<>');
      IF RemoveSeperators THEN BEGIN
        IF ExitValue[1] = OpenChar THEN
          ExitValue := COPYSTR(ExitValue, 2);
        IF STRLEN(ExitValue) > 0 THEN
          IF ExitValue[STRLEN(ExitValue)] = CloseChar THEN
            ExitValue := DELSTR(ExitValue, STRLEN(ExitValue));
      END;

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE NextChar@63(VAR TextLine@1000 : Text;VAR Position@1001 : Integer;VAR Char@1002 : Char) : Boolean;
    BEGIN
      IF Position <= STRLEN(TextLine) THEN BEGIN
        Char := TextLine[Position];
        Position += 1;
        EXIT(TRUE);
      END;
    END;

    LOCAL PROCEDURE NextField@64(VAR TextLine@1000 : Text;VAR Position@1001 : Integer;VAR ExitValue@1002 : Text) : Boolean;
    VAR
      Char@1003 : Char;
      Advanced@1004 : Boolean;
      Stop@1005 : Boolean;
    BEGIN
      ExitValue := '';

      IF Position > STRLEN(TextLine) THEN
        EXIT(FALSE);

      WHILE NOT Stop DO

        IF NextChar(TextLine, Position, Char) THEN

          CASE Char OF

            ' ' :
              IF Advanced THEN
                ExitValue += FORMAT(Char);

            '.' :
              IF Advanced THEN
                ExitValue += FORMAT(Char)
              ELSE
                ExitValue := '';

            '"' :
              BEGIN
                Advanced := NOT Advanced;
                IF NextChar(TextLine, Position, Char) THEN
                  IF Char = '"' THEN BEGIN
                    ExitValue += FORMAT(Char);
                    Advanced := NOT Advanced;
                  END ELSE
                    Position -= 1;
              END;

            ',', ')' :
              IF Advanced THEN
                ExitValue += FORMAT(Char)
              ELSE
                Stop := TRUE;

            ELSE
              ExitValue += FORMAT(Char);

          END

        ELSE
          Stop := TRUE;

      EXIT(TRUE);
    END;

    LOCAL PROCEDURE GetPropertyName@65(VAR CodeLine@1000 : Text;VAR Name@1001 : Text);
    VAR
      Position@1002 : Integer;
    BEGIN
      Name := '';

      Position := STRPOS(CodeLine, '=');
      IF Position <> 0 THEN BEGIN
        Name := DELSTR(CodeLine, Position);
        Name := DELCHR(Name, '<>');
      END;
    END;

    PROCEDURE GetPropertyValue@66(VAR CALHistoryLine@1000 : Record 11102053;VAR Value@1001 : Text);
    VAR
      Position@1002 : Integer;
    BEGIN
      Value := '';

      Position := STRPOS(CALHistoryLine.Code, '=');

      IF Position <> 0 THEN BEGIN
        Value := COPYSTR(CALHistoryLine.Code, Position + 1);
        IF Value[1] = '[' THEN
          Value := DELCHR(COPYSTR(Value, 2), '>', ' ;]}')
        ELSE
          Value := DELCHR(Value, '>', ' ;}');
      END;
    END;

    PROCEDURE NoOfOptionsChecked@68(VAR Setup@1000 : Record 11102035;pCheckOption@1001 : Integer) ExitValue : Integer;
    VAR
      Fld@1002 : Record 2000000041;
      RecRef@1003 : RecordRef;
      FldRef@1004 : FieldRef;
      FldRefValue@1005 : Boolean;
    BEGIN
      RecRef.GETTABLE(Setup);

      Fld.SETRANGE(TableNo, DATABASE::"OM - Setup");
      Fld.SETFILTER(FieldName, 'Check *');
      IF Fld.FINDSET THEN
        REPEAT
          FldRef := RecRef.FIELD(Fld."No.");
          EVALUATE(FldRefValue, FORMAT(FldRef.VALUE));
          IF FldRefValue THEN
            CASE pCheckOption OF

              CheckType::Coding :
                IF CodingCheckNo(Fld."No.") <> 0 THEN
                  ExitValue += 1;

              CheckType::Layout :
                IF LayoutCheckNo(Fld."No.") <> 0 THEN
                  ExitValue += 1;

              CheckType::Data :
                IF DataCheckNo(Fld."No.") <> 0 THEN
                  ExitValue += 1;

              CheckType::Naming :
                IF NamingCheckNo(Fld."No.") <> 0 THEN
                  ExitValue += 1;

              CheckType::Transport :
                IF TransportCheckNo(Fld."No.") <> 0 THEN
                  ExitValue += 1;

              CheckType::Captions :
                IF CaptionCheckNo(Fld."No.") <> 0 THEN
                  ExitValue += 1;

            END;

        UNTIL Fld.NEXT = 0;
    END;

    PROCEDURE DrillDownNoOfOptions@69(VAR Setup@1000 : Record 11102035;pCheckOption@1001 : Integer);
    VAR
      TmpSelectedUser@1002 : TEMPORARY Record 11102056;
      TmpUser@1003 : TEMPORARY Record 11102056;
      Fld@1004 : Record 2000000041;
      SelectUsers@1005 : Page 11102091;
      RecRef@1006 : RecordRef;
      FldRef@1007 : FieldRef;
      CheckOptionNo@1008 : Integer;
      FldRefValue@1009 : Boolean;
      ctSetOptions@1010 : TextConst 'DEU=Check Guidelines Options;ENU=Check Guidelines Options;ESP=Check Guidelines Options;FRA=Check Guidelines Options;NLD=Controleer richtijnopties;DEA=Check Guidelines Options';
    BEGIN
      RecRef.GETTABLE(Setup);

      Fld.SETRANGE(TableNo, DATABASE::"OM - Setup");
      Fld.SETFILTER(FieldName, 'Check *');
      IF Fld.FINDSET THEN
        REPEAT
          CASE pCheckOption OF
            CheckType::Coding : CheckOptionNo := CodingCheckNo(Fld."No.");
            CheckType::Layout : CheckOptionNo := LayoutCheckNo(Fld."No.");
            CheckType::Data : CheckOptionNo := DataCheckNo(Fld."No.");
            CheckType::Naming : CheckOptionNo := NamingCheckNo(Fld."No.");
            CheckType::Transport : CheckOptionNo := TransportCheckNo(Fld."No.");
            CheckType::Captions : CheckOptionNo := CaptionCheckNo(Fld."No.");
          END;
          IF CheckOptionNo <> 0 THEN BEGIN
            FldRef := RecRef.FIELD(Fld."No.");
            TmpUser.Code := PADSTR('', 3 - STRLEN(FORMAT(CheckOptionNo)), '0') + FORMAT(CheckOptionNo);
            TmpUser.Name := Fld."Field Caption";
            TmpUser.INSERT;

            EVALUATE(FldRefValue, FORMAT(FldRef.VALUE));
            IF FldRefValue THEN BEGIN
              TmpSelectedUser := TmpUser;
              TmpSelectedUser.INSERT;
            END;
          END;
        UNTIL Fld.NEXT = 0;

      SelectUsers.SetTmpRecord(TmpUser);
      TmpUser.FINDFIRST;
      SelectUsers.SETRECORD(TmpUser);

      SelectUsers.SetSelectedUser(TmpSelectedUser);

      SelectUsers.SetFormCaption(ctSetOptions);
      SelectUsers.LOOKUPMODE := TRUE;
      IF SelectUsers.RUNMODAL = ACTION::LookupOK THEN BEGIN

        TmpSelectedUser.DELETEALL;
        SelectUsers.GetSelectedUser(TmpSelectedUser);
        IF Fld.FINDSET THEN
          REPEAT
            FldRef := RecRef.FIELD(Fld."No.");
            CASE pCheckOption OF
              CheckType::Coding : CheckOptionNo := CodingCheckNo(Fld."No.");
              CheckType::Layout : CheckOptionNo := LayoutCheckNo(Fld."No.");
              CheckType::Data : CheckOptionNo := DataCheckNo(Fld."No.");
              CheckType::Naming : CheckOptionNo := NamingCheckNo(Fld."No.");
              CheckType::Transport : CheckOptionNo := TransportCheckNo(Fld."No.");
              CheckType::Captions : CheckOptionNo := CaptionCheckNo(Fld."No.");
            END;
            IF CheckOptionNo <> 0 THEN
              EVALUATE(FldRef, FORMAT(TmpSelectedUser.GET(PADSTR('', 3 - STRLEN(FORMAT(CheckOptionNo)), '0') + FORMAT(CheckOptionNo))));

          UNTIL Fld.NEXT = 0;
      END;

      RecRef.SETTABLE(Setup);
    END;

    PROCEDURE DrillDownCriticalChecks@70(VAR Setup@1000 : Record 11102035);
    VAR
      TmpSelectedUser@1001 : TEMPORARY Record 11102056;
      TmpUser@1002 : TEMPORARY Record 11102056;
      Fld@1003 : Record 2000000041;
      TmpFld2@1004 : TEMPORARY Record 2000000041;
      SelectUsers@1005 : Page 11102091;
      RecRef@1006 : RecordRef;
      FldRef@1007 : FieldRef;
      FieldString@1008 : Text;
      CheckOptionNo@1009 : Integer;
      i@1010 : Integer;
      FirstField@1011 : Boolean;
      ctCaptions@1012 : TextConst 'DEU=Captions;ENU=Captions;ESP=Captions;FRA=Captions;NLD=Captions;DEA=Captions';
      ctCodingChecks@1013 : TextConst 'DEU=Coding Checks;ENU=Coding Checks;ESP=Coding Checks;FRA=Coding Checks;NLD=Coderings controles;DEA=Coding Checks';
      ctComma@1014 : TextConst 'DEU=Comma;ENU=Comma;ESP=Comma;FRA=Comma;NLD=Komma;DEA=Comma';
      ctDataChecks@1015 : TextConst 'DEU=Data Checks;ENU=Data Checks;ESP=Data Checks;FRA=Data Checks;NLD=Data controles;DEA=Data Checks';
      ctLayoutChecks@1016 : TextConst 'DEU=Layout Checks;ENU=Layout Checks;ESP=Layout Checks;FRA=Layout Checks;NLD=Layout controles;DEA=Layout Checks';
      ctNamingChecks@1017 : TextConst 'DEU=Naming Checks;ENU=Naming Checks;ESP=Naming Checks;FRA=Naming Checks;NLD=Naamgeving controles;DEA=Naming Checks';
      ctSetOptions@1018 : TextConst 'DEU=Check Guidelines Options;ENU=Check Guidelines Options;ESP=Check Guidelines Options;FRA=Check Guidelines Options;NLD=Controleer richtijnopties;DEA=Check Guidelines Options';
    BEGIN
      RecRef.GETTABLE(Setup);

      TmpFld2.TableNo := DATABASE::"OM - Setup";
      FOR i := 1 TO STRLEN(Setup."Critical Guideline Checks") DO
        IF Setup."Critical Guideline Checks"[i] = '|' THEN BEGIN
          IF EVALUATE(TmpFld2."No.", FieldString) THEN
            TmpFld2.INSERT;
          FieldString := '';
        END ELSE
          FieldString := FieldString + FORMAT(Setup."Critical Guideline Checks"[i]);

      IF EVALUATE(TmpFld2."No.", FieldString) THEN
        TmpFld2.INSERT;

      Fld.SETRANGE(TableNo, DATABASE::"OM - Setup");
      Fld.SETFILTER(FieldName, 'Check *');

      FOR i := 1 TO 5 DO BEGIN

        FirstField := TRUE;

        IF Fld.FINDSET THEN
          REPEAT

            CASE i OF
              CheckType::Coding : CheckOptionNo := CodingCheckNo(Fld."No.");
              CheckType::Layout : CheckOptionNo := LayoutCheckNo(Fld."No.");
              CheckType::Data : CheckOptionNo := DataCheckNo(Fld."No.");
              CheckType::Naming : CheckOptionNo := NamingCheckNo(Fld."No.");
              CheckType::Captions : CheckOptionNo := CaptionCheckNo(Fld."No.");
            END;

            IF CheckOptionNo <> 0 THEN BEGIN

              FldRef := RecRef.FIELD(Fld."No.");
              IF FldRef.VALUE THEN BEGIN

                IF FirstField THEN BEGIN

                  IF i <> 1 THEN
                    AddDrillDownRecord(TmpUser, FORMAT(i - 1) + '99', '', '', TmpUser."Line Type"::Empty);

                  CASE i OF
                    CheckType::Coding :
                      AddDrillDownRecord(TmpUser, FORMAT(i) + '00', ctCodingChecks, '', TmpUser."Line Type"::Bold);
                    CheckType::Layout :
                      AddDrillDownRecord(TmpUser, FORMAT(i) + '00', ctLayoutChecks, '', TmpUser."Line Type"::Bold);
                    CheckType::Data :
                      AddDrillDownRecord(TmpUser, FORMAT(i) + '00', ctDataChecks, '', TmpUser."Line Type"::Bold);
                    CheckType::Naming :
                      AddDrillDownRecord(TmpUser, FORMAT(i) + '00', ctNamingChecks, '', TmpUser."Line Type"::Bold);
                    CheckType::Captions :
                      AddDrillDownRecord(TmpUser, FORMAT(i) + '00', ctCaptions, '', TmpUser."Line Type"::Bold);
                  END;
                  FirstField := FALSE;
                END;

                AddDrillDownRecord(
                  TmpUser, FORMAT(i) +
                  PADSTR('', 2 - STRLEN(FORMAT(CheckOptionNo)), '0') + FORMAT(CheckOptionNo), Fld."Field Caption",
                  FORMAT(Fld."No."), TmpUser."Line Type"::" ");

                TmpFld2 := Fld;
                IF TmpFld2.FIND('=') THEN BEGIN
                  TmpSelectedUser := TmpUser;
                  TmpSelectedUser.INSERT;
                END;
              END;

            END;
          UNTIL Fld.NEXT = 0;
      END;

      IF Setup."Space after Comma" <> Setup."Space after Comma"::" " THEN BEGIN
        AddDrillDownRecord(TmpUser, '599', '', '', TmpUser."Line Type"::Empty);
        AddDrillDownRecord(TmpUser, '600', ctComma, '', TmpUser."Line Type"::Bold);
        AddDrillDownRecord(TmpUser, '601', Setup.FIELDCAPTION("Space after Comma"), '172', TmpUser."Line Type"::" ");
        TmpFld2."No." := 172;
        IF TmpFld2.FIND('=') THEN BEGIN
          TmpSelectedUser := TmpUser;
          TmpSelectedUser.INSERT;
        END;
      END;

      SelectUsers.SetTmpRecord(TmpUser);
      TmpUser.FINDFIRST;
      SelectUsers.SETRECORD(TmpUser);

      SelectUsers.SetSelectedUser(TmpSelectedUser);

      SelectUsers.SetFormCaption(ctSetOptions);
      SelectUsers.EDITABLE(TRUE);
      SelectUsers.LOOKUPMODE := TRUE;
      IF SelectUsers.RUNMODAL = ACTION::LookupOK THEN BEGIN

        Setup."Critical Guideline Checks" := '';

        TmpSelectedUser.DELETEALL;
        SelectUsers.GetSelectedUser(TmpSelectedUser);
        IF TmpSelectedUser.FINDSET THEN
          REPEAT
            IF EVALUATE(i, TmpSelectedUser.Initials) THEN
              IF Setup."Critical Guideline Checks" = '' THEN
                Setup."Critical Guideline Checks" := FORMAT(i)
              ELSE
                Setup."Critical Guideline Checks" := Setup."Critical Guideline Checks" + '|' + FORMAT(i);
          UNTIL TmpSelectedUser.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE AddDrillDownRecord@71(VAR TmpUser@1000 : TEMPORARY Record 11102056;Code@1001 : Code[20];Name@1002 : Text;Initials@1003 : Code[20];Style@1004 : ' ,Empty,Bold,Grey');
    BEGIN
      TmpUser.Code := Code;
      TmpUser.Name := Name;
      TmpUser.Initials := Initials;
      TmpUser."Line Type" := Style;
      TmpUser.INSERT;
    END;

    LOCAL PROCEDURE NextLineStartWithElse@74(VAR CALHistoryLine@1000 : Record 11102053) ExitValue : Boolean;
    VAR
      OrigCALHistoryLine@1001 : Record 11102053;
      CodeLine@1002 : Text;
      StopLoop@1003 : Boolean;
    BEGIN
      OrigCALHistoryLine := CALHistoryLine;
      CALHistoryLine.SETRANGE("Sub Line No.", 1);

      IF CALHistoryLine.NEXT <> 0 THEN
        REPEAT
          CodeLine := DELCHR(CALHistoryLine.Code);
          IF (CodeLine <> '') AND
             (DELSTR(CodeLine, 3) <> '//') AND
             (DELSTR(CodeLine, 2) <> '{')
          THEN BEGIN
            ExitValue := DELSTR(CodeLine, 5) = 'ELSE';
            StopLoop := TRUE;
          END;

          IF NOT StopLoop THEN
            StopLoop := CALHistoryLine.NEXT = 0;
        UNTIL StopLoop;

      CALHistoryLine.SETRANGE("Sub Line No.");
      CALHistoryLine := OrigCALHistoryLine;
    END;

    LOCAL PROCEDURE DefaultProperty@75(ObjectType2@1000 : Text;PropertyType@1001 : Text;Name@1002 : Text) : Text;
    BEGIN
      CASE PropertyType OF
        'Table' :
          CASE Name OF
            'DataPerCompany' : EXIT('Yes');
            'PasteIsValid' : EXIT('Yes');
            'LinkedObject' : EXIT('No');
          END;

        'Report' :
          CASE Name OF
            'ShowPrintStatus' : EXIT('Yes');
            'UseReqForm' : EXIT('Yes');
            'UseSystemPrinter' : EXIT('No');
            'ProcessingOnly' : EXIT('No');
            'EnableExternalImages' : EXIT('No');
            'EnableHyperlinks' : EXIT('No');
            'EnableExternalAssemblies' : EXIT('No');
            'TransactionType' : EXIT('UpdateNoLocks');
            'TopMargin' : EXIT('2000');
            'BottomMargin' : EXIT('2000');
            'LeftMargin' : EXIT('2100');
            'RightMargin' : EXIT('0');
            'HorzGrid' : EXIT('150');
            'VertGrid' : EXIT('423');
          END;

        'Page' :
          CASE Name OF
            'Editable' : EXIT('Yes');
            'PageType' : EXIT('Card');
            'RefreshOnActivate' : EXIT('No');
            'InsertAllowed' : EXIT('Yes');
            'ModifyAllowed' : EXIT('Yes');
            'DelayedInsert' : EXIT('No');
            'MultipleNewLines' : EXIT('No');
            'SaveValues' : EXIT('No');
            'AutoSplitKey' : EXIT('No');
            'SourceTableTemporary' : EXIT('No');
            'LinksAllowed' : EXIT('Yes');
          END;

        'Field' :
          CASE Name OF
            'Enabled' : EXIT('Yes');
            'FieldClass' : EXIT('Normal');
            'BlankNumbers' : EXIT('DontBlank');
            'BlankZero' : EXIT('No');
            'SignDisplacement' : EXIT('0');
            'AutoFormatType' : EXIT('0');
            'Editable' : EXIT('Yes');
            'NotBlank' : EXIT('No');
            'AutoIncrement' : EXIT('No');
            'Numeric' : EXIT('No');
            'DateFormula' : EXIT('No');
            'ValidateTableRelation' : EXIT('Yes');
            'TestTableRelation' : EXIT('Yes');
            'ExtendedDatatype' : EXIT('None');
          END;

        'Control' :
          CASE Name OF
            'Visible' : EXIT('TRUE');
            'Enabled' : EXIT('TRUE');
            'Editable' : EXIT('TRUE');
            'HideValue' : EXIT('FALSE');
            'ShowCaption' : EXIT('Yes');
            'MultiLine' : EXIT('No');
            'Title' : EXIT('No');
            'BlankNumbers' : EXIT('DontBlank');
            'NotBlank' : EXIT('No');
            'BlankZero' : EXIT('No');
            'QuickEntry' : EXIT('TRUE');
            'Importance' : EXIT('Standard');
            'ClosingDates' : EXIT('No');
            'Numeric' : EXIT('No');
            'DateFormula' : EXIT('No');
            'Style' : EXIT('None');
            'StyleExpr' : EXIT('None');
            'ExtendedDatatype' : EXIT('None');
          END;

        'Action' :
          CASE Name OF
            'Visible' : EXIT('TRUE');
            'Enabled' : EXIT('TRUE');
            'RunPageMode' : EXIT('Edit');
            'Promoted' : EXIT('No');
            'PromotedCategory' : EXIT('New');
            'PromotedIsBig' : EXIT('No');
            'Scope' : EXIT('Page');
            'Ellipsis' : EXIT('No');
            'RunPageOnRec' : EXIT('No');
            'InFooterBar' : EXIT('No');
          END;

      END;
    END;

    PROCEDURE ExportKnownComments@77(FileName@1000 : Text);
    VAR
      CheckGuidelinesComment@1001 : Record 11102081;
      oFile@1002 : File;
      Tab@1003 : Char;
    BEGIN
      oFile.TEXTMODE(TRUE);
      oFile.CREATE(FileName);

      Tab := 9;

      WITH CheckGuidelinesComment DO BEGIN
        SETRANGE("Known Comment", TRUE);
        IF FINDSET THEN
          REPEAT
            oFile.WRITE(
              FORMAT("Object Type" + 0) + FORMAT(Tab) +
              FORMAT("Object No.") + FORMAT(Tab) +
              FORMAT("Comment No.") + FORMAT(Tab) +
              FORMAT(Identifier) + FORMAT(Tab));
          UNTIL NEXT = 0;
      END;
      oFile.CLOSE;
    END;

    PROCEDURE ImportKnownComments@78(FileName@1000 : Text);
    VAR
      CheckGuidelinesComment@1001 : Record 11102081;
      Mgt@1002 : Codeunit 11102035;
      oFile@1003 : File;
      SplitTextLine@1004 : ARRAY [100] OF Text[1024];
      Tab@1005 : Text;
      TextLine@1006 : Text;
      ReadChar@1007 : Char;
    BEGIN
      oFile.TEXTMODE(FALSE);
      oFile.OPEN(FileName);

      Tab[1] := 9;

      WHILE oFile.READ(ReadChar) > 0 DO
        CASE ReadChar OF
          13, 10 :

            IF TextLine <> '' THEN BEGIN

              Mgt.Split(TextLine, Tab, SplitTextLine);

              WITH CheckGuidelinesComment DO BEGIN

                RESET;

                SETCURRENTKEY("Object Type", "Object No.", "Comment No.", Identifier);
                EVALUATE("Object Type", SplitTextLine[1]);
                EVALUATE("Object No.", SplitTextLine[2]);
                EVALUATE("Comment No.", SplitTextLine[3]);
                EVALUATE(Identifier, SplitTextLine[4]);
                SETRANGE("Object Type", "Object Type");
                SETRANGE("Object No.", "Object No.");
                SETRANGE("Comment No.", "Comment No.");
                SETRANGE(Identifier, Identifier);
                SETRANGE("Known Comment", FALSE);
                MODIFYALL("Known Comment", TRUE);

              END;

              TextLine := '';
            END;

          ELSE
            TextLine += FORMAT(ReadChar);
        END;

      oFile.CLOSE;
    END;

    PROCEDURE SetKnownCommentWithCALHistory@79(VAR Object@1000 : Record 2000000001;HistoryType@1001 : ' ,Date,No. of Days,Begin of Project';HistoryDate@1002 : Date;ProjectNo@1003 : Code[20]);
    VAR
      Modification@1004 : Record 11102042;
      CALHistoryObject@1005 : Record 11102052;
      CALHistoryLine@1006 : Record 11102053;
      TmpCALHistoryLine@1007 : TEMPORARY Record 11102053;
      CheckGuidelinesComment@1008 : Record 11102081;
      TmpCheckGuidelinesComment@1009 : TEMPORARY Record 11102081;
      Progressbar@1010 : Codeunit 11102044;
      HistoryDate2@1011 : Date;
      ctSettingKnownComments@1012 : TextConst 'DEU=Setting known comments...;ENU=Setting known comments...;ESP=Setting known comments...;FRA=Setting known comments...;NLD=Bekende opmerkingen markeren...;DEA=Setting known comments...';
    BEGIN
      Initialize;

      Progressbar.Open(ctSettingKnownComments, 1);

      Progressbar.BarSize := Object.COUNT * 2;

      IF Object.FINDSET THEN
        REPEAT

          Progressbar.AddToBar(1);

          Progressbar.Text1Object := Object;

          AnalyseAndSaveObject(Object);

          Progressbar.AddToBar(1);

          HistoryDate2 := HistoryDate;
          IF HistoryType = HistoryType::"Begin of Project" THEN BEGIN
            Modification.SETCURRENTKEY("Assigned to Project No.", "Object Type", "Object No.", "Object Date", "Object Time");
            Modification.SETRANGE("Assigned to Project No.", ProjectNo);
            Modification.SETRANGE("Object Type", Object.Type);
            Modification.SETRANGE("Object No.", Object.ID);
            IF Modification.FINDFIRST THEN
              HistoryDate2 := Modification."Object Date";
          END;

          CALHistoryObject.SETCURRENTKEY("Object Type", "Object No.", "Object Date", "Object Time");
          CALHistoryObject.SETRANGE("Object Type", Object.Type);
          CALHistoryObject.SETRANGE("Object No.", Object.ID);
          CALHistoryObject.SETFILTER("Object Date", '<%1', HistoryDate2);
          CALHistoryObject.SETRANGE("C/AL Code Present", TRUE);
          IF CALHistoryObject.FINDLAST THEN BEGIN

            TmpCALHistoryLine.RESET;
            TmpCALHistoryLine.DELETEALL;

            TmpCheckGuidelinesComment.RESET;
            TmpCheckGuidelinesComment.DELETEALL;

            CALHistoryLine.SETRANGE("Entry No.", CALHistoryObject."Entry No.");
            IF CALHistoryLine.FINDSET THEN
              REPEAT
                TmpCALHistoryLine := CALHistoryLine;
                TmpCALHistoryLine."Entry No." := 0;
                TmpCALHistoryLine.INSERT;
              UNTIL CALHistoryLine.NEXT = 0;

            AnalyseObject(Object, TmpCALHistoryLine, TmpCheckGuidelinesComment);
            TmpCheckGuidelinesComment.RESET;
            IF TmpCheckGuidelinesComment.FINDSET THEN
              REPEAT

                CheckGuidelinesComment.SETCURRENTKEY("Object Type", "Object No.", "Comment No.", Identifier);
                CheckGuidelinesComment.SETRANGE("Object Type", Object.Type);
                CheckGuidelinesComment.SETRANGE("Object No.", Object.ID);
                CheckGuidelinesComment.SETRANGE("Comment No.", TmpCheckGuidelinesComment."Comment No.");
                CheckGuidelinesComment.SETRANGE(Identifier, TmpCheckGuidelinesComment.Identifier);
                CheckGuidelinesComment.SETRANGE("Known Comment", FALSE);
                CheckGuidelinesComment.MODIFYALL("Known Comment", TRUE);

              UNTIL TmpCheckGuidelinesComment.NEXT = 0;

          END;

        UNTIL Object.NEXT = 0;

      Progressbar.Close;
    END;

    PROCEDURE SetProjectObjects@80(VAR ProjectObject@1000 : Record 11102037);
    BEGIN
      IF ProjectObject.FINDSET THEN
        REPEAT
          TmpProjectObject := ProjectObject;
          TmpProjectObject.INSERT;
        UNTIL ProjectObject.NEXT = 0;
    END;

    PROCEDURE AddObjectsToSheet@81(VAR Object@1000 : Record 2000000001);
    VAR
      CheckGuidelinesObject@1001 : Record 11102080;
    BEGIN
      IF Object.FINDSET THEN
        REPEAT
          IF NOT CheckGuidelinesObject.GET(Object.Type, Object.ID) THEN BEGIN
            CheckGuidelinesObject."Object Type" := Object.Type;
            CheckGuidelinesObject."Object No." := Object.ID;
            CheckGuidelinesObject.INSERT;
          END;
        UNTIL Object.NEXT = 0;
    END;

    LOCAL PROCEDURE GetSourceTableOfObject@82(ObjectType2@1000 : Integer;ObjectNo@1001 : Integer) ExitValue : Integer;
    VAR
      CALHistoryObject@1002 : Record 11102052;
      CALHistoryLine@1003 : Record 11102053;
    BEGIN
      IF CALHistoryObject.TryGoToLastRecord(ObjectType2, ObjectNo) THEN BEGIN
        CALHistoryLine.SETRANGE("Entry No.", CALHistoryObject."Entry No.");
        CALHistoryLine.SETRANGE("Sub Line No.", 1);
        CALHistoryLine.SETFILTER(Code, '''    SourceTable=*''');
        IF CALHistoryLine.FINDFIRST THEN
          IF EVALUATE(ExitValue, DELCHR(COPYSTR(CALHistoryLine.Code, 22), '>', ';')) THEN
            ;
      END;
    END;

    LOCAL PROCEDURE AnalyseTableView@83(VAR Comment@1000 : Record 11102081;CALLineNo@1001 : Integer;Identifier@1002 : Code[100];VAR Expression@1003 : Text;VAR TableNo@1004 : Integer;WithFieldNo@1005 : Boolean);
    VAR
      Fld@1006 : Record 2000000041;
      Mgt@1007 : Codeunit 11102035;
      KeyFieldString@1008 : Text;
      SortingString@1009 : Text;
      KeyField@1010 : ARRAY [100] OF Integer;
      NoOfKeyFields@1011 : Integer;
      OrderPos@1012 : Integer;
      Position@1013 : Integer;
      WherePos@1014 : Integer;
      ctNotExistingKey@1015 : TextConst 'DEU=Not Existing Key;ENU=Not Existing Key;ESP=Not Existing Key;FRA=Not Existing Key;NLD=Sleutel bestaan niet;DEA=Not Existing Key';
    BEGIN
      Expression := LOWERCASE(Expression);

      IF STRPOS(Expression, 'order') > 0 THEN BEGIN

        OrderPos := STRPOS(Expression, ')order(');
        IF OrderPos > 0 THEN
          Expression := INSSTR(Expression, ' ', OrderPos + 1);

        OrderPos := STRPOS(Expression, ' order (');
        IF OrderPos > 0 THEN
          Expression := DELSTR(Expression, OrderPos + 6, 1);

        OrderPos := STRPOS(Expression, ' order(');
      END;

      IF STRPOS(Expression, 'where') > 0 THEN BEGIN
        WherePos := STRPOS(Expression, ')where(');
        IF WherePos > 0 THEN
          Expression := INSSTR(Expression, ' ', WherePos + 1);

        WherePos := STRPOS(Expression, ' where (');
        IF WherePos > 0 THEN
          Expression := DELSTR(Expression, WherePos + 6, 1);

        WherePos := STRPOS(Expression, ' where(');
      END;

      IF Expression[1] = 's' THEN BEGIN
        CASE TRUE OF
          OrderPos > 0 :
            SortingString := COPYSTR(Expression, 9, OrderPos - 10);
          WherePos > 0 :
            SortingString := COPYSTR(Expression, 9, WherePos - 10);
          ELSE
            SortingString := COPYSTR(Expression, 9, STRLEN(Expression) - 9);
        END;
        Position := 1;
        WHILE NextValue(SortingString, Position, ',', '"', '"', KeyFieldString) DO BEGIN
          Fld.SETRANGE(TableNo, TableNo);
          IF WithFieldNo THEN
            ReplaceFieldNo(KeyFieldString, TableNo);
          Fld.SETFILTER(FieldName, Mgt.CreateFieldFilter(KeyFieldString, TRUE));
          IF Fld.FINDFIRST THEN BEGIN
            NoOfKeyFields += 1;
            KeyField[NoOfKeyFields] := Fld."No.";
          END;
        END;
        IF NoOfKeyFields > 0 THEN
          IF NOT KeyExist(TableNo, KeyField) THEN
            AddLayoutComment(Comment, LayoutCheck::"Check Keys", ctNotExistingKey, CALLineNo, Identifier);
      END;
    END;

    LOCAL PROCEDURE ReplaceFieldNo@84(VAR FieldName2@1000 : Text;TableNo@1001 : Integer);
    VAR
      Field@1002 : Record 2000000041;
      FieldNo2@1003 : Integer;
    BEGIN
      IF STRLEN(FieldName2) > 5 THEN
        IF EVALUATE(FieldNo2, COPYSTR(FieldName2, 6)) THEN BEGIN
          Field.SETRANGE(TableNo, TableNo);
          Field.SETRANGE("No.", FieldNo2);
          IF Field.FINDFIRST THEN
            FieldName2 := Field.FieldName;
        END;
    END;

    LOCAL PROCEDURE KeyExist@85(TableNo@1000 : Integer;VAR FieldArray@1001 : ARRAY [100] OF Integer) : Boolean;
    VAR
      RecRef@1002 : RecordRef;
      FldRef@1003 : FieldRef;
      KeyRef@1004 : KeyRef;
      i@1005 : Integer;
      j@1006 : Integer;
      FieldsAreTheSame@1007 : Boolean;
    BEGIN
      RecRef.OPEN(TableNo);
      FOR i := 1 TO RecRef.KEYCOUNT DO BEGIN
        KeyRef := RecRef.KEYINDEX(i);
        IF KeyRef.ACTIVE THEN BEGIN
          FieldsAreTheSame := TRUE;
          FOR j := 1 TO KeyRef.FIELDCOUNT DO BEGIN
            FldRef := KeyRef.FIELDINDEX(j);
            IF NOT (FieldArray[j] IN [FldRef.NUMBER, 0]) THEN
              FieldsAreTheSame := FALSE;
          END;
          IF FieldsAreTheSame THEN
            EXIT(TRUE);
        END;
      END;
    END;

    LOCAL PROCEDURE AnalyseSetCurrentKey@86(VAR Comment@1000 : Record 11102081;VAR CALHistoryLine@1001 : Record 11102053;Identifier@1002 : Code[100];VAR VariableBuffer@1003 : TEMPORARY Record 11102062;TableNo@1004 : Integer;IndentRecName@1005 : Text);
    VAR
      PrevCALHistoryLine@1006 : Record 11102053;
      Fld@1007 : Record 2000000041;
      Mgt@1008 : Codeunit 11102035;
      CodeLine@1009 : Text;
      FieldsString@1010 : Text;
      KeyFieldString@1011 : Text;
      RecordString@1012 : Text;
      KeyField@1013 : ARRAY [100] OF Integer;
      LineCounter@1014 : Integer;
      NoOfKeyFields@1015 : Integer;
      Position@1016 : Integer;
      SetCurrentKeyPos@1017 : Integer;
      StopLoop@1018 : Boolean;
      ctNotExistingKey@1019 : TextConst 'DEU=Not Existing Key;ENU=Not Existing Key;ESP=Not Existing Key;FRA=Not Existing Key;NLD=Sleutel bestaan niet;DEA=Not Existing Key';
    BEGIN
      PrevCALHistoryLine := CALHistoryLine;
      REPEAT
        CodeLine += DELCHR(CALHistoryLine.Code, '<>');

        IF STRPOS(CodeLine, '//') > 0 THEN
          CodeLine := DELCHR(DELSTR(CodeLine, STRPOS(CodeLine, '//')), '<>');

        StopLoop := CodeLine[STRLEN(CodeLine)] IN [';', ')'];
        IF NOT StopLoop THEN
          StopLoop := CALHistoryLine.NEXT = 0;
        LineCounter += 1;
      UNTIL StopLoop OR (LineCounter = 10);
      CALHistoryLine := PrevCALHistoryLine;

      SetCurrentKeyPos := STRPOS(CodeLine, 'SETCURRENTKEY(');
      IF SetCurrentKeyPos = 0 THEN
        EXIT;

      RecordString := DELSTR(CodeLine, SetCurrentKeyPos);
      IF DELSTR(RecordString, 4) = 'IF ' THEN
        EXIT;

      IF RecordString <> '' THEN
        RecordString := DELSTR(RecordString, STRLEN(RecordString))
      ELSE
        RecordString := IndentRecName;

      IF STRPOS(RecordString, '[') > 0 THEN
        RecordString := DELSTR(RecordString, STRPOS(RecordString, '['));

      FieldsString := COPYSTR(CodeLine, SetCurrentKeyPos + 13);
      FieldsString := DELCHR(FieldsString, '<>', '(); ');

      IF RecordString <> '' THEN BEGIN
        VariableBuffer.SETFILTER(Name, Mgt.CreateFilter(RecordString, TRUE));
        IF VariableBuffer.FINDFIRST THEN
          IF (VariableBuffer."Object Type" = VariableBuffer."Object Type"::Table) AND
             (VariableBuffer."Object No." <> 0)
          THEN
            TableNo := VariableBuffer."Object No.";
      END;

      IF TableNo = 0 THEN
        EXIT;

      Position := 1;
      WHILE NextField(FieldsString, Position, KeyFieldString) DO BEGIN
        Fld.SETRANGE(TableNo, TableNo);
        IF STRLEN(KeyFieldString) > 32 THEN
          KeyFieldString := '';
        IF KeyFieldString <> '' THEN BEGIN
          Fld.SETFILTER(FieldName, Mgt.CreateFieldFilter(KeyFieldString, TRUE));
          IF Fld.FINDFIRST THEN BEGIN
            NoOfKeyFields += 1;
            KeyField[NoOfKeyFields] := Fld."No.";
          END;
        END;
      END;

      IF NoOfKeyFields > 0 THEN
        IF NOT KeyExist(TableNo, KeyField) THEN
          AddCodingComment(Comment, CodingCheck::SetCurrentKey, ctNotExistingKey, CALHistoryLine."Line No.", 0, 0, Identifier);
    END;

    LOCAL PROCEDURE AnalyseCalcDate@87(VAR Comment@1000 : Record 11102081;VAR CALHistoryLine@1001 : Record 11102053;Identifier@1002 : Code[100]);
    VAR
      CodeLine@1003 : Text;
      Formula@1004 : Text;
      ClosePos@1005 : Integer;
      OpenPos@1006 : Integer;
      ctAddBrackets@1007 : TextConst 'DEU=Add ''<>'' to CALCDATE;ENU=Add ''<>'' to CALCDATE;ESP=Add ''<>'' to CALCDATE;FRA=Add ''<>'' to CALCDATE;NLD=Voeg ''<>'' toe aan CALCDATE;DEA=Add ''<>'' to CALCDATE';
    BEGIN
      CodeLine := CALHistoryLine.Code;
      CodeLine := COPYSTR(CodeLine, STRPOS(CodeLine, 'CALCDATE'));

      OpenPos := STRPOS(CodeLine, '(');
      ClosePos := STRPOS(CodeLine, ')');
      IF (OpenPos > 0) AND (OpenPos < ClosePos) THEN BEGIN
        Formula := COPYSTR(CodeLine, OpenPos + 1, ClosePos - OpenPos - 1);
        IF (STRPOS(Formula, '''') > 0) AND (STRPOS(Formula, '%') = 0) THEN
          IF (STRPOS(Formula, '''<') = 0) OR (STRPOS(Formula, '>''') = 0) THEN
            AddCodingComment(Comment, CodingCheck::CALCDATE, ctAddBrackets, CALHistoryLine."Line No.", 0, 0, Identifier);
      END;
    END;

    LOCAL PROCEDURE AnalyseMark@88(VAR Comment@1000 : Record 11102081;VAR CALHistoryLine@1001 : Record 11102053;Identifier@1002 : Code[100]);
    VAR
      ctMark@1003 : TextConst 'DEU=Use temporary record instead of marking;ENU=Use temporary record instead of marking;ESP=Use temporary record instead of marking;FRA=Use temporary record instead of marking;NLD=Gebruik tijdelijke records in plaats van markeren;DEA=Use temporary record instead of marking';
    BEGIN
      IF (STRPOS(CALHistoryLine.Code, '.MARK') = 0) AND (STRPOS(CALHistoryLine.Code, ' MARK') = 0) THEN
        EXIT;

      IF (STRPOS(CALHistoryLine.Code, 'MARK(') = 0) AND
         (STRPOS(CALHistoryLine.Code, 'MARK;') = 0) AND
         (STRPOS(CALHistoryLine.Code, 'MARK ') = 0)
      THEN
        EXIT;

      AddCodingComment(Comment, CodingCheck::MARK, ctMark, CALHistoryLine."Line No.", 0, 0, Identifier);
    END;

    LOCAL PROCEDURE AnalyseIntegerInRun@89(VAR Comment@1000 : Record 11102081;VAR CALHistoryLine@1001 : Record 11102053;Identifier@1002 : Code[100]);
    VAR
      Object@1003 : Record 2000000001;
      CommentString@1004 : Text;
      IntegerString@1005 : Text;
      i@1006 : Integer;
      ObjectNo@1007 : Integer;
      Pos@1008 : Integer;
      ctReplaceInteger@1009 : TextConst 'DEU=Replace integer with %1::"%2";ENU=Replace integer with %1::"%2";ESP=Replace integer with %1::"%2";FRA=Replace integer with %1::"%2";NLD=Vervange integer met %1::"%2";DEA=Replace integer with %1::"%2"';
    BEGIN
      FOR i := 1 TO ARRAYLEN(CheckRunIntegerString) DO BEGIN
        Pos := STRPOS(CALHistoryLine.Code, CheckRunIntegerString[i] + '(');
        IF Pos > 0 THEN BEGIN
          IntegerString := COPYSTR(CALHistoryLine.Code, Pos + STRLEN(CheckRunIntegerString[i]) + 1);
          IF STRPOS(IntegerString, ')') > 0 THEN
            IntegerString := DELSTR(IntegerString, STRPOS(IntegerString, ')'));
          IF EVALUATE(ObjectNo, IntegerString) THEN BEGIN
            Pos := STRPOS(CheckRunIntegerString[i], '.');
            EVALUATE(Object.Type, DELSTR(CheckRunIntegerString[i], Pos));
            IF Object.GET(Object.Type, '', ObjectNo) THEN
              CommentString := STRSUBSTNO(ctReplaceInteger, UPPERCASE(FORMAT(Object.Type)), Object.Name)
            ELSE
              CommentString := STRSUBSTNO(ctReplaceInteger, UPPERCASE(FORMAT(Object.Type)), 'Object Name');

            AddCodingComment(Comment, CodingCheck::"RUN Integer", CommentString, CALHistoryLine."Line No.", 0, 0, Identifier);
          END;
        END;
      END;
    END;

    LOCAL PROCEDURE GetTableByName@129(VAR AllObj@1000 : Record 2000000038;Name@1001 : Text;RemoveQuotes@1002 : Boolean) : Boolean;
    VAR
      Mgt@1003 : Codeunit 11102035;
    BEGIN
      EXIT(Mgt.GetTableByName(AllObj, Mgt.CreateFilter(Name, RemoveQuotes)));
    END;

    LOCAL PROCEDURE AnalyseAssignment@111(VAR Comment@1000 : Record 11102081;VAR CALHistoryLine@1001 : Record 11102053;Identifier@1002 : Code[100];VAR VariableBuffer@1003 : TEMPORARY Record 11102062;TableNo@1004 : Integer;IndentRecName@1005 : Text);
    VAR
      FirstField@1006 : Record 2000000041;
      SecondField@1007 : Record 2000000041;
      FirstFieldName@1008 : Text;
      FirstTableName@1009 : Text;
      SecondFieldName@1010 : Text;
      SecondTableName@1011 : Text;
      AssignmentPos@1012 : Integer;
    BEGIN
      AssignmentPos := STRPOS(CALHistoryLine.Code, ':=');
      IF AssignmentPos = 0 THEN
        EXIT;

      IF NOT GetTableFieldName(COPYSTR(CALHistoryLine.Code, 1, AssignmentPos - 1), FirstFieldName, FirstTableName) THEN
        EXIT;

      IF NOT GetTableFieldName(COPYSTR(CALHistoryLine.Code, AssignmentPos + 3), SecondFieldName, SecondTableName) THEN
        EXIT;

      IF NOT IsTableField(FirstFieldName, FirstTableName, FirstField, VariableBuffer, TableNo, IndentRecName) THEN
        EXIT;

      IF NOT IsTableField(SecondFieldName, SecondTableName, SecondField, VariableBuffer, TableNo, IndentRecName) THEN
        EXIT;

      IF CheckDataOption[DataCheck::"Missing Relations"] THEN
        CheckMissingRelation(Comment, CALHistoryLine, FirstField, SecondField, Identifier);

      IF CheckDataOption[DataCheck::Assignments] THEN
        CheckAssignment(Comment, CALHistoryLine, FirstField, SecondField, Identifier);
    END;

    LOCAL PROCEDURE GetTableFieldName@109(Code@1000 : Text;VAR FirstName@1001 : Text;VAR SecondName@1002 : Text) : Boolean;
    VAR
      Mgt@1003 : Codeunit 11102035;
      i@1004 : Integer;
      ActiveName@1005 : ' ,First,Second';
      AddChar@1006 : Boolean;
      NameOpen@1007 : Boolean;
    BEGIN
      FirstName := '';
      SecondName := '';

      Code := DELCHR(Code, '<>');

      FOR i := 1 TO STRLEN(Code) DO BEGIN
        AddChar := FALSE;
        CASE TRUE OF

          NameOpen :
            IF Code[i] = '"' THEN

              IF Code[i + 1] = '"' THEN BEGIN
                i += 1;
                AddChar := TRUE;
              END ELSE
                NameOpen := FALSE
            ELSE
              AddChar := TRUE;

          Code[i] IN ['{', ''''] :
            EXIT;

          Code[i] = '.' :
            ActiveName := ActiveName::Second;

          Code[i] = '"' :
            BEGIN
              NameOpen := TRUE;
              IF ActiveName = ActiveName::" " THEN
                ActiveName := ActiveName::First;
            END;

          Mgt.SpecialCharacter(Code[i]) :
            i := STRLEN(Code);

          ELSE
            AddChar := TRUE;

        END;
        IF AddChar THEN
          CASE ActiveName OF

            ActiveName::" " :
              BEGIN
                ActiveName := ActiveName::First;
                FirstName := FirstName + FORMAT(Code[i]);
              END;

            ActiveName::First :
              FirstName := FirstName + FORMAT(Code[i]);

            ActiveName::Second :
              SecondName := SecondName + FORMAT(Code[i]);
          END;

      END;

      EXIT(FirstName <> '');
    END;

    LOCAL PROCEDURE IsTableField@112(VAR FirstName@1000 : Text;VAR SecondName@1001 : Text;VAR Field@1002 : Record 2000000041;VAR VariableBuffer@1003 : TEMPORARY Record 11102062;VAR TableNo@1004 : Integer;VAR IndentRecName@1005 : Text) : Boolean;
    BEGIN
      IF STRLEN(FirstName) > MAXSTRLEN(Field.FieldName) THEN
        EXIT;

      IF SecondName <> '' THEN
        EXIT(GetFromVariableBuffer(VariableBuffer, FirstName, SecondName, Field));

      IF IndentRecName <> '' THEN
        IF GetFromVariableBuffer(VariableBuffer, IndentRecName, FirstName, Field) THEN
          EXIT(TRUE);

      Field.SETRANGE(TableNo, TableNo);
      Field.SETRANGE(FieldName, FirstName);

      EXIT(Field.FINDFIRST);
    END;

    LOCAL PROCEDURE GetFromVariableBuffer@110(VAR VariableBuffer@1000 : TEMPORARY Record 11102062;VAR FirstName@1001 : Text;VAR SecondName@1002 : Text;VAR Field@1003 : Record 2000000041) : Boolean;
    BEGIN
      VariableBuffer.RESET;
      VariableBuffer.SETRANGE(Name, FirstName);
      IF NOT VariableBuffer.FINDFIRST THEN
        EXIT;
      IF VariableBuffer."Object Type" <> VariableBuffer."Object Type"::Table THEN
        EXIT;
      Field.SETRANGE(TableNo, VariableBuffer."Object No.");
      Field.SETRANGE(FieldName, SecondName);
      EXIT(Field.FINDFIRST);
    END;

    LOCAL PROCEDURE CheckMissingRelation@113(VAR Comment@1000 : Record 11102081;VAR CALHistoryLine@1001 : Record 11102053;VAR FirstField@1002 : Record 2000000041;VAR SecondField@1003 : Record 2000000041;VAR Identifier@1004 : Code[100]);
    VAR
      Relation@1005 : Record 11102078;
      RecRef@1006 : RecordRef;
      FldRef@1007 : FieldRef;
      KeyRef@1008 : KeyRef;
      ctMissingRelation@1009 : TextConst 'DEU="Relation is missing ";ENU="Relation is missing ";ESP="Relation is missing ";FRA="Relation is missing ";NLD=Ontbrekende relatie;DEA="Relation is missing "';
    BEGIN
      RecRef.OPEN(SecondField.TableNo);
      KeyRef := RecRef.KEYINDEX(1);
      IF KeyRef.FIELDCOUNT <> 1 THEN
        EXIT;

      FldRef := KeyRef.FIELDINDEX(1);
      IF FldRef.NUMBER <> SecondField."No." THEN
        EXIT;

      IF (FirstField.TableNo = SecondField.TableNo) AND
         (FirstField."No." = SecondField."No.")
      THEN
        EXIT;

      IF (FirstField.RelationTableNo = SecondField.TableNo) AND
         (FirstField.RelationFieldNo IN [SecondField."No.", 0])
      THEN
        EXIT;

      Relation.SETCURRENTKEY("Object Type", "Table No.", "Relation Table No.", "Field No.", "Relation Field No.");
      Relation.SETRANGE("Object Type", Relation."Object Type"::Table);
      Relation.SETRANGE("Table No.", FirstField.TableNo);
      Relation.SETRANGE("Field No.", FirstField."No.");
      Relation.SETRANGE("Relation Table No.", SecondField.TableNo);
      Relation.SETRANGE("Relation Field No.", SecondField."No.");
      IF NOT Relation.ISEMPTY THEN
        EXIT;

      AddDataComment(Comment, DataCheck::"Missing Relations", ctMissingRelation, CALHistoryLine."Line No.", Identifier);
    END;

    LOCAL PROCEDURE CheckAssignment@114(VAR Comment@1000 : Record 11102081;VAR CALHistoryLine@1001 : Record 11102053;VAR FirstField@1002 : Record 2000000041;VAR SecondField@1003 : Record 2000000041;VAR Identifier@1004 : Code[100]);
    VAR
      ctWrongAssignment@1005 : TextConst 'DEU="This assignment can cause an overflow. %1%2 := %3%4";ENU="This assignment can cause an overflow. %1%2 := %3%4";ESP="This assignment can cause an overflow. %1%2 := %3%4";FRA="This assignment can cause an overflow. %1%2 := %3%4";NLD="Deze toewijzing kan een overflow veroorzaken. %1%2 := %3%4";DEA="This assignment can cause an overflow. %1%2 := %3%4"';
    BEGIN
      IF (FirstField.Type IN [FirstField.Type::Code, FirstField.Type::Text]) AND
         (SecondField.Type IN [SecondField.Type::Code, SecondField.Type::Text]) AND
         (FirstField.Len < SecondField.Len)
      THEN
        AddDataComment(
          Comment, DataCheck::Assignments,
          STRSUBSTNO(ctWrongAssignment, FirstField.Type, FirstField.Len, SecondField.Type, SecondField.Len),
          CALHistoryLine."Line No.", Identifier);
    END;

    LOCAL PROCEDURE SplitFieldType@116(VAR FieldType@1000 : Text;VAR FieldTypeName@1001 : Text;VAR FieldLength@1002 : Integer);
    VAR
      FieldLengthString@1003 : Text;
      i@1004 : Integer;
    BEGIN
      FOR i := 1 TO STRLEN(FieldType) DO
        IF FieldType[i] IN ['0'..'9'] THEN
          FieldLengthString := FieldLengthString + FORMAT(FieldType[i])
        ELSE
          FieldTypeName := FieldTypeName + FORMAT(FieldType[i]);
      IF EVALUATE(FieldLength, FieldLengthString) THEN
        ;
    END;

    LOCAL PROCEDURE CheckTestFields@115(VAR Comment@1000 : Record 11102081;VAR CALHistoryLine@1001 : Record 11102053;VAR FieldBuffer@1002 : Record 11102082;VAR TestKeyFieldName@1003 : Text);
    VAR
      Mgt@1004 : Codeunit 11102035;
      OnInsertSection@1005 : Integer;
      PropertySection@1006 : Integer;
      TestFieldPresent@1007 : Boolean;
      ctAddTestfield@1008 : TextConst 'DEU="Add TESTFIELD(%1);";ENU="Add TESTFIELD(%1);";ESP="Add TESTFIELD(%1);";FRA="Add TESTFIELD(%1);";NLD="Voeg TESTFIELD(%1); toe";DEA="Add TESTFIELD(%1);"';
      EscapedTestKeyFieldName@1009 : Text;
    BEGIN
      IF TestKeyFieldName = '' THEN
        EXIT;

      IF SetRangeOnSection(CALHistoryLine, 'PROPERTIES') THEN BEGIN

        CALHistoryLine.SETRANGE("Sub Line No.", 1);
        IF CALHistoryLine.FINDFIRST THEN
          PropertySection := CALHistoryLine."Line No.";

        CALHistoryLine.SETFILTER(Code, '%1', '    OnInsert=*');

        EscapedTestKeyFieldName := LOWERCASE(Mgt.AddQuotes(TestKeyFieldName));

        IF CALHistoryLine.FINDFIRST THEN BEGIN
          OnInsertSection := CALHistoryLine."Line No.";
          CALHistoryLine.SETRANGE(Code);
          REPEAT
            IF STRPOS(LOWERCASE(CALHistoryLine.Code), 'testfield(' + EscapedTestKeyFieldName + ');') > 0 THEN
              TestFieldPresent := TRUE;
          UNTIL (CALHistoryLine.NEXT = 0) OR
                ((CALHistoryLine.Code[5] <> ' ') AND (STRLEN(CALHistoryLine.Code) > 4));

          IF NOT TestFieldPresent THEN
            AddDataComment(
              Comment, DataCheck::Testfield, STRSUBSTNO(ctAddTestfield, EscapedTestKeyFieldName),
              OnInsertSection, FieldBuffer.Identifier);

        END ELSE
          AddDataComment(
            Comment, DataCheck::Testfield, STRSUBSTNO(ctAddTestfield, EscapedTestKeyFieldName),
            PropertySection - 2, FieldBuffer.Identifier);

      END;
    END;

    LOCAL PROCEDURE CheckDeleteRelatingTables@117(VAR Object@1000 : Record 2000000001;VAR Comment@1001 : Record 11102081;VAR CALHistoryLine@1002 : Record 11102053;VAR VariableBuffer@1003 : Record 11102062);
    VAR
      Object2@1010 : Record 2000000001;
      TmpSubTable@1004 : TEMPORARY Record 2000000001;
      Mgt@1005 : Codeunit 11102035;
      VariableName@1006 : Text;
      CommentLineNo@1007 : Integer;
      Found@1008 : Boolean;
      ctDeleteSubTable@1009 : TextConst 'DEU=Related records in table %1 are not deleted;ENU=Related records in table %1 are not deleted;ESP=Related records in table %1 are not deleted;FRA=Related records in table %1 are not deleted;NLD=Gerelateerde records in tabel %1 worden niet verwijderd;DEA=Related records in table %1 are not deleted';
    BEGIN
      IF NOT GetSubTables(Object.ID, TmpSubTable) THEN
        EXIT;

      IF NOT SetRangeOnSection(CALHistoryLine, 'PROPERTIES') THEN
        EXIT;

      CALHistoryLine.SETRANGE("Sub Line No.", 1);
      IF CALHistoryLine.FINDFIRST THEN
        CommentLineNo := CALHistoryLine."Line No.";

      CALHistoryLine.SETFILTER(Code, '%1', '    OnDelete=*');
      IF CALHistoryLine.FINDFIRST THEN BEGIN
        CommentLineNo := CALHistoryLine."Line No.";

        CALHistoryLine.SETRANGE(Code);
        GetLocalVariables(Object, Comment, CALHistoryLine, VariableBuffer, '');

        CALHistoryLine.SETFILTER("Line No.", '>%1', CommentLineNo);
        CALHistoryLine.SETFILTER(Code, '%1', '             END;');
        IF CALHistoryLine.FINDFIRST THEN BEGIN
          CALHistoryLine.SETRANGE("Line No.", CommentLineNo, CALHistoryLine."Line No.");

          VariableBuffer.RESET;
          VariableBuffer.SETRANGE("Object Type", VariableBuffer."Object Type"::Table);
          IF VariableBuffer.FINDSET THEN
            REPEAT
              VariableName := Mgt.AddQuotes(VariableBuffer.Name);
              CALHistoryLine.SETFILTER(Code, Mgt.CreateFilter('* WITH ' + VariableName + ' *', FALSE));
              Found := NOT CALHistoryLine.ISEMPTY;

              IF NOT Found THEN BEGIN
                CALHistoryLine.SETFILTER(Code, Mgt.CreateFilter('*' + VariableName + '.DELETE*', FALSE));
                Found := NOT CALHistoryLine.ISEMPTY;
              END;

              IF NOT Found THEN BEGIN
                CALHistoryLine.SETFILTER(Code, Mgt.CreateFilter('*' + VariableName + '.FIND*', FALSE));
                Found := NOT CALHistoryLine.ISEMPTY;
              END;

              IF NOT Found THEN BEGIN
                CALHistoryLine.SETFILTER(Code, Mgt.CreateFilter('*' + VariableName + '.IS' + 'EMPTY*', FALSE));
                Found := NOT CALHistoryLine.ISEMPTY;
              END;

              IF Found THEN BEGIN
                TmpSubTable.SETRANGE(ID, VariableBuffer."Object No.");
                TmpSubTable.DELETEALL;
              END;

            UNTIL VariableBuffer.NEXT = 0;
        END;

        VariableBuffer.RESET;
        VariableBuffer.SETRANGE(Scope, VariableBuffer.Scope::"Local");
        VariableBuffer.DELETEALL;
        VariableBuffer.RESET;

      END;

      TmpSubTable.RESET;
      IF TmpSubTable.FINDSET THEN
        REPEAT
          IF Object2.GET(TmpSubTable.Type, '', TmpSubTable.ID) THEN
            AddComment(
              Comment, CheckType::Data, DataCheck::"Delete Relating Table",
              STRSUBSTNO(ctDeleteSubTable, Object2.Name), CommentLineNo, 0, 0, FORMAT(TmpSubTable.ID));
        UNTIL TmpSubTable.NEXT = 0;

      CALHistoryLine.RESET;
    END;

    LOCAL PROCEDURE GetLocalVariables@118(VAR Object@1000 : Record 2000000001;VAR Comment@1001 : Record 11102081;VAR CALHistoryLine@1002 : Record 11102053;VAR VariableBuffer@1003 : Record 11102062;Identifier@1004 : Code[100]);
    VAR
      StopLoop@1005 : Boolean;
    BEGIN
      IF COPYSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 2) = 'VAR' THEN BEGIN

        CALHistoryLine.SETFILTER("Line No.", '>%1', CALHistoryLine."Line No.");
        IF CALHistoryLine.FINDFIRST THEN
          REPEAT

            IF STRLEN(CALHistoryLine.Code) > 4 THEN
              StopLoop := COPYSTR(CALHistoryLine.Code, STRLEN(CALHistoryLine.Code) - 4) = 'BEGIN';

            IF NOT StopLoop THEN BEGIN
              AnalyseVariableLine(Object, CALHistoryLine, VariableBuffer, Comment, 0, FALSE, Identifier);
              StopLoop := CALHistoryLine.NEXT = 0;
            END;

          UNTIL StopLoop;
      END;
    END;

    LOCAL PROCEDURE CheckDoubleVariableNames@121(VAR Comment@1000 : Record 11102081;VAR VariableBuffer@1001 : Record 11102062;Identifier@1002 : Code[100]);
    VAR
      VariableBuffer2@1003 : TEMPORARY Record 11102062;
      ctVariableInUse@1004 : TextConst 'DEU=Variable Name ''%1'' already in use as global;ENU=Variable Name ''%1'' already in use as global;ESP=Variable Name ''%1'' already in use as global;FRA=Variable Name ''%1'' already in use as global;NLD=Variabelenaam ''%1'' al in gebruik als globale;DEA=Variable Name ''%1'' already in use as global';
    BEGIN
      VariableBuffer.RESET;
      VariableBuffer.SETCURRENTKEY(Name, Scope);
      VariableBuffer.SETRANGE(Scope, VariableBuffer.Scope::"Local");

      IF VariableBuffer.FINDSET THEN
        REPEAT
          VariableBuffer2 := VariableBuffer;

          VariableBuffer.SETRANGE(Scope, VariableBuffer.Scope::Global);
          VariableBuffer.SETRANGE(Name, VariableBuffer2.Name);
          IF NOT VariableBuffer.ISEMPTY THEN
            AddCodingComment(
              Comment, CodingCheck::"Double Var. Name", STRSUBSTNO(ctVariableInUse, VariableBuffer2.Name),
              VariableBuffer2."C/AL Line No.", 0, 0, Identifier + '-' + FORMAT(VariableBuffer2.Id));

          VariableBuffer.SETRANGE(Scope, VariableBuffer.Scope::"Local");
          VariableBuffer.SETRANGE(Name);

          VariableBuffer := VariableBuffer2;

        UNTIL VariableBuffer.NEXT = 0;

      VariableBuffer.RESET;
    END;

    LOCAL PROCEDURE GetSubTables@119(VAR TableNo@1000 : Integer;VAR TmpObject@1001 : TEMPORARY Record 2000000001) : Boolean;
    VAR
      Relation@1002 : Record 11102078;
      AllObj@1003 : Record 2000000038;
      RecRef@1004 : RecordRef;
      FldRef@1005 : FieldRef;
      KeyRef@1006 : KeyRef;
    BEGIN
      IF NOT AllObj.GET(AllObj."Object Type"::Table, TableNo) THEN
        EXIT;

      RecRef.OPEN(TableNo);
      KeyRef := RecRef.KEYINDEX(1);
      FldRef := KeyRef.FIELDINDEX(KeyRef.FIELDCOUNT);

      Relation.SETCURRENTKEY("Object Type", "Relation Table No.");
      Relation.SETRANGE("Relation Table No.", TableNo);
      Relation.SETRANGE("Relation Field No.", FldRef.NUMBER);
      IF Relation.FINDSET THEN
        REPEAT
          IF IsPrimaryKeyField(Relation."Table No.", Relation."Field No.") THEN
            IF NOT TmpObject.GET(TmpObject.Type::Table, '', Relation."Table No.") THEN BEGIN
              TmpObject.Type := TmpObject.Type::Table;
              TmpObject.ID := Relation."Table No.";
              TmpObject.INSERT;
            END;
        UNTIL Relation.NEXT = 0;

      IF TmpObject.FINDSET THEN
        REPEAT
          IF FindBetterParentTable(TmpObject, TableNo) THEN
            TmpObject.DELETE;
        UNTIL TmpObject.NEXT = 0;

      EXIT(NOT TmpObject.ISEMPTY);
    END;

    LOCAL PROCEDURE IsPrimaryKeyField@125(TableNo@1000 : Integer;FieldNo2@1001 : Integer) : Boolean;
    VAR
      AllObj@1002 : Record 2000000038;
      RecRef@1003 : RecordRef;
      FldRef@1004 : FieldRef;
      KeyRef@1005 : KeyRef;
      i@1006 : Integer;
    BEGIN
      IF NOT AllObj.GET(AllObj."Object Type"::Table, TableNo) THEN
        EXIT;

      RecRef.OPEN(TableNo);

      KeyRef := RecRef.KEYINDEX(GetBestPrimaryKeyNo(RecRef));
      FOR i := 1 TO KeyRef.FIELDCOUNT DO BEGIN
        FldRef := KeyRef.FIELDINDEX(i);
        IF FldRef.NUMBER = FieldNo2 THEN
          EXIT(TRUE);
      END;
    END;

    LOCAL PROCEDURE FindBetterParentTable@120(VAR Object@1000 : Record 2000000001;TableNo@1001 : Integer) : Boolean;
    VAR
      Relation@1002 : Record 11102078;
      Relation2@1003 : Record 11102078;
      RecRef@1004 : RecordRef;
      RecRef2@1005 : RecordRef;
      FldRef@1006 : FieldRef;
      FldRef2@1007 : FieldRef;
      KeyRef@1008 : KeyRef;
      KeyRef2@1009 : KeyRef;
      i@1010 : Integer;
      j@1011 : Integer;
    BEGIN
      IF Object.ID = DATABASE::"OM - Document Line" THEN BEGIN
        Object.ID := Object.ID;
        Object.ID := Object.ID;
        Object.ID := Object.ID;
      END;

      RecRef.OPEN(Object.ID);
      KeyRef := RecRef.KEYINDEX(GetBestPrimaryKeyNo(RecRef));
      IF KeyRef.FIELDCOUNT <= 2 THEN
        EXIT;

      FOR i := KeyRef.FIELDCOUNT DOWNTO 2 DO BEGIN

        FldRef := KeyRef.FIELDINDEX(i);

        Relation.SETCURRENTKEY("Object Type", "Table No.");
        Relation.SETRANGE("Table No.", Object.ID);
        Relation.SETRANGE("Field No.", FldRef.NUMBER);
        IF Relation.FINDSET THEN
          REPEAT
            IF Relation."Relation Table No." = TableNo THEN
              EXIT(FALSE);

            RecRef2.OPEN(Relation."Relation Table No.");
            KeyRef2 := RecRef2.KEYINDEX(1);
            IF KeyRef2.FIELDCOUNT > 1 THEN
              FOR j := 1 TO KeyRef2.FIELDCOUNT DO BEGIN
                FldRef2 := KeyRef2.FIELDINDEX(j);

                Relation2.SETCURRENTKEY("Object Type", "Table No.");
                Relation2.SETRANGE("Table No.", Relation."Relation Table No.");
                Relation2.SETRANGE("Field No.", FldRef2.NUMBER);
                Relation2.SETRANGE("Relation Table No.", TableNo);
                IF NOT Relation2.ISEMPTY THEN
                  EXIT(TRUE);
              END;
            RecRef2.CLOSE;
          UNTIL Relation.NEXT = 0;
      END;
    END;

    LOCAL PROCEDURE GetBestPrimaryKeyNo@122(VAR RecRef@1000 : RecordRef) ReturnValue : Integer;
    VAR
      FldRef@1001 : FieldRef;
      KeyRef@1002 : KeyRef;
    BEGIN
      KeyRef := RecRef.KEYINDEX(1);
      IF (KeyRef.FIELDCOUNT = 1) AND (RecRef.KEYCOUNT > 1) THEN BEGIN
        FldRef := KeyRef.FIELDINDEX(1);
        IF FORMAT(FldRef.TYPE) = 'Integer' THEN
          EXIT(2);
      END;

      EXIT(1);
    END;

    LOCAL PROCEDURE AddBracketComment@128(VAR Comment@1000 : Record 11102081;VAR CALLine@1001 : Integer;VAR Identifier@1002 : Code[100];VAR BracketCommentAdded@1003 : Boolean);
    VAR
      ctUseSlashes@1004 : TextConst 'DEU=Use slashes instead of curly brackets;ENU=Use slashes instead of curly brackets;ESP=Use slashes instead of curly brackets;FRA=Use slashes instead of curly brackets;NLD=Gebruik slashes in plaats van accolades;DEA=Use slashes instead of curly brackets';
    BEGIN
      IF BracketCommentAdded THEN
        EXIT;
      AddCodingComment(Comment, CodingCheck::Brackets, ctUseSlashes, CALLine, 0, 0, Identifier);
      BracketCommentAdded := TRUE;
    END;

    LOCAL PROCEDURE AnalyseTransferFields@40(VAR Comment@1000 : Record 11102081;VAR CALHistoryLine@1001 : Record 11102053;Identifier@1002 : Code[100];VAR VariableBuffer@1003 : TEMPORARY Record 11102062;IndentRecName@1004 : Text;IndentRecordNo@1005 : Integer);
    VAR
      TmpCheckTransferfieldsFld@1006 : TEMPORARY Record 11102084;
      Mgt@1007 : Codeunit 11102035;
      CheckTransferFieldsMgt@1008 : Codeunit 11102062;
      CodeLine@1009 : Text;
      DestRecordString@1010 : Text;
      SourceRecordString@1011 : Text;
      DestTableNo@1012 : Integer;
      Pos@1013 : Integer;
      SourceTableNo@1014 : Integer;
      TransferFieldsPos@1015 : Integer;
      ctErrorTransferFields@1016 : TextConst 'DEU="Transferfields on field %1 can cause an error. %2 := %3";ENU="Transferfields on field %1 can cause an error. %2 := %3";ESP="Transferfields on field %1 can cause an error. %2 := %3";FRA="Transferfields on field %1 can cause an error. %2 := %3";NLD="Transferfields op veld %1 kan een fout veroorzaken. %2 := %3";DEA="Transferfields on field %1 can cause an error. %2 := %3"';
    BEGIN
      CodeLine := DELCHR(CALHistoryLine.Code, '<>');

      TransferFieldsPos := STRPOS(CodeLine, 'TRANSFERFIELDS');
      IF TransferFieldsPos = 0 THEN
        EXIT;

      DestRecordString := DELSTR(CodeLine, TransferFieldsPos);
      IF DestRecordString <> '' THEN
        DestRecordString := DELSTR(DestRecordString, STRLEN(DestRecordString))
      ELSE
        IF IndentRecName = '' THEN
          DestTableNo := IndentRecordNo
        ELSE
          DestRecordString := IndentRecName;
      IF STRPOS(DestRecordString, '[') > 0 THEN
        DestRecordString := DELSTR(DestRecordString, STRPOS(DestRecordString, '['));

      CodeLine := COPYSTR(CodeLine, TransferFieldsPos + 15);
      CodeLine := DELCHR(CodeLine, '<', '( ');

      Pos := 1;
      IF NOT NextField(CodeLine, Pos, SourceRecordString) THEN
        EXIT;

      IF DestRecordString <> '' THEN BEGIN
        VariableBuffer.SETFILTER(Name, Mgt.CreateFilter(DestRecordString, TRUE));
        IF VariableBuffer.FINDFIRST THEN
          IF (VariableBuffer."Object Type" = VariableBuffer."Object Type"::Table) AND
             (VariableBuffer."Object No." <> 0)
          THEN
            DestTableNo := VariableBuffer."Object No.";
      END;

      VariableBuffer.SETFILTER(Name, Mgt.CreateFilter(SourceRecordString, TRUE));
      IF VariableBuffer.FINDFIRST THEN
        IF (VariableBuffer."Object Type" = VariableBuffer."Object Type"::Table) AND
           (VariableBuffer."Object No." <> 0)
        THEN
          SourceTableNo := VariableBuffer."Object No.";

      IF (DestTableNo = 0) OR (SourceTableNo = 0) THEN
        EXIT;

      CheckTransferFieldsMgt.GetFields(SourceTableNo, DestTableNo, TmpCheckTransferfieldsFld);
      WITH TmpCheckTransferfieldsFld DO BEGIN
        SETRANGE("Is Error", TRUE);
        IF FINDFIRST THEN
          AddDataComment(
            Comment, DataCheck::Transferfields,
            STRSUBSTNO(ctErrorTransferFields, "To Field Name", "To Field Type", "From Field Type"),
            CALHistoryLine."Line No.", Identifier);
      END;
    END;

    LOCAL PROCEDURE AnalysePageControls@72(VAR CALHistoryLine@1000 : Record 11102053;VAR Comment@1001 : Record 11102081;StartControlSection@1002 : Integer) SectionLineNo : Integer;
    VAR
      ActionContainerType@1003 : Text;
      ActiveSection@1004 : Text;
      CodeLine@1005 : Text;
      ControlId@1006 : Text;
      ControlType@1007 : Text;
      IndentString@1008 : Text;
      PageType@1009 : Text;
      PropertyName@1010 : Text;
      PropertyValue@1011 : Text;
      ControlLineNo@1012 : Integer;
      Indent@1013 : Integer;
      Position@1014 : Integer;
      CaptionNeeded@1015 : Boolean;
      HasCaption@1016 : Boolean;
      HasImage@1017 : Boolean;
      ImageNeeded@1018 : Boolean;
      IsEmptyAction@1019 : Boolean;
      ctAddCaption@1020 : TextConst 'DEU=Add caption;ENU=Add caption;ESP=Add caption;FRA=Add caption;NLD=Voeg caption toe;DEA=Add caption';
      ctEmptyAction@1021 : TextConst 'DEU=This action has no code;ENU=This action has no code;ESP=This action has no code;FRA=This action has no code;NLD=Deze actie heeft geen code;DEA=This action has no code';
      ctNoImagePresent@1022 : TextConst 'DEU=Add an image;ENU=Add an image;ESP=Add an image;FRA=Add an image;NLD=Voeg een afbeelding toe;DEA=Add an image';
      ctRemoveProperty@1023 : TextConst 'DEU=Remove property: ''%1'' is default for ''%2'';ENU=Remove property: ''%1'' is default for ''%2'';ESP=Remove property: ''%1'' is default for ''%2'';FRA=Remove property: ''%1'' is default for ''%2'';NLD=Verwijder property: ''%1'' is de standaardwaarde voor ''%2'';DEA=Remove property: ''%1'' is default for ''%2''';
    BEGIN
      PageType := 'Card';

      WITH CALHistoryLine DO BEGIN
        RESET;
        SETRANGE("Sub Line No.", 1);
        IF FINDSET THEN
          REPEAT
            IF DELSTR(Code, 14) = '    PageType=' THEN BEGIN
              PageType := COPYSTR(Code, 14);
              PageType := DELCHR(PageType, '>', ';');
              IF NOT (PageType IN ['Card', 'List', 'Document', 'Worksheet', 'RoleCenter']) THEN
                EXIT;
            END;
            IF Code = PADSTR('', StartControlSection + 1) + 'ActionList=ACTIONS' THEN
              ActiveSection := 'ACTIONS';

            IF Code = PADSTR('', StartControlSection - 1) + 'CONTROLS' THEN
              ActiveSection := 'CONTROLS';

            CASE ActiveSection OF

              'ACTIONS' :
                BEGIN
                  IF Code[StartControlSection + 4] = '{' THEN BEGIN
                    ControlLineNo := "Line No.";

                    HasImage := FALSE;
                    IsEmptyAction := TRUE;
                    HasCaption := FALSE;

                    Position := StartControlSection + 5;
                    NextValue(Code, Position, ';', '"', '"', ControlId);
                    NextValue(Code, Position, ';', '"', '"', IndentString);
                    IF EVALUATE(Indent, IndentString) THEN
                      ;
                    NextValue(Code, Position, ';', '"', '"', ControlType);

                  END;

                  IF NOT (FORMAT(Code[StartControlSection + 20]) IN ['', ' ']) THEN BEGIN
                    CodeLine := COPYSTR(Code, StartControlSection + 20);
                    GetPropertyName(CodeLine, PropertyName);
                    GetPropertyValue(CALHistoryLine, PropertyValue);

                    IF PropertyName <> '' THEN
                      IF DefaultProperty('', 'Action', PropertyName) = PropertyValue THEN
                        AddLayoutComment(Comment, LayoutCheck::Properties,
                          STRSUBSTNO(ctRemoveProperty, PropertyValue, PropertyName), "Line No.", ControlId);

                    CASE PropertyName OF
                      '' :
                        ;

                      'Image' :
                        HasImage := TRUE;

                      'CaptionML' :
                        HasCaption := TRUE;

                      'ActionContainerType' :
                        ActionContainerType := PropertyValue;

                      ELSE
                        IsEmptyAction := FALSE;

                    END;
                  END;

                  IF Code <> '' THEN
                    IF (Code[STRLEN(Code)] = '}') AND (ControlId <> '') THEN BEGIN
                      IF NOT HasImage THEN BEGIN
                        ImageNeeded := FALSE;
                        IF (ControlType = 'Action') AND NOT IsEmptyAction AND
                           NOT (ActionContainerType IN ['HomeItems', 'ActivityButtons'])
                        THEN
                          ImageNeeded := TRUE;

                        IF (ControlType = 'ActionGroup') AND (Indent > 1) THEN
                          ImageNeeded := TRUE;

                        IF ImageNeeded THEN
                          AddLayoutComment(Comment, LayoutCheck::Image, ctNoImagePresent, ControlLineNo, ControlId);

                      END;
                      IF NOT HasCaption THEN BEGIN
                        CaptionNeeded := FALSE;
                        IF (ControlType = 'Action') AND NOT IsEmptyAction THEN
                          CaptionNeeded := TRUE;

                        IF (ControlType = 'ActionGroup') AND (Indent > 1) THEN
                          CaptionNeeded := TRUE;

                        IF CaptionNeeded THEN
                          AddCaptionComment(Comment, CaptionCheck::"Missing Captions", ctAddCaption, ControlLineNo, 'ACTION-' + ControlId);

                      END;
                      IF IsEmptyAction AND (ControlType = 'Action') THEN
                        AddLayoutComment(Comment, LayoutCheck::"Empty Action", ctEmptyAction, ControlLineNo, ControlId);

                      ControlId := '';
                    END;

                  IF Code = PADSTR('', StartControlSection + 1) + '}' THEN
                    ActiveSection := '';
                END;

              'CONTROLS' :
                BEGIN
                  IF Code[StartControlSection + 2] = '{' THEN BEGIN

                    ControlLineNo := "Line No.";
                    Position := StartControlSection + 7;
                    NextValue(Code, Position, ';', '"', '"', ControlId);
                    NextValue(Code, Position, ';', '"', '"', IndentString);
                    IF EVALUATE(Indent, IndentString) THEN
                      ;
                    NextValue(Code, Position, ';', '"', '"', ControlType);
                  END;

                  IF NOT (FORMAT(Code[StartControlSection + 14]) IN ['', ' ']) THEN BEGIN
                    CodeLine := COPYSTR(Code, StartControlSection + 14);
                    GetPropertyName(CodeLine, PropertyName);
                    GetPropertyValue(CALHistoryLine, PropertyValue);

                    IF PropertyName <> '' THEN
                      IF DefaultProperty('', 'Control', PropertyName) = PropertyValue THEN
                        AddLayoutComment(
                          Comment, LayoutCheck::Properties,
                          STRSUBSTNO(ctRemoveProperty, PropertyValue, PropertyName), "Line No.", ControlId);

                  END;

                  IF Code = PADSTR('', StartControlSection - 1) + '}' THEN
                    ActiveSection := '';

                END;
            END;

          UNTIL NEXT = 0;
        RESET;

      END;
    END;

    LOCAL PROCEDURE GetPermissionRange@124(VAR ProjectType@1000 : Record 11102097;VAR PermissionRange@1001 : Record 2000000044) : Boolean;
    VAR
      ImExportMgt@1002 : Codeunit 11102043;
      InStr@1003 : InStream;
      ImportLine@1004 : Text;
      Value@1005 : ARRAY [11] OF Text;
      FieldId@1006 : Integer;
      i@1007 : Integer;
      ValidFile@1008 : Boolean;
      ctNotValid@1009 : TextConst 'DEU=not a valid license file;ENU=not a valid license file;ESP=not a valid license file;FRA=not a valid license file;NLD=Geen geldig licentiebestand;DEA=not a valid license file';
    BEGIN
      WITH PermissionRange DO BEGIN

        ProjectType.CALCFIELDS("Customer License");
        IF NOT ProjectType."Customer License".HASVALUE THEN
          EXIT;

        ProjectType."Customer License".CREATEINSTREAM(InStr);

        ValidFile := TRUE;

        WHILE ImExportMgt.ReadLine(InStr, ImportLine) DO BEGIN

          FieldId := 1;

          CLEAR(Value);
          FOR i := 1 TO STRLEN(ImportLine) DO
            IF ImportLine[i] = ' ' THEN
              FieldId += 1
            ELSE
              Value[FieldId] := Value[FieldId] + FORMAT(ImportLine[i]);

          IF Value[10] <> '' THEN
            ValidFile := FALSE;

          IF NOT EVALUATE("Object Type", Value[1]) THEN
            ValidFile := FALSE;

          IF NOT EVALUATE(Index, Value[2]) THEN
            ValidFile := FALSE;

          IF NOT EVALUATE(From, Value[3]) THEN
            ValidFile := FALSE;

          IF NOT EVALUATE("To", Value[4]) THEN
            ValidFile := FALSE;

          IF NOT EVALUATE("Read Permission", Value[5]) THEN
            ValidFile := FALSE;

          IF NOT EVALUATE("Insert Permission", Value[6]) THEN
            ValidFile := FALSE;

          IF NOT EVALUATE("Modify Permission", Value[7]) THEN
            ValidFile := FALSE;

          IF NOT EVALUATE("Delete Permission", Value[8]) THEN
            ValidFile := FALSE;

          IF NOT EVALUATE("Execute Permission", Value[9]) THEN
            ValidFile := FALSE;

          IF NOT INSERT THEN
            ValidFile := FALSE;

          IF NOT ValidFile THEN
            ProjectType.FIELDERROR("Customer License", ctNotValid);

        END;

      END;

      EXIT(TRUE);
    END;

    BEGIN
    END.
  }
}

