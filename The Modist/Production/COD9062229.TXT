OBJECT Codeunit 9062229 TNP Utils
{
  OBJECT-PROPERTIES
  {
    Date=10/05/16;
    Time=12:00:00 PM;
    Version List=NA2016.15;
  }
  PROPERTIES
  {
    OnRun=VAR
            tempRegExp@1000000000 : Text;
            Mytext@1000000001 : Text;
          BEGIN
          END;

  }
  CODE
  {
    VAR
      Text001@1000000000 : TextConst 'ENU=Cannot get Contact No. as UserID %1 does not exist in User Setup table;ENG=Cannot get Contact No. as UserID %1 does not exist in User Setup table';
      Text002@1000000001 : TextConst 'ENU=Cannot get Contact No. as User Setup for User %1 has no Contact No.;ENG=Cannot get Contact No. as User Setup for User %1 has no Contact No.';
      SysB@1000000003 : Record 9062230;
      Convert@1000000019 : Codeunit 9062683;
      "3Tier"@1000000002 : Codeunit 419;
      mDotNetFileSystem@1000000004 : Codeunit 9062264;
      Text003@1000000005 : TextConst 'ENU=Cannot get Salesperson Code as User Setup for User %1 has no Salesperson Code;ENG=Cannot get Salesperson Code as User Setup for User %1 has no Salesperson Code';
      eCalcDateBracket@1000000006 : TextConst 'ENU=There must be a Close Bracket '')'' after the keyword CALCDATE;ENG=There must be a Close Bracket '')'' after the keyword CALCDATE';
      eCalcDateComma@1000000007 : TextConst 'ENU=There must be a Comman '','' after the keyword CALCDATE;ENG=There must be a Comman '','' after the keyword CALCDATE';
      eGetDSBracket@1000000008 : TextConst 'ENU=There must be a Close Curly Bracket ''}'' after the Open Curly Bracket ''{'';ENG=There must be a Close Curly Bracket ''}'' after the Open Curly Bracket ''{''';
      eNoDS@1000000009 : TextConst 'ENU=There must be a Dataset Code between the Curly Brackets ''{ }'';ENG=There must be a Dataset Code between the Curly Brackets ''{ }''';
      eDSNotFound@1000000010 : TextConst 'ENU=The Dataset %1 was not found;ENG=The Dataset %1 was not found';
      eFavsBracket@1000000013 : TextConst 'ENU=There must be a Close Bracket '')'' after the keyword FAVOURITES;ENG=There must be a Close Bracket '')'' after the keyword FAVOURITES';
      tCurrentUserSysB@1000000012 : TextConst 'ENU=CURR_USER;ENG=CURR_USER';
      tCurrentContactSysB@1000000014 : TextConst 'ENU=CURR_CONTACT;ENG=CURR_CONTACT';
      NameValueToolkit@1000000011 : Codeunit 9062587;
      RecordRefManagement@1000000018 : Codeunit 9062241;
      SmartFilterManagement@1000000016 : Codeunit 9062231;
      String@1000000017 : Codeunit 9062236;
      TNPToolkit@1000000015 : Codeunit 9062230;

    PROCEDURE IsWorkflowInUse@1000000002(WFCode@1000000000 : Code[20]) : Boolean;
    VAR
      WorkFlow@1000000001 : Record 9062258;
    BEGIN
      IF WFCode <> '' THEN
        IF WorkFlow.GET(WFCode) AND WorkFlow.Enabled THEN
          EXIT(TRUE);
    END;

    PROCEDURE CreatePageHyperlink@1000000003(TableNo@1000000005 : Integer;PositionText@1000000006 : Text[250];PageNo@1000000000 : Integer) : Text[250];
    VAR
      RecRef@1000000007 : RecordRef;
      FieldRef@1000000008 : FieldRef;
      Output@1000000009 : Text[250];
      TxtNoTableNo@1000000002 : TextConst 'ENU=No Table No. was sent when trying to open the page\\It might be that a record has not been selected yet;ENG=No Table No. was sent when trying to open the page\\It might be that a record has not been selected yet';
      TxtNoPosition@1000000003 : TextConst 'ENU=No Position Text was sent when trying to open the page\\It might be that a record has not been selected yet;ENG=No Position Text was sent when trying to open the page\\It might be that a record has not been selected yet';
      TxtNoCardPageFound@1000000004 : TextConst 'ENU=No card page was found for table %1, record "%2"\\'' + ''A solution to this is to add a dataset which contains this record and has a card page no. set;ENG=No card page was found for table %1, record "%2"\\'' + ''A solution to this is to add a dataset which contains this record and has a card page no. set';
      TableManagement@1000000001 : Codeunit 9062585;
    BEGIN
      IF TableNo = 0 THEN ERROR(TxtNoTableNo);
      IF PositionText = '' THEN ERROR(TxtNoPosition);

      RecRef.OPEN(TableNo);
      RecRef.SETPOSITION(PositionText);

      IF PageNo = 0 THEN BEGIN
        PageNo := TableManagement.GetCardPageId(TableNo,PositionText);
      END;

      IF PageNo = 0 THEN ERROR(TxtNoCardPageFound,TableNo,PositionText);

      Output := 'dynamicsnav:////runpage?page=' + FORMAT(PageNo) + '&bookmark=' + FORMAT(RecRef.RECORDID,0,10) + '&mode=View';
      EXIT(Output);
    END;

    PROCEDURE CreateFileredPageHyperlink@1000000055(TableNo@1000000005 : Integer;PositionText@1000000006 : Text[250];FilterFieldID@1000000010 : Integer;FilterString@1000000011 : Text;PageNo@1000000000 : Integer) : Text[250];
    VAR
      RecRef@1000000007 : RecordRef;
      FieldRef@1000000008 : FieldRef;
      Output@1000000009 : Text[250];
      TableManagement@1000000001 : Codeunit 9062585;
      TxtNoTableNo@1000000002 : TextConst 'ENU=No Table No. was sent when trying to open the page\\It might be that a record has not been selected yet;ENG=No Table No. was sent when trying to open the page\\It might be that a record has not been selected yet';
      TxtNoPosition@1000000003 : TextConst 'ENU=No Position Text was sent when trying to open the page\\It might be that a record has not been selected yet;ENG=No Position Text was sent when trying to open the page\\It might be that a record has not been selected yet';
      TxtNoCardPageFound@1000000004 : TextConst 'ENU=No card page was found for table %1, record "%2"\\'' + ''A solution to this is to add a dataset which contains this record and has a card page no. set;ENG=No card page was found for table %1, record "%2"\\'' + ''A solution to this is to add a dataset which contains this record and has a card page no. set';
      Bookmark@1000000012 : Text;
      Filter@1000000013 : Text;
    BEGIN
      IF TableNo = 0 THEN ERROR(TxtNoTableNo);
      RecRef.OPEN(TableNo);

      IF PositionText <> '' THEN BEGIN
        RecRef.SETPOSITION(PositionText);
        Bookmark := '&bookmark=' + FORMAT(RecRef.RECORDID,0,10);
      END;

      IF FilterFieldID <> 0 THEN BEGIN
        FieldRef := RecRef.FIELD(FilterFieldID);
        Filter := '&$filter=';
        Filter := Filter + '''' + String.Replace(FORMAT(RecRef.NAME),' ','%20') + '''';
        Filter := Filter + '.';
        Filter := Filter + '''' + String.Replace(FORMAT(FieldRef.NAME),' ','%20') + '''';
        Filter := Filter + '%20IS%20';
        Filter := Filter + '''' + String.Replace(FilterString,'|','%7C') + '''';
      END;

      IF PageNo = 0 THEN BEGIN
        PageNo := TableManagement.GetCardPageId(TableNo,PositionText);
      END;

      IF PageNo = 0 THEN ERROR(TxtNoCardPageFound,TableNo,PositionText);

      Output := 'dynamicsnav:////runpage?page=' + FORMAT(PageNo) + Bookmark + Filter + '&mode=View';
      EXIT(Output);
    END;

    PROCEDURE CreateRecViewHyperlink@1000000001(TableNo@1000000000 : Integer;PositionText@1000000001 : Text[250];PageNo@1000000002 : Integer) : Text[250];
    BEGIN
      EXIT(CreatePageHyperlink(TableNo,PositionText,PageNo));
    END;

    PROCEDURE RunCardPage@1000000010(TableNo@1000000002 : Integer;PositionText@1000000003 : Text;RunModal@1000000005 : Boolean);
    VAR
      RunWithRecRef@1000000000 : Codeunit 9062239;
      RecRef@1000000001 : RecordRef;
    BEGIN
      //DOC PC NA2015.1 08/04/2014 >>

      RecRef.OPEN(TableNo);
      RecRef.SETPOSITION(PositionText);
      RecRef.GET(RecRef.RECORDID);

      RunWithRecRef.RunCardPage(RecRef,RunModal);
    END;

    PROCEDURE RunListPage@1000000039(TableNo@1000000002 : Integer;PositionText@1000000003 : Text;RunModal@1000000005 : Boolean);
    VAR
      RunWithRecRef@1000000000 : Codeunit 9062239;
      RecRef@1000000001 : RecordRef;
    BEGIN
      //DOC PC NA2015.1 08/04/2014 >>

      RecRef.OPEN(TableNo);
      RecRef.SETPOSITION(PositionText);
      RecRef.GET(RecRef.RECORDID);

      RunWithRecRef.RunListPage(RecRef,RunModal);
    END;

    PROCEDURE GetUserContactNo@1000000000(UserID@1000000000 : Code[50]) : Code[20];
    VAR
      nAblementUser@1000000001 : Record 9062729;
    BEGIN
      IF NOT nAblementUser.GET(UserID) THEN
        CLEAR(nAblementUser);
      EXIT(nAblementUser."Contact No.");
    END;

    PROCEDURE GetUserSalespersonCode@1000000043(UserID@1000000000 : Code[50]) : Code[20];
    VAR
      nAblementUser@1000000002 : Record 9062729;
    BEGIN
      IF NOT nAblementUser.GET(UserID) THEN
        CLEAR(nAblementUser);
      EXIT(nAblementUser."Salesperson/Purchaser Code");
    END;

    PROCEDURE GetUserTeamFilter@1000000053(UserID@1000000000 : Code[50]) : Code[20];
    VAR
      nAblementUser@1000000002 : Record 9062729;
    BEGIN
      IF NOT nAblementUser.GET(UserID) THEN
        CLEAR(nAblementUser);
      EXIT(nAblementUser."Team Filter");
    END;

    PROCEDURE GetUserVendorNo@1000000004(UserID@1000000001 : Code[50]) : Code[20];
    VAR
      nAblementUser@1000000000 : Record 9062729;
    BEGIN
      IF NOT nAblementUser.GET(UserID) THEN
        CLEAR(nAblementUser);
      EXIT(nAblementUser."Vendor No.");
    END;

    PROCEDURE CalcDueDateTime@1000000007(dt@1000000000 : DateTime;dur@1000000001 : Duration;perStart@1000000002 : Time;perEnd@1000000003 : Time;incWeekends@1000000004 : Boolean) : DateTime;
    VAR
      result@1000000005 : DateTime;
      rTime@1000000006 : Time;
      rDate@1000000007 : Date;
    BEGIN
      IF dur = 0 THEN EXIT(dt);
      result := dt + dur;
      rTime := DT2TIME(result);
      rDate := DT2DATE(result);
      IF rTime < perStart THEN rTime := perStart;
      IF rTime > perEnd THEN BEGIN
        rTime := perStart + (rTime-perEnd);
        rDate := DT2DATE(result) + 1;
      END;
      result := CREATEDATETIME(rDate,rTime);
      EXIT(result);
    END;

    PROCEDURE CalcTakenDuration@1000000008(dtStart@1000000000 : DateTime;dtEnd@1000000001 : DateTime;perStart@1000000002 : Time;perEnd@1000000003 : Time;incWeekends@1000000004 : Boolean) : Duration;
    VAR
      dateStarted@1000000005 : Date;
      dateEnded@1000000006 : Date;
      timeStarted@1000000007 : Time;
      timeEnded@1000000008 : Time;
      return@1000000009 : Duration;
      tmpDur@1000000010 : Duration;
      tmpDaysInt@1000000011 : Integer;
      tmpDays@1000000012 : Duration;
      i@1000000013 : Integer;
    BEGIN
      dateStarted := DT2DATE(dtStart);
      dateEnded := DT2DATE(dtEnd);
      timeStarted := DT2TIME(dtStart);
      timeEnded := DT2TIME(dtEnd);

      IF timeEnded < timeStarted THEN BEGIN
        EVALUATE(tmpDur,'24h');
        return := tmpDur - (timeStarted - timeEnded);
      END ELSE
        return := timeEnded - timeStarted;

      i := dateEnded - dateStarted;

      IF i > 0 THEN BEGIN
        REPEAT
          IF incWeekends THEN
            tmpDaysInt += 1
          ELSE
            IF (DATE2DWY(dateEnded-i,1) <> 6) AND
               (DATE2DWY(dateEnded-i,1) <> 7) THEN tmpDaysInt += 1;
          i -= 1;
        UNTIL i = 0;
      END ELSE tmpDaysInt := 0;

      EVALUATE(tmpDays,FORMAT(tmpDaysInt) + 'd');
      return += tmpDays;
      EXIT(return);
    END;

    PROCEDURE NotificationsToXML@1000000006(VAR XMLOutput@1000000000 : BigText;VAR WFlowNot@1000000007 : Record 9062261;RTCLink@1000000002 : Boolean);
    VAR
      WFlowAct@1000000001 : Record 9062266;
    BEGIN
      CLEAR(XMLOutput);
      XMLOutput.ADDTEXT('<Root>');

      IF WFlowNot.FINDSET THEN BEGIN
        REPEAT
          IF NOT WFlowAct.GET(WFlowNot."Workflow GUID") THEN EXIT;
          XMLOutput.ADDTEXT('<Notification>');
          XMLOutput.ADDTEXT('<Subject>' + WFlowNot.Subject + '</Subject>');
          XMLOutput.ADDTEXT('<Body>' + WFlowNot.Body + '</Body>');
          XMLOutput.ADDTEXT('<LinkURL>');
          XMLOutput.ADDTEXT(String.Replace(String.Replace(CreatePageHyperlink(DATABASE::"Enhanced Workflow Activity Ln.",WFlowAct.GETPOSITION,PAGE::"Enhanced Workflow Activity Ln."),'&','ª')
                                           ,'ª','&amp;'));
          XMLOutput.ADDTEXT('</LinkURL>');
          XMLOutput.ADDTEXT('</Notification>');
        UNTIL WFlowNot.NEXT = 0;
      END;

      XMLOutput.ADDTEXT('</Root>');
    END;

    PROCEDURE FindCodeInString@1000000012(String@1000000003 : Text[250];Code@1000000004 : Text[20]) Value : Text[250];
    VAR
      Filename@1000000000 : Text[250];
      start@1000000001 : Integer;
      endchar@1000000002 : Integer;
    BEGIN
      IF STRPOS(String,Code) <> 0 THEN BEGIN
        start := STRPOS(String,Code) + STRLEN(Code);
        endchar := start + STRPOS(COPYSTR(String,start),')') -1;
        EXIT(COPYSTR(String,start,endchar-start));
      END;
    END;

    PROCEDURE GetContactFromEmail@1000000030(EmailAdd@1000000000 : Text[250]) : Code[20];
    VAR
      Contact@1000000001 : Record 5050;
      ContactNo@1000000002 : Code[20];
    BEGIN
      EmailAdd := DELCHR(EmailAdd, '<>', ' ');
      IF (EmailAdd <> '') THEN
      BEGIN
        Contact.SETCURRENTKEY("E-Mail");
        Contact.SETRANGE("E-Mail", LOWERCASE(COPYSTR(EmailAdd, 1, MAXSTRLEN(Contact."E-Mail"))));
        IF Contact.FINDFIRST THEN
          ContactNo := Contact."No.";
      END;
      EXIT(ContactNo);
    END;

    PROCEDURE DownloadToClientFileName@1(ServerFileName@1000 : Text[250];ToFile@1006 : Text[250]) : Text[250];
    VAR
      ClientFileName@1001 : Text[250];
      objScript@1002 : Automation "{0E59F1D2-1FBE-11D0-8FF2-00A0D10038BC} 1.0:{0E59F1D5-1FBE-11D0-8FF2-00A0D10038BC}:'Microsoft Script Control 1.0'.ScriptControl";
      CR@1003 : Text[1];
    BEGIN
      ClientFileName := ToFile;
      IF NOT DOWNLOAD(ServerFileName, '', '<TEMP>','', ClientFileName) THEN
        EXIT('');
      IF CREATE(objScript, TRUE, TRUE) THEN
      BEGIN
        CR := ' '; CR[1] := 13;
        objScript.Language := 'VBScript';
        objScript.AddCode(
        'function RenameTempFile(fromFile, toFile)'+CR+
        'set fso = createobject("Scripting.FileSystemObject")'+CR+
        'set x = createobject("Scriptlet.TypeLib")'+CR+
        'path = fso.getparentfoldername(fromFile)'+CR+
        'toPath = path+"\"+left(x.GUID,38)'+CR+
        'fso.CreateFolder toPath'+CR+
        'fso.MoveFile fromFile, toPath+"\"+toFile'+CR+
        'RenameTempFile = toPath'+CR+
        'end function');
        ClientFileName := objScript.Eval('RenameTempFile("'+ClientFileName+'","'+ToFile+'")');
        ClientFileName := ClientFileName+'\'+ToFile;
      END;
      EXIT(ClientFileName);
    END;

    PROCEDURE GetPrimKeyString@1000000016(RecRef@1000000000 : RecordRef) PrimKey : Text[200];
    VAR
      FieldRef@1000000001 : FieldRef;
      i@1000000002 : Integer;
      TextRep@1000000003 : Text[100];
      tempInt@1000000004 : Integer;
    BEGIN
      IF RecRef.KEYINDEX(RecRef.CURRENTKEYINDEX).FIELDCOUNT > 0 THEN BEGIN
        i := 1;
        REPEAT
          FieldRef := RecRef.KEYINDEX(RecRef.CURRENTKEYINDEX).FIELDINDEX(i);
          IF FORMAT(FieldRef.TYPE) = 'Option' THEN BEGIN
            TextRep := FORMAT(FieldRef.VALUE,0,2);
          END ELSE
            TextRep := FORMAT(FieldRef.VALUE);
          IF i > 1 THEN
            PrimKey += '+';

          PrimKey += TextRep;
          i += 1;

        UNTIL i > RecRef.KEYINDEX(RecRef.CURRENTKEYINDEX).FIELDCOUNT
      END;
    END;

    PROCEDURE GetNextWord@1000000019(theString@1000000000 : Text[1024];StartPos@1000000001 : Integer;VAR theWord@1000000006 : Text[1024]) EndPos : Integer;
    VAR
      currChar@1000000002 : Text[1];
      i@1000000004 : Integer;
      FoundStart@1000000003 : Boolean;
      OpenQuotes@1000000005 : Boolean;
    BEGIN
      //Delimeters:
      //  Space
      theWord := '';
      FOR i := StartPos TO STRLEN(theString) DO BEGIN
        currChar := COPYSTR(theString,i,1);
        IF NOT FoundStart THEN
          IF currChar <> ' ' THEN FoundStart := TRUE;

        IF FoundStart THEN BEGIN
          IF i = STRLEN(theString) THEN BEGIN
            IF NOT((CharIsQuote(currChar)) OR (currChar <> ' ')) THEN
              theWord := theWord + currChar;
            EndPos := i;
            EXIT(EndPos);
          END;

          IF OpenQuotes THEN BEGIN
            IF NOT CharIsQuote(currChar) THEN
              theWord := theWord + currChar
            ELSE
              OpenQuotes := FALSE;
          END ELSE BEGIN
            IF CharIsQuote(currChar) THEN
              OpenQuotes := TRUE
            ELSE BEGIN
              IF currChar <> ' ' THEN
                theWord := theWord + currChar
              ELSE BEGIN
                EndPos := i;
                EXIT(EndPos);
              END;
            END;
          END;
        END;

      END;

      EndPos := i;
    END;

    PROCEDURE WordAsDate@1000000020(Word@1000000000 : Text[1024];VAR theDate@1000000002 : Date) OK : Boolean;
    VAR
      tmpDate@1000000001 : Date;
      yearint@1000000003 : Integer;
      eJanuary@1000000004 : TextConst 'ENU=JANUARY;ENG=JANUARY';
      eJanuaryShort@1000000016 : TextConst 'ENU=JAN;ENG=JAN';
      eFebruary@1000000005 : TextConst 'ENU=FEBRUARY;ENG=FEBRUARY';
      eFebruaryShort@1000000017 : TextConst 'ENU=FEB;ENG=FEB';
      eMarch@1000000006 : TextConst 'ENU=MARCH;ENG=MARCH';
      eMarchShort@1000000018 : TextConst 'ENU=MAR;ENG=MAR';
      eApril@1000000007 : TextConst 'ENU=APRIL;ENG=APRIL';
      eAprilShort@1000000019 : TextConst 'ENU=APR;ENG=APR';
      eMay@1000000008 : TextConst 'ENU=MAY;ENG=MAY';
      eMayShort@1000000020 : TextConst 'ENU=MAY;ENG=MAY';
      eJune@1000000009 : TextConst 'ENU=JUNE;ENG=JUNE';
      eJuneShort@1000000021 : TextConst 'ENU=JUN;ENG=JUN';
      eJuly@1000000010 : TextConst 'ENU=JULY;ENG=JULY';
      eJulyShort@1000000022 : TextConst 'ENU=JUL;ENG=JUL';
      eAugust@1000000011 : TextConst 'ENU=AUGUST;ENG=AUGUST';
      eAugustShort@1000000023 : TextConst 'ENU=AUG;ENG=AUG';
      eSeptember@1000000012 : TextConst 'ENU=SEPTEMBER;ENG=SEPTEMBER';
      eSeptemberShort@1000000024 : TextConst 'ENU=SEP;ENG=SEP';
      eOctober@1000000013 : TextConst 'ENU=OCTOBER;ENG=OCTOBER';
      eOctoberShort@1000000025 : TextConst 'ENU=OCT;ENG=OCT';
      eNovember@1000000014 : TextConst 'ENU=NOVEMBER;ENG=NOVEMBER';
      eNovemberShort@1000000026 : TextConst 'ENU=NOV;ENG=NOV';
      eDecember@1000000015 : TextConst 'ENU=DECEMBER;ENG=DECEMBER';
      eDecemberShort@1000000027 : TextConst 'ENU=DEC;ENG=DEC';
    BEGIN
      IF EVALUATE(tmpDate,Word) THEN BEGIN
        theDate := tmpDate;
        EXIT(TRUE);
      END ELSE BEGIN
        EVALUATE(yearint,FORMAT(TODAY,0,'<Year4>'));

        CASE UPPERCASE(Word) OF
          eJanuary, eJanuaryShort:
          BEGIN
            theDate := DMY2DATE(1,1,yearint);
            EXIT(TRUE);
          END;
          eFebruary, eFebruaryShort:
          BEGIN
            theDate := DMY2DATE(1,2,yearint);
            EXIT(TRUE);
          END;
          eMarch, eMarchShort:
          BEGIN
            theDate := DMY2DATE(1,3,yearint);
            EXIT(TRUE);
          END;
          eApril, eAprilShort:
          BEGIN
            theDate := DMY2DATE(1,4,yearint);
            EXIT(TRUE);
          END;
          eMay, eMayShort:
          BEGIN
            theDate := DMY2DATE(1,5,yearint);
            EXIT(TRUE);
          END;
          eJune, eJuneShort:
          BEGIN
            theDate := DMY2DATE(1,6,yearint);
            EXIT(TRUE);
          END;
          eJuly, eJulyShort:
          BEGIN
            theDate := DMY2DATE(1,7,yearint);
            EXIT(TRUE);
          END;
          eAugust, eAugustShort:
          BEGIN
            theDate := DMY2DATE(1,8,yearint);
            EXIT(TRUE);
          END;
          eSeptember, eSeptemberShort:
          BEGIN
            theDate := DMY2DATE(1,9,yearint);
            EXIT(TRUE);
          END;
          eOctober, eOctoberShort:
          BEGIN
            theDate := DMY2DATE(1,10,yearint);
            EXIT(TRUE);
          END;
          eNovember, eNovemberShort:
          BEGIN
            theDate := DMY2DATE(1,11,yearint);
            EXIT(TRUE);
          END;
          eDecember, eDecemberShort:
          BEGIN
            theDate := DMY2DATE(1,12,yearint);
            EXIT(TRUE);
          END;

        END;
      END;
    END;

    PROCEDURE WordAsDateFilter@1000000018(theWord@1000000000 : Text[30];theDateFilter@1000000001 : Text[30]) OK : Boolean;
    VAR
      tmpDate@1000000002 : Date;
      fromDateText@1000000003 : Text[30];
      toDateText@1000000004 : Text[30];
      fromDate@1000000005 : Date;
      toDate@1000000006 : Date;
      isRange@1000000007 : Boolean;
    BEGIN
      IF STRPOS(theWord,'..') <> 0 THEN BEGIN
        isRange := TRUE;
        fromDateText := COPYSTR(theWord,1,STRPOS(theWord,'..')-1);
        toDateText := COPYSTR(theWord,STRPOS(theWord,'..')+2,STRLEN(theWord)-(STRPOS(theWord,'..')+1));
      END ELSE BEGIN
        isRange := FALSE;
        fromDateText := theWord;
      END;

      IF fromDateText <> '' THEN BEGIN
        IF NOT WordAsDate(fromDateText,fromDate) THEN
          EXIT(FALSE)
        ELSE
          theDateFilter := FORMAT(fromDate,0,'<Day,2>/<Month,2>/<Year4>');
      END;

      IF isRange THEN
        theDateFilter := theDateFilter + '..';

      IF toDateText <> '' THEN BEGIN
        IF NOT WordAsDate(toDateText,toDate) THEN
          EXIT(FALSE)
        ELSE
          theDateFilter := theDateFilter + FORMAT(toDate,0,'<Day,2>/<Month,2>/<Year4>');
      END;

      MESSAGE('date filter : %1',theDateFilter);
      EXIT(TRUE);
    END;

    PROCEDURE CharIsQuote@1000000017(theChar@1000000000 : Text[1]) : Boolean;
    VAR
      Quote@1000000001 : Text[1];
      OpenCurlyQuote@1000000002 : Text[1];
      CloseCurlyQuote@1000000003 : Text[1];
      OutlookQuote@1000000004 : Text[1];
      OutlookQuote2@1000000005 : Text[1];
    BEGIN
      Quote := '"';
      OpenCurlyQuote := 'Ã';
      CloseCurlyQuote := 'Ä';
      OutlookQuote := '“';
      OutlookQuote2 := '”';

      IF theChar = Quote THEN EXIT(TRUE);
      IF theChar = OpenCurlyQuote THEN EXIT(TRUE);
      IF theChar = CloseCurlyQuote THEN EXIT(TRUE);
      IF theChar = OutlookQuote THEN EXIT(TRUE);
      IF theChar = OutlookQuote2 THEN EXIT(TRUE);

      EXIT(FALSE);
    END;

    PROCEDURE GetPrimaryKey@1000000036(TableID@1000000000 : Integer;PositionText@1000000006 : Text[250];KeyNum@1000000001 : Integer) KeyValue : Text[250];
    VAR
      RecRef@1000000002 : RecordRef;
      FieldRef@1000000004 : FieldRef;
      KeyRef@1000000005 : KeyRef;
    BEGIN
      RecRef.OPEN(TableID);
      RecRef.SETPOSITION(PositionText);

      KeyRef := RecRef.KEYINDEX(1);
      IF KeyRef.FIELDCOUNT < KeyNum THEN EXIT('');
      FieldRef := KeyRef.FIELDINDEX(KeyNum);
      IF UPPERCASE(FORMAT(FieldRef.TYPE)) = 'OPTION' THEN
        EXIT(FORMAT(FieldRef.VALUE,0,'<Number>'))
      ELSE
        EXIT(FORMAT(FieldRef.VALUE));
    END;

    PROCEDURE GetPrimaryKeyFieldID@1000000025(TableID@1000000000 : Integer;PositionText@1000000006 : Text[250];KeyNum@1000000001 : Integer) FieldID : Integer;
    VAR
      RecRef@1000000002 : RecordRef;
      FieldRef@1000000004 : FieldRef;
      KeyRef@1000000005 : KeyRef;
    BEGIN
      RecRef.OPEN(TableID);
      IF PositionText <> '' THEN RecRef.SETPOSITION(PositionText);

      KeyRef := RecRef.KEYINDEX(1);
      IF KeyRef.FIELDCOUNT < KeyNum THEN EXIT(0);
      FieldRef := KeyRef.FIELDINDEX(KeyNum);
      EXIT(FieldRef.NUMBER);
    END;

    PROCEDURE IsPrimaryKey@1000000048(TableNo@1000000000 : Integer;FieldNo@1000000001 : Integer) : Boolean;
    VAR
      RecRef@1000000004 : RecordRef;
      FieldRef@1000000003 : FieldRef;
      KeyRef@1000000002 : KeyRef;
      i@1000000005 : Integer;
    BEGIN
      RecRef.OPEN(TableNo);
      KeyRef := RecRef.KEYINDEX(1);

      i := 1;
      REPEAT
        FieldRef := KeyRef.FIELDINDEX(i);
        IF FieldRef.NUMBER = FieldNo THEN EXIT(TRUE);
        i += 1;
      UNTIL i >= KeyRef.FIELDCOUNT;
      EXIT(FALSE);
    END;

    PROCEDURE CalcNumPeriods@1000000021(StartDate@1000000006 : Date;PeriodSize@1000000004 : DateFormula;LengthOfTime@1000000005 : DateFormula) : Integer;
    VAR
      EndDate@1000000003 : Date;
      SalesHeader@1000000001 : Record 36;
      i@1000000000 : Integer;
    BEGIN
      EndDate := CALCDATE(LengthOfTime,StartDate)-1;
      i := 0;
      REPEAT
        i += 1;
        StartDate := CALCDATE(PeriodSize,StartDate);
      UNTIL StartDate > EndDate;
      EXIT(i);
    END;

    PROCEDURE FAttachToEmail@1000000022();
    BEGIN
    END;

    PROCEDURE IsMyAutoNAVTask@1000000024(TaskCode@1000000000 : Code[20]) : Boolean;
    BEGIN
      EXIT(TRUE);
    END;

    PROCEDURE GetFieldIDFromName@1000000038(TableID@1000000001 : Integer;FieldName@1000000000 : Text[50]) ID : Integer;
    VAR
      RecRef@1000000002 : RecordRef;
      FieldRef@1000000003 : FieldRef;
      i@1000000004 : Integer;
    BEGIN
      RecRef.OPEN(TableID);
      i := 1;

      REPEAT
        FieldRef := RecRef.FIELDINDEX(i);
        IF UPPERCASE(FieldRef.NAME) = UPPERCASE(FieldName) THEN BEGIN
          EXIT(FieldRef.NUMBER);
        END;
        i += 1;
      UNTIL i > RecRef.FIELDCOUNT;
      EXIT(0);
    END;

    PROCEDURE KillWindowsProcess@1000000035(ImageName@1000000000 : Text[100]) KilledProcesses : Boolean;
    VAR
      wSHShell@1000000002 : Automation "{F935DC20-1CF0-11D0-ADB9-00C04FD58A0B} 1.0:{72C24DD5-D70A-438B-8A42-98424B88AFB8}:'Windows Script Host Object Model'.WshShell";
      runModally@1000000001 : Boolean;
      dummyInt@1000000003 : Integer;
      resultInt@1000000004 : Integer;
    BEGIN
      CREATE(wSHShell,TRUE,TRUE);
      runModally := TRUE;
      dummyInt := 0;
      EVALUATE(resultInt,FORMAT(wSHShell.Run('taskkill /FI "USERNAME eq ' + USERID + '" /IM ' + ImageName + ' /F',dummyInt,runModally)));
      CLEAR(wSHShell);
      EXIT(resultInt = 0);
    END;

    PROCEDURE SplitText@1000000005(OrigText@1000000000 : Text;MaxStringLen@1000000007 : Integer;VAR OutputText1@1000000001 : Text[1024];VAR OutputText2@1000000002 : Text[1024];VAR OutputText3@1000000003 : Text[1024];VAR OutputText4@1000000004 : Text[1024];VAR OutputText5@1000000006 : Text[1024]);
    VAR
      OrigLen@1000000005 : Integer;
    BEGIN
      OrigLen := STRLEN(OrigText);

      IF OrigLen > 0 THEN OutputText1 := COPYSTR(OrigText,1,MaxStringLen);
      IF OrigLen > MaxStringLen THEN OutputText2 := COPYSTR(OrigText,MaxStringLen+1,MaxStringLen);
      IF OrigLen > (MaxStringLen * 2) THEN OutputText3 := COPYSTR(OrigText,(MaxStringLen*2)+1,MaxStringLen);
      IF OrigLen > (MaxStringLen * 3) THEN OutputText4 := COPYSTR(OrigText,(MaxStringLen*3)+1,MaxStringLen);
      IF OrigLen > (MaxStringLen * 4) THEN OutputText5 := COPYSTR(OrigText,(MaxStringLen*4)+1,MaxStringLen);
    END;

    PROCEDURE SetFieldValueFromText@1000000013(VAR FieldRef@1000000000 : FieldRef;SetToText@1000000001 : Text;Validate@1000000009 : Boolean) OK : Boolean;
    VAR
      eBool@1000000011 : TextConst 'ENU=Cannot set Boolean field using value ''%1'';ENG=Cannot set Boolean field using value ''%1''';
      lOldValue@1000000002 : Variant;
      lNewValue@1000000003 : Variant;
      lResult@1000000021 : Boolean;
    BEGIN
      lOldValue := FieldRef.VALUE;
      IF (RecordRefManagement.FieldRefIsNormalField(FieldRef)) THEN
      BEGIN
        RecordRefManagement.TextToFieldRefAdv(SetToText, Validate, FieldRef);
        lNewValue := FieldRef.VALUE;
        lResult := ( NOT (Convert.AreVariantsEqual(lOldValue, lNewValue)));
      END
      ELSE
        lResult := FALSE;
      EXIT(lResult);
    END;

    PROCEDURE ReplaceRecFieldsInText@1000000061(pText@1000000000 : Text[1024];pTableId@1000000001 : Integer;pRec@1000000002 : Variant) : Text[1024];
    VAR
      lPattern@1000000004 : ARRAY [2] OF Text[250];
      lPatternIndex@1000000005 : Integer;
      lRegex@1000000003 : DotNet "'System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.RegularExpressions.Regex";
      lMatching@1000000006 : Boolean;
      lMatch@1000000007 : DotNet "'System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.RegularExpressions.Match";
      lGroupCollection@1000000008 : DotNet "'System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.RegularExpressions.GroupCollection";
      lGroup@1000000009 : ARRAY [4] OF DotNet "'System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.RegularExpressions.Group";
      lGroupIndex@1000000015 : ' ,Start,Function,Field,Finish';
      lGroupText@1000000012 : Text[250];
      lText@1000000011 : Text[1024];
      lRecordRef@1000000010 : RecordRef;
      lFieldRef@1000000013 : FieldRef;
      lField@1000000014 : Record 2000000041;
      lFieldValue@1000000019 : Text[250];
      lProcess@1000000018 : Boolean;
      lFunctionPresent@1000000017 : Boolean;
      lFunction@1000000016 : ' ,Null';
      lFieldRefTools@1000000020 : Codeunit 9062241;
    BEGIN
      //DOC NA2015.1 - Replacing "Rec" fields in text
      //  "Rec" fields in the text can be coded in two ways: 1) As 'Rec."Field Name"', 2) As 'Rec.[Field Name]'
      //  -> pText: Text to replace fields in
      //  -> pTableId: Table identifier
      //  -> pRec: The record
      //  <- Text with fields replaced

      lPattern[1] := '(.*)(null|NULL|Null)\(Rec.["\[](.*)["\]]\)(.*)';
      lPattern[2] := '(.*)Rec.["\[](.*)["\]](.*)';

      lRecordRef.OPEN(pTableId);
      lRecordRef.GETTABLE(pRec);

      FOR lPatternIndex := 1 TO ARRAYLEN(lPattern) DO
      BEGIN
        lRegex := lRegex.Regex(lPattern[lPatternIndex]);
        lMatching := TRUE;
        WHILE (lMatching) DO
        BEGIN
          lMatch := lRegex.Match(pText);
          IF (lMatch.Success) THEN
          BEGIN
            lGroupCollection := lMatch.Groups;
            CASE (lGroupCollection.Count) OF
              4:
                BEGIN
                  lGroup[lGroupIndex::Start] := lGroupCollection.Item(1);
                  lGroup[lGroupIndex::Field] := lGroupCollection.Item(2);
                  lGroup[lGroupIndex::Finish] := lGroupCollection.Item(3);
                  lFunctionPresent := FALSE;
                  lProcess := TRUE;
                END;
              5:
                BEGIN
                  lGroup[lGroupIndex::Start] := lGroupCollection.Item(1);
                  lGroup[lGroupIndex::"Function"] := lGroupCollection.Item(2);
                  lGroup[lGroupIndex::Field] := lGroupCollection.Item(3);
                  lGroup[lGroupIndex::Finish] := lGroupCollection.Item(4);
                  lFunctionPresent := TRUE;
                  lProcess := TRUE;
                END;
            END;
            IF (lProcess) THEN
            BEGIN
              lText := lText + lGroup[lGroupIndex::Start].Value;
              IF (lFunctionPresent) THEN
                CASE (LOWERCASE(lGroup[lGroupIndex::"Function"].Value)) OF
                  'null':
                    lFunction := lFunction::Null;
                  ELSE
                    lFunction := lFunction::" ";
                END;
              lGroupText := lGroup[lGroupIndex::Field].Value;
              lField.RESET();
              lField.SETRANGE(TableNo, pTableId);
              lField.SETFILTER(FieldName, '@' + lGroupText);
              IF ((lField.FINDFIRST()) AND (lRecordRef.FIELDEXIST(lField."No."))) THEN
              BEGIN
                lFieldRef := lRecordRef.FIELD(lField."No.");
                CASE (lFunction) OF
                  lFunction::Null:
                    IF (lFieldRefTools.FieldRefValueIsEmpty(lFieldRef)) THEN
                      lFieldValue := '0&1'
                    ELSE
                      lFieldValue := FORMAT(lFieldRef.VALUE);
                  ELSE
                    lFieldValue := FORMAT(lFieldRef.VALUE);
                END;
                lText := lText + lFieldValue;
              END;
              lText := lText + lGroup[lGroupIndex::Finish].Value;
              pText := lText;
            END;
          END
          ELSE
            lMatching := FALSE;
        END;
      END;

      lRecordRef.CLOSE();

      EXIT(pText);
    END;

    PROCEDURE GetRecFieldFunctionHelpMsg@1000000062();
    VAR
      lNameValueBufferTmp@1000000001 : TEMPORARY Record 9062730;
      lMessage@1000000000 : Text;
      lTextToAdd@1000000002 : Text[1024];
    BEGIN
      FillRecFieldFunctionBuffer(TRUE, lNameValueBufferTmp);
      IF (lNameValueBufferTmp.FINDSET()) THEN
      REPEAT
        IF ((lNameValueBufferTmp.Name <> '') AND (lNameValueBufferTmp.Value <> '')) THEN
          lTextToAdd := STRSUBSTNO('%1: %2', lNameValueBufferTmp.Name, lNameValueBufferTmp.Value)
        ELSE IF ((lNameValueBufferTmp.Name = '') AND (lNameValueBufferTmp.Value <> '')) THEN
          lTextToAdd := STRSUBSTNO('  ' + lNameValueBufferTmp.Value)
        ELSE
          lTextToAdd := lNameValueBufferTmp.Name;
        IF (lMessage <> '') THEN
          lMessage := lMessage + '\';
        lMessage := lMessage + lTextToAdd;
      UNTIL (lNameValueBufferTmp.NEXT() = 0);

      MESSAGE(lMessage);
    END;

    PROCEDURE GetRecFieldFunctionLookup@1000000066(VAR pValue@1000000000 : Text[250]) : Boolean;
    VAR
      lNameValueBufferTmp@1000000001 : TEMPORARY Record 9062730;
      lResult@1000000002 : Boolean;
    BEGIN
      //DOC NA2015.1 - Performing a lookup for "Rec" field functions
      //  <> pValue: Source / target value
      //  <- Lookup result

      FillRecFieldFunctionBuffer(FALSE, lNameValueBufferTmp);
      IF (pValue <> '') THEN
      BEGIN
        lNameValueBufferTmp.SETRANGE(Name, pValue);
        IF (lNameValueBufferTmp.FINDFIRST()) THEN;
        lNameValueBufferTmp.SETRANGE(Name);
      END;
      IF (NameValueToolkit.NameValueLookup(lNameValueBufferTmp, TRUE)) THEN
      BEGIN
        pValue := lNameValueBufferTmp.Name;
        lResult := TRUE;
      END;

      EXIT(lResult);
    END;

    PROCEDURE FillRecFieldFunctionBuffer@1000000063(pDescriptiveLines@1000000003 : Boolean;VAR pNameValueBuffer@1000000000 : Record 9062730);
    VAR
      lNameValueBufferTmp@1000000001 : TEMPORARY Record 9062730;
      lId@1000000002 : Integer;
      eHeader@1000000004 : TextConst 'ENU=The following functions can be used with "Rec" fields;ENG=The following functions can be used with "Rec" fields';
      eNull@1000000005 : TextConst 'ENU=If the "Rec" field is empty - it applies "show me nothing" filter (like 0&1);ENG=If the "Rec" field is empty - it applies "show me nothing" filter (like 0&1)';
    BEGIN
      //DOC NA2015.1 - Filling "Rec" field functions buffer
      //  -> pDescriptiveLines: TRUE: add descriptive lines, FALSE: only value lines
      //  <> pNameValueBuffer: The buffer
      //  There are 3 scenarios of lines in the buffer:
      //   - Name is not empty and Value is not empty - the line will be added as Name + ': ' + Value,
      //   - Name is empty and Value is not empty - the line will be added as '  ' + Value (indented),
      //   - Otherwise - the line will be added as Name only.
      //  Use "NameValueToolkit.AddToNameValueBuffer" to add lines with name only and "NameValueToolkit.AddToNameValueBufferV" to add lins with name and value

      IF (pDescriptiveLines) THEN
      BEGIN
        NameValueToolkit.AddToNameValueBuffer(pNameValueBuffer, TNPToolkit.Inc(lId), eHeader + ':');
        NameValueToolkit.AddToNameValueBuffer(pNameValueBuffer, TNPToolkit.Inc(lId), '');
      END;
      NameValueToolkit.AddToNameValueBufferV(pNameValueBuffer, TNPToolkit.Inc(lId), 'NULL', eNull);

      IF (pNameValueBuffer.FINDFIRST()) THEN;
    END;

    PROCEDURE AddCSStoBigText@1000000015(VAR BodyHTML@1000000000 : BigText);
    BEGIN
      BodyHTML.ADDTEXT('<style type="text/css"><!--');
      BodyHTML.ADDTEXT('body {');
      BodyHTML.ADDTEXT('  font-family:Verdana;');
      BodyHTML.ADDTEXT('  font-size:12px;');
      BodyHTML.ADDTEXT('}');
      BodyHTML.ADDTEXT('table.wikitable {');
      BodyHTML.ADDTEXT('    background: #f9f9f9;');
      BodyHTML.ADDTEXT('    border: 1px #aaa solid;');
      BodyHTML.ADDTEXT('    border-collapse: collapse;');
      BodyHTML.ADDTEXT('    border-spacing: 0px 0px;');
      BodyHTML.ADDTEXT('}');
      BodyHTML.ADDTEXT('.wikitable th, .wikitable td {');
      BodyHTML.ADDTEXT('    border: 1px #aaa solid;');
      BodyHTML.ADDTEXT('    padding: 0.2em;');
      BodyHTML.ADDTEXT('}');
      BodyHTML.ADDTEXT('.wikitable th {');
      BodyHTML.ADDTEXT('    background: #f2f2f2;');
      BodyHTML.ADDTEXT('    text-align: center;');
      BodyHTML.ADDTEXT('}');
      BodyHTML.ADDTEXT('.wikitable caption {');
      BodyHTML.ADDTEXT('    font-weight: bold;');
      BodyHTML.ADDTEXT('}');
      BodyHTML.ADDTEXT('--></style>');
    END;

    PROCEDURE MakeValidFilename@1000000032(VAR FileName@1000000000 : Text[1024]);
    VAR
      Regex@1000000001 : DotNet "'System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.RegularExpressions.Regex";
      SysIOPath@1000000003 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.Path";
      SysString@1000000006 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.String";
      InvalidChars@1000000002 : Text[1024];
      InvalidCharsRegE@1000000005 : Text[1024];
    BEGIN
      InvalidChars := Regex.Escape(SysString.String(SysIOPath.GetInvalidFileNameChars));
      InvalidCharsRegE := SysString.Format('([{0}]*\.+$)|([{0}]+)',InvalidChars);
      FileName := Regex.Replace(FileName,InvalidCharsRegE,'_');
    END;

    PROCEDURE Util_XMLDateToDateAndTime@1000000033(XMLDate@1000000000 : Text[30];VAR theDate@1000000001 : Date;VAR theTime@1000000002 : Time;ConvertFromUTCtoLocal@1000000013 : Boolean);
    VAR
      DateTime_Local@1000000004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.DateTime";
      DateTime_Local_PossDL@1000000006 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.DateTime";
      DateTime_UTC@1000000003 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.DateTime";
      NAVDateTime@1000000005 : DateTime;
      TimeZoneInfo@1000000009 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.TimeZoneInfo";
      TimeZone@1000000007 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.TimeZone";
      DateTimeKind@1000000008 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.DateTimeKind";
      DateString@1000000010 : Text[20];
      TimeString@1000000011 : Text[20];
      OneHour@1000000012 : Duration;
      XMLConvert@1000000015 : DotNet "'System.Xml, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Xml.XmlConvert";
    BEGIN
      IF XMLDate = '' THEN BEGIN
        theDate := 0D;
        theTime := 0T;
        EXIT;
      END;

      IF ConvertFromUTCtoLocal THEN BEGIN
        TimeZoneInfo := TimeZoneInfo.Local;
        DateTime_UTC := XMLConvert.ToDateTime(XMLDate);

        DateTime_Local := DateTime_Local.DateTime(DateTime_UTC.Ticks,DateTimeKind.Local);

        NAVDateTime := DateTime_Local;
        theDate := DT2DATE(NAVDateTime);
        theTime := DT2TIME(NAVDateTime);

        DateTime_UTC := DateTime_UTC.DateTime(DateTime_UTC.Ticks,DateTimeKind.Utc);

        DateTime_Local_PossDL := DateTime_UTC.AddHours(1);
        DateTime_Local_PossDL := DateTime_Local_PossDL.DateTime(DateTime_UTC.Ticks,DateTimeKind.Local);

        IF DateTime_Local_PossDL.IsDaylightSavingTime THEN BEGIN
          EVALUATE(OneHour,'1H');
          NAVDateTime := NAVDateTime + OneHour;
          theDate := DT2DATE(NAVDateTime);
          theTime := DT2TIME(NAVDateTime);
        END;
      END ELSE BEGIN
        DateTime_Local := XMLConvert.ToDateTime(XMLDate);
        NAVDateTime := DateTime_Local;
        theDate := DT2DATE(NAVDateTime);
        theTime := DT2TIME(NAVDateTime);
      END;
    END;

    PROCEDURE FindRecordFromText@1000000034(VAR DestRecRef@1000000000 : RecordRef;FieldID@1000000002 : Integer;SearchInText@1000000003 : Text[1024]) Found : Boolean;
    VAR
      FieldRef@1000000004 : FieldRef;
      TextMgt@1000000005 : Codeunit 9062247;
      Skip@1000000006 : Boolean;
      CurrWord@1000000007 : Text[1024];
      FilterText@1000000008 : Text[250];
    BEGIN
      FieldRef := DestRecRef.FIELD(FieldID);

      TextMgt.SetSpaceCharacters(' |.','|');
      TextMgt.SetString(SearchInText);

      CurrWord := TextMgt.GetNextWord;
      IF CurrWord <> '' THEN BEGIN
        REPEAT
          Skip := FALSE;
          FilterText := CreateFilterString(DestRecRef.NUMBER,FieldID,COPYSTR(CurrWord,1,250));
          IF FilterText <> '' THEN BEGIN
            FieldRef.SETFILTER(FilterText);
            IF DestRecRef.FINDFIRST THEN EXIT(TRUE);
          END;

          CurrWord := TextMgt.GetNextWord;
        UNTIL (CurrWord = '');
      END;

      EXIT(FALSE);
    END;

    PROCEDURE CreateFilterString@1000000040(TableID@1000000000 : Integer;FieldID@1000000001 : Integer;FilterText@1000000002 : Text[250]) NewFilterText : Text[250];
    VAR
      RecRef@1000000003 : RecordRef;
      FieldRef@1000000004 : FieldRef;
      FilterTextDec@1000000005 : Decimal;
      FilterTextInt@1000000006 : Integer;
      FilterTextDate@1000000007 : Date;
      FilterTextTime@1000000008 : Time;
      FilterTextBool@1000000009 : Boolean;
    BEGIN
      RecRef.OPEN(TableID);
      FieldRef := RecRef.FIELD(FieldID);

      CASE FORMAT(FieldRef.TYPE) OF
        'Option','Integer' : IF EVALUATE(FilterTextInt,FilterText) THEN EXIT(FORMAT(FilterTextInt));
        'Decimal' : IF EVALUATE(FilterTextDec,FilterText) THEN EXIT(FORMAT(FilterTextDec));
        'Date' : IF EVALUATE(FilterTextDate,FilterText) THEN EXIT(FORMAT(FilterTextDate));
        'Time' : IF EVALUATE(FilterTextTime,FilterText) THEN EXIT(FORMAT(FilterTextTime));
        'Boolean' : IF EVALUATE(FilterTextBool,FilterText) THEN EXIT(FORMAT(FilterTextBool));
        ELSE EXIT(String.Replace(COPYSTR(FilterText,1,FieldRef.LENGTH),'@','?'));
      END;
    END;

    PROCEDURE SetFiltersFromFilterText@1000000041(VAR RecRef@1000000000 : RecordRef;ViewText@1000000001 : Text);
    VAR
      RecRef2@1000000006 : RecordRef;
      FieldRef@1000000002 : FieldRef;
      FieldRef2@1000000007 : FieldRef;
      i@1000000003 : Integer;
    BEGIN
      RecRef2.OPEN(RecRef.NUMBER);
      RecRef2.SETVIEW(ViewText);

      i := 1;
      REPEAT
        FieldRef2 := RecRef2.FIELDINDEX(i);
        IF FieldRef2.GETFILTER <> '' THEN BEGIN
          FieldRef := RecRef.FIELD(FieldRef2.NUMBER);
          FieldRef.SETFILTER(FieldRef2.GETFILTER);
        END;
        i += 1;
      UNTIL i >= RecRef2.FIELDCOUNT;
    END;

    PROCEDURE GetPositionTextUsingPrimaryKeyValues@1000000042(TableNo@1000000000 : Integer;PrimaryKeyValue1@1000000001 : Text[250];PrimaryKeyValue2@1000000002 : Text[250];PrimaryKeyValue3@1000000003 : Text[250];PrimaryKeyValue4@1000000004 : Text[250];PrimaryKeyValue5@1000000005 : Text[250]) PositionText : Text;
    VAR
      RecRef@1000000006 : RecordRef;
      FieldRef@1000000007 : FieldRef;
    BEGIN
      RecRef.OPEN(TableNo);
      IF PrimaryKeyValue1 <> '' THEN BEGIN
        FieldRef := RecRef.FIELD(GetPrimaryKeyFieldID(TableNo,'',1));
        FieldRef.SETFILTER(PrimaryKeyValue1);
      END;

      IF PrimaryKeyValue2 <> '' THEN BEGIN
        FieldRef := RecRef.FIELD(GetPrimaryKeyFieldID(TableNo,'',2));
        FieldRef.SETFILTER(PrimaryKeyValue2);
      END;

      IF PrimaryKeyValue3 <> '' THEN BEGIN
        FieldRef := RecRef.FIELD(GetPrimaryKeyFieldID(TableNo,'',3));
        FieldRef.SETFILTER(PrimaryKeyValue3);
      END;

      IF PrimaryKeyValue4 <> '' THEN BEGIN
        FieldRef := RecRef.FIELD(GetPrimaryKeyFieldID(TableNo,'',4));
        FieldRef.SETFILTER(PrimaryKeyValue4);
      END;

      IF PrimaryKeyValue5 <> '' THEN BEGIN
        FieldRef := RecRef.FIELD(GetPrimaryKeyFieldID(TableNo,'',5));
        FieldRef.SETFILTER(PrimaryKeyValue5);
      END;

      IF RecRef.FINDFIRST THEN
        IF RecRef.COUNT = 1 THEN EXIT(RecRef.GETPOSITION) ELSE EXIT('')
      ELSE EXIT('');
    END;

    PROCEDURE FindArrayEntryInText@1000000044(FindInText@1000000000 : Text[1024];ValuesArray@1000000001 : ARRAY [10000] OF Text[1024];KeysArray@1000000002 : ARRAY [10000] OF Text[1024]) FoundKey : Text[1024];
    VAR
      i@1000000003 : Integer;
      CurrKey@1000000004 : Text[1024];
    BEGIN
      IF FindInText = '' THEN EXIT('');

      i := 1;
      CurrKey := '';
      REPEAT
        CurrKey := KeysArray[i];
        IF CurrKey <> '' THEN BEGIN
          IF STRPOS(FindInText,ValuesArray[i]) <> 0 THEN EXIT(CurrKey);
        END;

        i += 1;
      UNTIL (i > 10000) OR (CurrKey = '');
    END;

    PROCEDURE QuestionDialogue@1000000045(QuestionText@1000000000 : Text[250];VAR AnswerText@1000000001 : Text[250]) OK : Boolean;
    VAR
      QuestionPage@1000000002 : Page 9062248;
    BEGIN
      CLEAR(QuestionPage);
      QuestionPage.SetQuestion(QuestionText);
      IF QuestionPage.RUNMODAL = ACTION::Cancel THEN EXIT(FALSE);
      AnswerText := QuestionPage.GetAnswer;
      EXIT(TRUE);
    END;

    PROCEDURE ConcatenateFieldValues@1000000046(Formula@1000000000 : Text[1024];RecRef@1000000005 : RecordRef) Output : Text[1024];
    VAR
      TP@1000000001 : Codeunit 9062247;
      CurrWord@1000000002 : Text[1024];
      FieldName@1000000003 : Text[1024];
      TxtBlankFieldNameRef@1000000006 : TextConst 'ENU=A blank field name reference was found in the formula "%1";ENG=A blank field name reference was found in the formula "%1"';
      OpenBracket@1000000004 : TextConst 'ENU=[;ENG=[';
      CloseBracket@1000000007 : TextConst 'ENU=];ENG=]';
      OpenBracketPos@1000000008 : Integer;
      CloseBracketPos@1000000009 : Integer;
    BEGIN
      OpenBracketPos  := STRPOS(Formula,OpenBracket);
      CloseBracketPos := STRPOS(Formula,CloseBracket);
      Output := Formula;

      WHILE (OpenBracketPos > 0) AND (CloseBracketPos > 0) DO BEGIN
        FieldName := COPYSTR(Output,(OpenBracketPos + 1), (CloseBracketPos - OpenBracketPos)-1);
        Output   := String.Replace(Output,(OpenBracket + FieldName + CloseBracket),GetFieldValue(RecRef,FieldName));
        OpenBracketPos  := STRPOS(Output,OpenBracket);
        CloseBracketPos := STRPOS(Output,CloseBracket);
      END;
    END;

    PROCEDURE GetFieldValue@1000000050(VAR RecRef@1000000000 : RecordRef;FieldName@1000000001 : Text[50]) FieldValue : Text[250];
    VAR
      FieldRef@1000000002 : FieldRef;
      Fields@1000000003 : Record 2000000041;
      tmpDecimal@1000000004 : Decimal;
      EnhFieldDef@1000000005 : Record 9062327;
      EnhFieldVal@1000000006 : Record 9062328;
      PositionText@1000000007 : Text[250];
      EnhFieldMgt@1000000009 : Codeunit 9062298;
    BEGIN
      RecRef.GET(RecRef.RECORDID);

      //Is it a number?
      IF EVALUATE(tmpDecimal,FieldName) THEN EXIT(FieldName);

      FieldName := String.Replace(FieldName,'"','');
      FieldName := String.Replace(FieldName,'[','');
      FieldName := String.Replace(FieldName,']','');

      //Check for real field
      Fields.SETRANGE(TableNo,RecRef.NUMBER);
      Fields.SETRANGE(FieldName,FieldName);
      IF Fields.FINDFIRST THEN BEGIN
        CLEAR(FieldRef);
        FieldRef := RecRef.FIELD(Fields."No.");
        IF Fields.Class = Fields.Class::FlowFilter THEN EXIT(FieldRef.GETFILTER);
        IF Fields.Class = Fields.Class::FlowField THEN FieldRef.CALCFIELD;

        EXIT(FORMAT(FieldRef.VALUE));
      END;

      //Check for Enhanced Field
      IF EnhFieldDef.READPERMISSION THEN BEGIN
        EnhFieldDef.SETRANGE("Table No.",RecRef.NUMBER);
        EnhFieldDef.SETRANGE(Name,FieldName);
        IF EnhFieldDef.FINDFIRST THEN BEGIN
          EXIT(EnhFieldMgt.CalculateFieldValue(EnhFieldDef."Table No.",EnhFieldDef."Enhanced Field No.",RecRef.GETPOSITION));
        END;
      END;
    END;

    PROCEDURE GetFieldValue_Simple@1000000073(TableNo@1000000000 : Integer;PositionText@1000000001 : Text;FieldName@1000000002 : Text) FieldValue : Text;
    VAR
      RecRef@1000000003 : RecordRef;
    BEGIN
      IF TableNo = 0 THEN EXIT;
      IF PositionText = '' THEN EXIT;
      RecRef.OPEN(TableNo);
      RecRef.SETPOSITION(PositionText);
      EXIT(GetFieldValue(RecRef,FieldName));
    END;

    PROCEDURE RunClassicForm@1000000047(ObjID@1000000000 : Code[30];RecordID@1000000001 : Code[30]) Boolean : Boolean;
    VAR
      SysBehv@1000000002 : Record 9062230;
      NAVCLASICHYPERLINK@1000000003 : TextConst 'ENU="navision://client/run?servername=cs01%26database=Historical_Internal_System%26company=Touchstone%20NAV%20Ltd.%26target=Form%20OBJID%26view=SORTING(Field1)%26position=Field1=0(RECORDID)%26servertype=MSSQL";ENG="navision://client/run?servername=cs01%26database=Historical_Internal_System%26company=Touchstone%20NAV%20Ltd.%26target=Form%20OBJID%26view=SORTING(Field1)%26position=Field1=0(RECORDID)%26servertype=MSSQL"';
      Link@1000000004 : Text;
      ObjIDTxt@1000000005 : Text;
    BEGIN
      Link :=  String.Replace(NAVCLASICHYPERLINK,'RECORDID',RecordID);
      Link :=  String.Replace(Link,'OBJID',COPYSTR(FORMAT(ObjID),6));

      HYPERLINK(Link);
    END;

    PROCEDURE ParseMethodCallText@1000000049(CallText@1000000000 : Text;VAR MethodName@1000000001 : Text;VAR Params@1000000002 : ARRAY [100] OF Text) NumParams : Integer;
    VAR
      i@1000000003 : Integer;
      CurrParam@1000000004 : Integer;
      CurrChar@1000000005 : Text[1];
    BEGIN
      IF STRLEN(CallText) = 0 THEN EXIT;

      CurrParam := 0;
      i := 1;
      REPEAT
        CurrChar := COPYSTR(CallText,i,1);
        IF CurrParam = 0 THEN BEGIN
          IF CurrChar <> '(' THEN
            MethodName += CurrChar
          ELSE
            CurrParam += 1;
        END ELSE BEGIN
          IF CurrChar = ',' THEN
            CurrParam +=1
          ELSE BEGIN
            IF CurrChar = ')' THEN
              EXIT(CurrParam)
            ELSE Params[CurrParam] += CurrChar;
          END;
        END;
        i += 1;
      UNTIL i > STRLEN(CallText);
      EXIT(CurrParam);
    END;

    PROCEDURE ClearFieldRef@1000000051(VAR pFieldRef@1000000000 : FieldRef;pWithValidation@1000000001 : Boolean);
    VAR
      lEmptyDateFormula@1000000002 : DateFormula;
      lEmptyDuration@1000000003 : Duration;
      lEmptyGuid@1000000004 : GUID;
      lEmptyRecordId@1000000005 : RecordID;
    BEGIN
      //DOC NA2015.1 - Clearing field reference
      //  <> pFieldRef: The FieldRef to clear
      //  -> pWithValidation: TRUE = call validation, FALSE = assign value only

      CASE (LOWERCASE(FORMAT(pFieldRef.TYPE))) OF
        'boolean':
          pFieldRef.VALUE := FALSE;
        'biginteger', 'decimal', 'integer', 'option':
          pFieldRef.VALUE := 0;
        'code', 'text':
          pFieldRef.VALUE := '';
        'date':
          pFieldRef.VALUE := 0D;
        'time':
          pFieldRef.VALUE := 0T;
        'datetime':
          pFieldRef.VALUE := 0DT;
        'dateformula':
          pFieldRef.VALUE := lEmptyDateFormula;
        'duration':
          pFieldRef.VALUE := lEmptyDuration;
        'guid':
          pFieldRef.VALUE := lEmptyGuid;
        'recordid':
          pFieldRef.VALUE := lEmptyRecordId;
      END;

      IF (pWithValidation) THEN
        pFieldRef.VALIDATE();
    END;

    PROCEDURE GetRecordPosition@1000000011(Record@1000000000 : Variant) Position : Text;
    VAR
      RecRef@1000000001 : RecordRef;
    BEGIN
      IF NOT Record.ISRECORD THEN ERROR('The Item passed to this function is not a Record');

      RecRef.GETTABLE(Record);
      EXIT(RecRef.GETPOSITION);
    END;

    PROCEDURE GetRecordRecRef@1000000067(Record@1000000000 : Variant;VAR RecRef@1000000001 : RecordRef);
    BEGIN
      IF NOT Record.ISRECORD THEN ERROR('The Item passed to this function is not a Record');
      RecRef.GETTABLE(Record);
    END;

    PROCEDURE FieldValue@1000000065(Record@1000000000 : Variant;FieldName@1000000001 : Text[50]) FieldValue : Text[250];
    VAR
      RecRef@1000000002 : RecordRef;
    BEGIN
      GetRecordRecRef(Record,RecRef);
      EXIT(GetFieldValue(RecRef,FieldName));
    END;

    PROCEDURE TestFieldValue@1000000068(Record@1000000000 : Variant;FieldName@1000000001 : Text[50];CheckForValue@1000000002 : Text[250];ErrorIfDifferent@1000000004 : Boolean;ErrorMessageIfDifferent@1000000003 : Text) IsSame : Boolean;
    VAR
      ActualValue@1000000005 : Text;
      tErrorMsg@1000000006 : TextConst 'ENU=The value of the Field "%1" is "%2", not "%3";ENG=The value of the Field "%1" is "%2", not "%3"';
    BEGIN
      //DOC PC NA2015.1 >>
      //For "ErrorMessageOnDifferent" parameter:
      // %1 = FieldName
      // %2 = Actual Value
      // %3 = CheckForValue

      IF ErrorMessageIfDifferent = '' THEN ErrorMessageIfDifferent := tErrorMsg;

      ActualValue := FieldValue(Record,FieldName);
      IF ActualValue = CheckForValue THEN
        EXIT(TRUE)
      ELSE BEGIN
        IF NOT ErrorIfDifferent THEN EXIT(FALSE);
        ERROR(ErrorMessageIfDifferent,FieldName,ActualValue,CheckForValue);
      END;
    END;

    PROCEDURE GetRecordNo@1000000023(pTableId@1000000000 : Integer;pPosition@1000000001 : Text) : Code[20];
    VAR
      lRecordNo@1000000002 : Code[20];
      lSearching@1000000003 : Boolean;
      lRecordRef@1000000004 : RecordRef;
      lFieldRef@1000000005 : FieldRef;
      lFields@1000000008 : Integer;
      lFieldIndex@1000000006 : Integer;
      lField@1000000007 : Record 2000000041;
    BEGIN
      //DOC NA2016.12 - Returning record no. (for workflows, but here as general function)
      //  -> pTableId: Table ID
      //  -> pPosition: Position
      //  <- Record no.

      lRecordNo := '';

      IF ((pTableId <> 0) AND (pPosition <> '')) THEN
      BEGIN
        lRecordRef.OPEN(pTableId);
        lRecordRef.SETPOSITION(pPosition);
        lRecordRef.SETRECFILTER();
        IF ( NOT (lRecordRef.FINDFIRST())) THEN
          lRecordRef.INIT();
        lFields := lRecordRef.FIELDCOUNT();
        lFieldIndex := 0;
        lSearching := TRUE;
        WHILE (lSearching) DO
        BEGIN
          lFieldIndex += 1;
          IF (lFieldIndex <= lFields) THEN
          BEGIN
            lFieldRef := lRecordRef.FIELDINDEX(lFieldIndex);
            lField.GET(lRecordRef.NUMBER(), lFieldRef.NUMBER());
            IF (( NOT (lField.Type IN [lField.Type::Binary, lField.Type::BLOB, lField.Type::GUID, lField.Type::Option,
                  lField.Type::RecordID, lField.Type::TableFilter])) AND (lFieldRef.RELATION() = 0)) THEN
            BEGIN
              lRecordNo := FORMAT(lFieldRef.VALUE(), 0, 1);
              lSearching := FALSE;
            END;
          END
          ELSE
            lSearching := FALSE;
        END;
        lRecordRef.CLOSE();
      END;

      EXIT(lRecordNo);
    END;

    PROCEDURE GetRecordDescription@1000000069(TableNo@1000000004 : Integer;PositionText@1000000005 : Text) Name : Text;
    VAR
      Fields@1000000003 : Record 2000000041;
      RecRef@1000000002 : RecordRef;
      Contact@1000000000 : Record 5050;
      Name2@1000000001 : Text;
    BEGIN
      //DOC PC 04/02/2014 >>
      IF TableNo = 0 THEN EXIT;
      IF PositionText = '' THEN EXIT;
      RecRef.OPEN(TableNo);
      RecRef.SETPOSITION(PositionText);

      IF NOT RecRef.GET(RecRef.RECORDID) THEN EXIT;

      Fields.SETRANGE(TableNo,TableNo);
      IF NOT Fields.FINDSET THEN EXIT;

      IF TableNo = DATABASE::Contact THEN BEGIN
        Contact.SETPOSITION(PositionText);
        Contact.SETRECFILTER;
        Contact.FINDFIRST;
        CASE Contact.Type OF
          Contact.Type::Company :
            BEGIN
              EXIT(Contact.Name);
            END;
          Contact.Type::Person :
            BEGIN
              IF Contact."Company Name" = '' THEN
                EXIT(Contact.Name)
              ELSE BEGIN
                EXIT(Contact.Name + ' at ' + Contact."Company Name");
              END;
            END;
        END;
      END;

      Fields.SETRANGE(FieldName,'Name');
      IF Fields.FINDFIRST THEN BEGIN
        Name := GetFieldValue(RecRef,Fields.FieldName);
        IF Name <> '' THEN EXIT;
      END;

      Fields.SETRANGE(FieldName,'Description');
      IF Fields.FINDFIRST THEN BEGIN
        Name := GetFieldValue(RecRef,Fields.FieldName);
        IF Name <> '' THEN EXIT;
      END;

      Fields.SETRANGE(FieldName,'Posting Description');
      IF Fields.FINDFIRST THEN BEGIN
        Name := GetFieldValue(RecRef,Fields.FieldName);
        Fields.SETRANGE(FieldName,'Document No.');
        IF Fields.FINDFIRST THEN BEGIN
          Name2 := GetFieldValue(RecRef,Fields.FieldName);
        END ELSE BEGIN
          Fields.SETRANGE(FieldName,'No.');
          IF Fields.FINDFIRST THEN BEGIN
            Name2 := GetFieldValue(RecRef,Fields.FieldName);
          END;
        END;

        Fields.SETRANGE(FieldName,'Document Type');
        IF Fields.FINDFIRST THEN BEGIN
          Name2 := GetFieldValue(RecRef,Fields.FieldName) + ' ' + Name2;
        END;

        IF Name2 <> '' THEN BEGIN
          IF Name2 <> Name THEN Name := Name2 + ' : ' + Name;
          EXIT;
        END;
      END;

      Fields.SETRANGE(FieldName,'Document Type');
      IF Fields.FINDFIRST THEN BEGIN
        Name := GetFieldValue(RecRef,Fields.FieldName);
        Fields.SETRANGE(FieldName,'Document No.');
        IF Fields.FINDFIRST THEN BEGIN
          Name += ' ' + GetFieldValue(RecRef,Fields.FieldName);
          Fields.SETRANGE(FieldName,'Line No.');
          IF Fields.FINDFIRST THEN BEGIN
            Name += ' Line ' + GetFieldValue(RecRef,Fields.FieldName);
            IF Name <> '' THEN EXIT;
          END;
        END ELSE BEGIN
          Fields.SETRANGE(FieldName,'No.');
          IF Fields.FINDFIRST THEN BEGIN
            Name += GetFieldValue(RecRef,Fields.FieldName);
            IF Name <> '' THEN EXIT;
          END;
        END;
      END;

      EXIT(RecRef.GETPOSITION);
    END;

    PROCEDURE GetTableName@1000000071(TableNo@1000000000 : Integer) Name : Text;
    VAR
      RecRef@1000000001 : RecordRef;
    BEGIN
      IF TableNo = 0 THEN EXIT(FORMAT(TableNo));
      RecRef.OPEN(TableNo);
      EXIT(RecRef.NAME);
    END;

    PROCEDURE GetRecordAddress@1000000037(TableNo@1000000001 : Integer;PositionText@1000000000 : Text;VAR AddressText@1000000004 : Text) AddressValue : Text;
    VAR
      Fields@1000000003 : Record 2000000041;
      RecRef@1000000002 : RecordRef;
      CurrVal@1000000005 : Text;
      EnhFieldMgt@1000000006 : Codeunit 9062298;
    BEGIN
      AddressText := '';
      IF TableNo = 0 THEN EXIT('');
      RecRef.OPEN(TableNo);
      RecRef.SETPOSITION(PositionText);
      IF NOT RecRef.GET(RecRef.RECORDID) THEN EXIT('');

      Fields.SETRANGE(TableNo,TableNo);
      IF NOT Fields.FINDSET THEN EXIT;

      Fields.SETRANGE(FieldName,'Post Code');
      IF Fields.FINDFIRST THEN BEGIN
        CurrVal := EnhFieldMgt.GetFieldValue(RecRef,Fields.FieldName);
        IF CurrVal <> '' THEN BEGIN
          IF AddressValue = '' THEN AddressValue := CurrVal;
        END;
      END;

      Fields.SETRANGE(FieldName,'Address');
      IF Fields.FINDFIRST THEN BEGIN
        CurrVal := EnhFieldMgt.GetFieldValue(RecRef,Fields.FieldName);
        IF CurrVal <> '' THEN BEGIN
          IF AddressValue = '' THEN AddressValue := CurrVal;
          IF AddressText <> '' THEN AddressText := AddressText + ', ';
          AddressText := AddressText + CurrVal;
        END;
      END;

      Fields.SETRANGE(FieldName,'Address 2');
      IF Fields.FINDFIRST THEN BEGIN
        CurrVal := EnhFieldMgt.GetFieldValue(RecRef,Fields.FieldName);
        IF CurrVal <> '' THEN BEGIN
          IF AddressValue = '' THEN AddressValue := CurrVal;
          IF AddressText <> '' THEN AddressText := AddressText + ', ';
          AddressText := AddressText + CurrVal;
        END;
      END;

      Fields.SETRANGE(FieldName,'City');
      IF Fields.FINDFIRST THEN BEGIN
        CurrVal := EnhFieldMgt.GetFieldValue(RecRef,Fields.FieldName);
        IF CurrVal <> '' THEN BEGIN
          IF AddressValue = '' THEN AddressValue := CurrVal;
          IF AddressText <> '' THEN AddressText := AddressText + ', ';
          AddressText := AddressText + CurrVal;
        END;
      END;

      Fields.SETRANGE(FieldName,'County');
      IF Fields.FINDFIRST THEN BEGIN
        CurrVal := EnhFieldMgt.GetFieldValue(RecRef,Fields.FieldName);
        IF CurrVal <> '' THEN BEGIN
          IF AddressValue = '' THEN AddressValue := CurrVal;
          IF AddressText <> '' THEN AddressText := AddressText + ', ';
          AddressText := AddressText + CurrVal;
        END;
      END;

      Fields.SETRANGE(FieldName,'Post Code');
      IF Fields.FINDFIRST THEN BEGIN
        CurrVal := EnhFieldMgt.GetFieldValue(RecRef,Fields.FieldName);
        IF CurrVal <> '' THEN BEGIN
          IF AddressValue = '' THEN AddressValue := CurrVal;
          IF AddressText <> '' THEN AddressText := AddressText + ', ';
          AddressText := AddressText + CurrVal;
        END;
      END;

      Fields.SETRANGE(FieldName,'Country/Region Code');
      IF Fields.FINDFIRST THEN BEGIN
        CurrVal := EnhFieldMgt.GetFieldValue(RecRef,Fields.FieldName);
        IF CurrVal <> '' THEN BEGIN
          IF AddressValue = '' THEN AddressValue := CurrVal;
          IF AddressText <> '' THEN AddressText := AddressText + ', ';
          AddressText := AddressText + CurrVal;
        END;
      END;
    END;

    PROCEDURE CurrentUser@1000000080() "User ID" : Code[50];
    BEGIN
      "User ID" := SysB.GetText(tCurrentUserSysB);
      IF "User ID" = '' THEN "User ID" := USERID;
    END;

    PROCEDURE ClearCurrentContact@9062229();
    BEGIN
      IF SysB.GET(tCurrentContactSysB,USERID) THEN
        SysB.DELETE(TRUE);
    END;

    PROCEDURE SetCurrentUser@1000000083(SetToUserID@1000000000 : Code[50]);
    VAR
      eSysB_Name@1000000001 : TextConst 'ENU=User ID of the currently active user;ENG=User ID of the currently active user';
      eSysB_Desc@1000000002 : TextConst 'ENU=Set by nOra to represent the user it''s acting on behalf of;ENG=Set by nOra to represent the user it''s acting on behalf of';
      Logger@1000000003 : Record 9062280;
      eLogMsg@1000000004 : TextConst 'ENU=Setting Current User to %1;ENG=Setting Current User to %1';
      nAblementUser@1000000005 : Record 9062729;
    BEGIN
      Logger.Log('UTILS',Logger.Type::Debug,STRSUBSTNO(eLogMsg,SetToUserID),USERID);

      IF NOT nAblementUser.GET(SetToUserID) THEN SetToUserID := USERID;

      IF NOT SysB.GET(tCurrentUserSysB,USERID) THEN BEGIN
        SysB.INIT;
        SysB.VALIDATE(Code,tCurrentUserSysB);
        SysB.VALIDATE("User ID",USERID);
        SysB.INSERT(TRUE);
      END;

      SysB.VALIDATE(Name,eSysB_Name);
      SysB.VALIDATE(Description,eSysB_Desc);
      SysB.VALIDATE("Answer Type",SysB."Answer Type"::Text);
      SysB.VALIDATE(Answer,SetToUserID);
      SysB.MODIFY(TRUE);
    END;

    PROCEDURE CurrentContact@1000000082() ContactNo : Code[20];
    BEGIN
      ContactNo := SysB.GetText(tCurrentContactSysB);

      IF ContactNo = '' THEN BEGIN
        ContactNo := GetUserContactNo(CurrentUser);
      END;
    END;

    PROCEDURE SetCurrentContact@1000000081(SetToContactNo@1000000000 : Code[20]);
    VAR
      eSysB_Name@1000000001 : TextConst 'ENU=Contact No. of the currently active user;ENG=Contact No. of the currently active user';
      eSysB_Desc@1000000002 : TextConst 'ENU=Set by nOra to represent the Contact it''s acting on behalf of;ENG=Set by nOra to represent the Contact it''s acting on behalf of';
      Logger@1000000003 : Record 9062280;
      eLogMsg@1000000004 : TextConst 'ENU=Setting Current Contact to %1;ENG=Setting Current Contact to %1';
      Contact@1000000005 : Record 5050;
    BEGIN
      Logger.Log('UTILS',Logger.Type::Debug,STRSUBSTNO(eLogMsg,SetToContactNo),USERID);

      IF NOT Contact.GET(SetToContactNo) THEN SetToContactNo := '';

      IF NOT SysB.GET(tCurrentContactSysB,USERID) THEN BEGIN
        SysB.INIT;
        SysB.VALIDATE(Code,tCurrentContactSysB);
        SysB.VALIDATE("User ID",USERID);
        SysB.INSERT(TRUE);
      END;

      SysB.VALIDATE(Name,eSysB_Name);
      SysB.VALIDATE(Description,eSysB_Desc);
      SysB.VALIDATE("Answer Type",SysB."Answer Type"::Text);
      SysB.VALIDATE(Answer,SetToContactNo);
      SysB.MODIFY(TRUE);
    END;

    PROCEDURE RemoveEmailHTMLTags@1000000084(VAR BodyText@1000000000 : Text[1024]) : Text[1024];
    BEGIN
      BodyText := String.Replace(BodyText,'</t:Body>','');
      BodyText := String.Replace(BodyText,'</T:BODY>','');

      EXIT(BodyText);
    END;

    PROCEDURE CalcWorkingHours@1000000087("Start Date"@1000000012 : Date;"Start Time"@1000000014 : Time;"End Date"@1000000013 : Date;"End Time"@1000000015 : Time;"All Day"@1000000016 : Boolean) "No. Working Hours" : Decimal;
    VAR
      MaxHoursInDay@1000000001 : Decimal;
      DayStartTime@1000000002 : Time;
      DayEndTime@1000000004 : Time;
      IncludeWeekends@1000000009 : Boolean;
      NoDays@1000000000 : Integer;
      CurrDate@1000000003 : Date;
      CurrStartTime@1000000005 : Time;
      CurrEndTime@1000000006 : Time;
      CurrNoHours@1000000007 : Decimal;
      TotalNoHours@1000000008 : Decimal;
      i@1000000010 : Integer;
      NoWeekendDays@1000000011 : Integer;
    BEGIN
      //DOC PC 28/01/2015 NA2015.4
      MaxHoursInDay := SysB.GetDecimal('MAXHOURSINDAY');
      IF MaxHoursInDay = 0 THEN MaxHoursInDay := 8;

      EVALUATE(DayStartTime,SysB.GetText('DAYSTARTTIME'));
      IF DayStartTime = 0T THEN DayStartTime := 090000T;

      EVALUATE(DayEndTime,SysB.GetText('DAYENDTIME'));
      IF DayEndTime = 0T THEN DayEndTime := 173000T;

      IncludeWeekends := SysB.GetBoolean('WORKWEEKENDS');

      NoDays := ("End Date" - "Start Date") + 1;

      CASE NoDays OF
        1 :
          BEGIN
            IF "All Day" THEN BEGIN
              TotalNoHours := MaxHoursInDay;
            END ELSE BEGIN
              IF "Start Time" < DayStartTime THEN CurrStartTime := DayStartTime ELSE CurrStartTime:= "Start Time";
              IF "End Time" > DayEndTime THEN CurrEndTime := DayEndTime ELSE CurrEndTime := "End Time";

              CurrNoHours := CurrEndTime - CurrStartTime;
              IF CurrNoHours > 0 THEN CurrNoHours := CurrNoHours/1000/60/60;
              IF CurrNoHours > MaxHoursInDay THEN CurrNoHours := MaxHoursInDay;

              TotalNoHours := CurrNoHours;
            END;
          END;
        ELSE
          BEGIN
            IF "All Day" THEN BEGIN
              TotalNoHours := MaxHoursInDay*NoDays;
            END ELSE BEGIN
              //First Day
              IF "Start Time" < DayStartTime THEN CurrStartTime := DayStartTime ELSE CurrStartTime:= "Start Time";
              CurrEndTime := DayEndTime;

              CurrNoHours := CurrEndTime - CurrStartTime;
              IF CurrNoHours > 0 THEN CurrNoHours := CurrNoHours/1000/60/60;
              IF CurrNoHours > MaxHoursInDay THEN CurrNoHours := MaxHoursInDay;

              TotalNoHours += CurrNoHours;

              //Last Day
              CurrStartTime := DayStartTime;
              IF "End Time" > DayEndTime THEN CurrEndTime := DayEndTime ELSE CurrEndTime := "End Time";

              CurrNoHours := CurrEndTime - CurrStartTime;
              IF CurrNoHours > 0 THEN CurrNoHours := CurrNoHours/1000/60/60;
              IF CurrNoHours > MaxHoursInDay THEN CurrNoHours := MaxHoursInDay;

              TotalNoHours += CurrNoHours;

              //Add days in between
              TotalNoHours += MaxHoursInDay*(NoDays-2);
            END;
          END;
      END;

      IF NOT IncludeWeekends THEN BEGIN
        CurrDate := "Start Date";
        REPEAT
          IF (DATE2DWY(CurrDate,1) >= 6) THEN NoWeekendDays += 1;
          CurrDate += 1;
        UNTIL CurrDate > "End Date";

        IF NoWeekendDays > 0 THEN TotalNoHours := TotalNoHours - (NoWeekendDays*MaxHoursInDay);
      END;

      IF TotalNoHours < 0 THEN
        "No. Working Hours" := 0
      ELSE
        "No. Working Hours" := TotalNoHours;
    END;

    PROCEDURE CalcWorkingDays@1000000085("Start Date"@1000000004 : Date;"Start Time"@1000000003 : Time;"End Date"@1000000002 : Date;"End Time"@1000000001 : Time;"All Day"@1000000000 : Boolean) "No. Working Days" : Decimal;
    VAR
      MaxHoursInDay@1000000005 : Decimal;
      NoWorkingHours@1000000006 : Decimal;
    BEGIN
      //DOC PC 28/01/2015 NA2015.4
      MaxHoursInDay := SysB.GetDecimal('MAXHOURSINDAY');
      IF MaxHoursInDay = 0 THEN MaxHoursInDay := 8;

      NoWorkingHours := CalcWorkingHours("Start Date","Start Time","End Date","End Time","All Day");
      EXIT(NoWorkingHours/MaxHoursInDay);
    END;

    PROCEDURE GetImageExtension@1000000088(VAR TemplBlob@1000000000 : Record 99008535;VAR Extension@1000000001 : Text[10]) IsImage : Boolean;
    VAR
      Image@1000000002 : DotNet "'System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'.System.Drawing.Image";
      ImageFormat@1000000003 : DotNet "'System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a'.System.Drawing.Imaging.ImageFormat";
      MemStream@1000000004 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.IO.MemoryStream";
      Convert@1000000005 : DotNet "'mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Convert";
      InStr@1000000006 : InStream;
    BEGIN
      IF NOT TemplBlob.Blob.HASVALUE THEN BEGIN
        EXIT(FALSE);
      END ELSE BEGIN
        TemplBlob.CALCFIELDS(Blob);
        TemplBlob.Blob.CREATEINSTREAM(InStr);
        MemStream := MemStream.MemoryStream;
        COPYSTREAM(MemStream,InStr);
        Image := Image.FromStream(MemStream);
        ImageFormat := Image.RawFormat;
        CASE TRUE OF
           ImageFormat.Equals(ImageFormat.Gif): Extension := 'gif';
           ImageFormat.Equals(ImageFormat.Jpeg): Extension := 'jpg';
           ImageFormat.Equals(ImageFormat.Png): Extension := 'png';
           ImageFormat.Equals(ImageFormat.Bmp): Extension := 'bmp';
           ImageFormat.Equals(ImageFormat.Icon): Extension := 'Icon';
           ImageFormat.Equals(ImageFormat.Tiff): Extension := 'Tiff';
        END;
        EXIT(TRUE);
      END;
    END;

    PROCEDURE ConvertHTMLToText@1000000089(HTMLText@1000000000 : Text) InnerText : Text;
    VAR
      PSMPowershellWrapper@1000000012 : Codeunit 9062554;
      PSMPsObjectCollection@1000000011 : Codeunit 9062555;
      PSMSetup@1000000009 : Record 9062714;
    BEGIN
      PSMSetup.GET;
      WITH PSMPowershellWrapper DO BEGIN
        OpenRunspace(PSMSetup."Default Server Name",PSMSetup.GetLoginID,PSMSetup.GetPassword);
        PSMPowershellWrapper.AddScript('$WebContent = Invoke-WebRequest -Uri ''http://localhost'';'
                                        + '$WebContent.ParsedHtml.body.innerHTML = ' + '''' + HTMLText + ''';'
                                        + 'Return $WebContent.ParsedHtml.body');

        InvokeCommands(PSMPsObjectCollection);
        IF (PSMPsObjectCollection.FINDFIRST) THEN REPEAT
          InnerText := PSMPsObjectCollection.GetPropertyValueText('innerText');
          EXIT(InnerText);
        UNTIL PSMPsObjectCollection.NEXT < 1;
        CloseRunspace();
      END;
    END;

    PROCEDURE "--- Excel Formats ---"@1000000098();
    BEGIN
    END;

    PROCEDURE ExcelIntegerFormat@1000000097() : Text[20];
    BEGIN
      //DOC NA2015.1 - Returning Excel integer format
      //  <- The format

      EXIT('0');
    END;

    PROCEDURE ExcelDecimalFormat@1000000096() : Text[20];
    BEGIN
      //DOC NA2015.1 - Returning Excel decimal format
      //  <- The format

      EXIT('0.00');
    END;

    PROCEDURE ExcelDateFormat@1000000095() : Text[20];
    VAR
      lFormat@1000000000 : Text[10];
    BEGIN
      //DOC NA2015.1 - Returning Excel date format
      //  <- The format

      lFormat := FORMAT(DMY2DATE(22, 11, 3344));
      lFormat := String.Replace(lFormat, '22', 'dd');
      lFormat := String.Replace(lFormat, '11', 'mm');
      lFormat := String.Replace(lFormat, '33', 'yy');
      lFormat := String.Replace(lFormat, '44', 'yy');

      EXIT(lFormat);
    END;

    PROCEDURE ExcelTimeFormat@1000000094() : Text[20];
    BEGIN
      //DOC NA2015.1 - Returning Excel time format
      //  <- The format

      EXIT('hh:mm');
    END;

    PROCEDURE ExcelDateTimeFormat@1000000093() : Text[20];
    BEGIN
      //DOC NA2015.1 - Returning Excel datetime format
      //  <- The format

      EXIT(ExcelDateFormat() + ' ' + ExcelTimeFormat());
    END;

    PROCEDURE "---RegExp---"@1000000074();
    BEGIN
    END;

    PROCEDURE GetValueFromText@1000000075(SearchString@1000000000 : Text;RegExp@1000000001 : Text;VAR ReturnValue@1000000002 : Text;VAR ReturnValuePos@1000000005 : Integer;VAR ReturnValueLength@1000000006 : Integer) Found : Boolean;
    VAR
      dnRegEx@1000000004 : DotNet "'System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.RegularExpressions.Regex";
      dnMatch@1000000003 : DotNet "'System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089'.System.Text.RegularExpressions.Match";
    BEGIN
      IF (SearchString = '') THEN EXIT(FALSE);

      dnMatch := dnRegEx.Match(SearchString,RegExp);

      IF dnMatch.Success THEN
      BEGIN
        ReturnValue := dnMatch.Value();
        ReturnValuePos := dnMatch.Index();
        ReturnValueLength := dnMatch.Length();
        EXIT(TRUE);
      END ELSE
        EXIT(FALSE);
    END;

    PROCEDURE GetRegExpFromText@1000000078(TextExpression@1000000000 : Text;VAR RegExpression@1000000001 : Text) Success : Boolean;
    VAR
      TxtCharsToKeep@1000000002 : Text;
      MyText@1000000003 : Text;
      AlphaText@1000000004 : Text;
      AlphaRegExp@1000000005 : Text;
      Length@1000000007 : Integer;
      Pos@1000000008 : Integer;
      Digits@1000000006 : Integer;
      int@1000000009 : Integer;
    BEGIN
      TxtCharsToKeep := 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 -';
      TextExpression := DELCHR(TextExpression,'=',DELCHR(TextExpression,'=',TxtCharsToKeep));

      AlphaRegExp := '[a-z|A-Z]+';
      //Find if TextExpressions contains AlphaNumeric Characters
      IF GetValueFromText(TextExpression,AlphaRegExp,AlphaText,Pos,Length) THEN
      BEGIN
        IF EVALUATE(int,COPYSTR(TextExpression,STRLEN(AlphaText)+1)) THEN
        BEGIN
          Digits := STRLEN(COPYSTR(TextExpression,STRLEN(AlphaText)))-1;
          RegExpression := '\b' + AlphaText + '\d{' + FORMAT(Digits) + '}\b';
          EXIT(TRUE);
        END ELSE
        BEGIN
          RegExpression := '\b' + AlphaText + '\b';
          EXIT(TRUE);
        END;
      END ELSE
      //Find if TextExpression contains just Numeric Characters
      BEGIN
        IF EVALUATE(int,TextExpression) THEN
        BEGIN
          RegExpression := '\b\d{' + FORMAT(STRLEN(TextExpression))  + '}\b';
          EXIT(TRUE);
        END;
      END;
      EXIT(FALSE);
    END;

    PROCEDURE GETBASEURL@1000000086(VAR URL@1000000000 : Text) BASEURL : Text;
    VAR
      SystemBehaviour@1000000001 : Record 9062230;
      WrongURL@1000000002 : Text;
    BEGIN
      WrongURL := COPYSTR(URL,1,STRPOS(URL,':8080')-1);
      URL := String.Replace(URL,WrongURL,'https://demo.navondemand.co.uk');
      EXIT(URL);
    END;

    BEGIN
    {
      //DOC NA2015.1  JH 10/08/2012 - Migrated to 2013
      //DOC NA2015.1  AP 23/01/2013 - Added IsWorkflowInUse function
      //DOC NA2015.1  PC 25/02/2013 - Added Function SetFieldValueFromText
      //DOC NA2015.1  PC 26/02/2013 - Changed "CreatePageHyperlink" function to look for Page No. using Datasets if no Page No. provided
      //DOC NA2015.1  AP 22/05/2013 - Run Classic Form from Historical System
      //DOC NA2015.1  JH 10/07/2013 - "ClearFieldRef" added
      //DOC NA2015.1  PC 02/08/2013 - Changes to replace Jet Param names in text strings with the param values
      //DOC NA2015.1  PC 15/08/2013 - Changed "FieldLookup" function to use Dataset Fields if System Behaviour is set
      //DOC NA2015.1  PC 25/03/2014 - Removed reliance on AutoNAV Tasks
      //DOC NA2015.1  PC 08/04/2014 - Added "Trim" and "CountWordsInString" functions
      //DOC NA2015.1  PC 08/04/2014 - Added "RunCardPage" and "RunListPage" functions
      //DOC NA2015.1  AP 02/05/2014 - Added "RegExp" functionality
      //DOC NA2015.1  AP 06/05/2014 - Added "UpdateNoSeriesRegExp" function
      //DOC NA2015.3  PC 14/08/2014 - Added THISWEEK,LASTWEEK,NEXTWEEK Smart Filters
      //DOC NA2015.3  PC 14/08/2014 - Added USER.[ functions to smart filters
      //DOC NA2015.3  PC 18/08/2014 - Added CurrentUser and SetCurrentUser functions
      //DOC NA2015.3  PC 18/08/2014 - Added CurrentContact and SetCurrentContact functions
      //DOC NA2015.3  AP 02/09/2014 - Added RemoveEmailHTMLTags function
      //DOC NA2015.4  PC 24/10/2014 - NAV on Demand modifications
      //DOC NA2015.4  JH 03/11/2014 - Upgraded to 2015
      //DOC NA2015.4  JH 28/12/2014 - System behaviours renamed
      //DOC NA2015.4  PC 28/01/2015 - Added Functions "CalcWorkingHours" and "CalcWorkingDays"
      //DOC NA2015.6  JH 10/04/2015 - MYLOCATION added
      //DOC NA2015.7  AP 26/05/2015 - fix issue where the [Field]  is not a word and is part of a word or formula ex. http://www.google.com/search?=[Description]
      //DOC NA2015.7  AP 26/05/2015 - Added GetImageExtension function
      //DOC NA2016.10 JH 26/08/2015 - Upgraded to 2016
      //DOC NA2016.12 JH 10/12/2015 - New function "GetRecordNo"
      //DOC NA2016.12 JH 22/01/2016 - "LASTMONTH" added to smart filtering
      //DOC NA2016.12 JH 28/01/2016 - String functions moved to "String" codeunit
      //DOC NA2016.14 JH 14/03/2016 - "SetFieldValueFromText" redirected to "RecordRefManagement" dodeunit
      //DOC NA2016.14 JH 23/03/2016 - Bugfixes
      //DOC NA2016.15 JH 15/04/2016 - CfMD amendments
    }
    END.
  }
}

